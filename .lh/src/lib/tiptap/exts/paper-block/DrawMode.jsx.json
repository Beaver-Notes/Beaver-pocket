{
    "sourceFile": "src/lib/tiptap/exts/paper-block/DrawMode.jsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 12,
            "patches": [
                {
                    "date": 1731678443885,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1731678452868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -485,11 +485,11 @@\n             d={item.path}\n             stroke={\n               isDarkMode\n                 ? item.color === \"#FFFFFF\"\n-                  ? \"#FFFFFF\" // White text for dark mode\n+                  ? \"#000000\" // White text for dark mode\n                   : item.color // Keep original color\n-                : item.color === \"#FFFFFF\"\n+                : item.color === \"#000000\"\n                 ? \"#000000\"\n                 : item.color // Keep original color\n             }\n             strokeWidth={item.size}\n"
                },
                {
                    "date": 1731678601973,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -487,11 +487,8 @@\n               isDarkMode\n                 ? item.color === \"#FFFFFF\"\n                   ? \"#000000\" // White text for dark mode\n                   : item.color // Keep original color\n-                : item.color === \"#000000\"\n-                ? \"#000000\"\n-                : item.color // Keep original color\n             }\n             strokeWidth={item.size}\n             opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n             fill=\"none\"\n@@ -721,5 +718,5 @@\n     </div>\n   );\n };\n \n-export default DrawMode;\n\\ No newline at end of file\n+export default DrawMode;\n"
                },
                {
                    "date": 1731678800264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -484,11 +484,12 @@\n             key={`${item.id}-${item.color}-${item.size}`}\n             d={item.path}\n             stroke={\n               isDarkMode\n-                ? item.color === \"#FFFFFF\"\n-                  ? \"#000000\" // White text for dark mode\n-                  : item.color // Keep original color\n+                ? item.color === \"#000000\"\n+                  ? \"#FFFFFF\"\n+                  : item.color\n+                : item.color\n             }\n             strokeWidth={item.size}\n             opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n             fill=\"none\"\n"
                },
                {
                    "date": 1731691174865,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -523,8 +523,9 @@\n         <div className=\"flex items-center space-x-2\">\n           <button\n             onClick={() => {\n               setTool(\"pencil\");\n+              setColor(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n             }}\n             onMouseDown={(e) => e.preventDefault()}\n             className={`flex items-center justify-center p-2 border ${\n               tool === \"pencil\"\n"
                },
                {
                    "date": 1731691336474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -474,8 +474,16 @@\n     }\n     return chunks;\n   }, [linesRef.current.length]);\n \n+  const adjustColorForMode = (color) => {\n+    if (isDarkMode) {\n+      return color === \"#000000\" ? \"#FFFFFF\" : color === \"#FFFFFF\" ? \"#000000\" : color;\n+    } else {\n+      return color === \"#FFFFFF\" ? \"#000000\" : color === \"#000000\" ? \"#FFFFFF\" : color;\n+    }\n+  };  \n+\n   // Optimize path rendering\n   const renderPaths = () =>\n     chunkedLines.map((chunk, chunkIndex) => (\n       <g key={`chunk-${chunkIndex}`}>\n"
                },
                {
                    "date": 1731691346594,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -490,15 +490,9 @@\n         {chunk.map((item) => (\n           <path\n             key={`${item.id}-${item.color}-${item.size}`}\n             d={item.path}\n-            stroke={\n-              isDarkMode\n-                ? item.color === \"#000000\"\n-                  ? \"#FFFFFF\"\n-                  : item.color\n-                : item.color\n-            }\n+            stroke={adjustColorForMode(item.color)}\n             strokeWidth={item.size}\n             opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n             fill=\"none\"\n             vectorEffect=\"non-scaling-stroke\"\n"
                },
                {
                    "date": 1731691358595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -709,10 +709,9 @@\n           {path && (\n             <path\n               ref={activePathRef}\n               d={path}\n-              stroke={color}\n-              strokeWidth={size}\n+              stroke={adjustColorForMode(color)}               strokeWidth={size}\n               opacity={tool === \"highlighter\" ? 0.3 : 1}\n               fill=\"none\"\n               vectorEffect=\"non-scaling-stroke\"\n             />\n"
                },
                {
                    "date": 1731691597124,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -474,25 +474,23 @@\n     }\n     return chunks;\n   }, [linesRef.current.length]);\n \n-  const adjustColorForMode = (color) => {\n-    if (isDarkMode) {\n-      return color === \"#000000\" ? \"#FFFFFF\" : color === \"#FFFFFF\" ? \"#000000\" : color;\n-    } else {\n-      return color === \"#FFFFFF\" ? \"#000000\" : color === \"#000000\" ? \"#FFFFFF\" : color;\n-    }\n-  };  \n-\n   // Optimize path rendering\n   const renderPaths = () =>\n     chunkedLines.map((chunk, chunkIndex) => (\n       <g key={`chunk-${chunkIndex}`}>\n         {chunk.map((item) => (\n           <path\n             key={`${item.id}-${item.color}-${item.size}`}\n             d={item.path}\n-            stroke={adjustColorForMode(item.color)}\n+            stroke={\n+              isDarkMode\n+                ? item.color === \"#000000\"\n+                  ? \"#FFFFFF\"\n+                  : item.color\n+                : item.color\n+            }\n             strokeWidth={item.size}\n             opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n             fill=\"none\"\n             vectorEffect=\"non-scaling-stroke\"\n@@ -525,9 +523,8 @@\n         <div className=\"flex items-center space-x-2\">\n           <button\n             onClick={() => {\n               setTool(\"pencil\");\n-              setColor(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n             }}\n             onMouseDown={(e) => e.preventDefault()}\n             className={`flex items-center justify-center p-2 border ${\n               tool === \"pencil\"\n@@ -709,9 +706,10 @@\n           {path && (\n             <path\n               ref={activePathRef}\n               d={path}\n-              stroke={adjustColorForMode(color)}               strokeWidth={size}\n+              stroke={color}\n+              strokeWidth={size}\n               opacity={tool === \"highlighter\" ? 0.3 : 1}\n               fill=\"none\"\n               vectorEffect=\"non-scaling-stroke\"\n             />\n"
                },
                {
                    "date": 1731691680424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -474,8 +474,18 @@\n     }\n     return chunks;\n   }, [linesRef.current.length]);\n \n+  const adjustColorForMode = (color) => {\n+    if (isDarkMode) {\n+      // Dark mode: Black turns to white; other colors unchanged\n+      return color === \"#000000\" ? \"#FFFFFF\" : color;\n+    } else {\n+      // Light mode: White turns to black; other colors unchanged\n+      return color === \"#FFFFFF\" ? \"#000000\" : color;\n+    }\n+  };\n+\n   // Optimize path rendering\n   const renderPaths = () =>\n     chunkedLines.map((chunk, chunkIndex) => (\n       <g key={`chunk-${chunkIndex}`}>\n@@ -523,8 +533,9 @@\n         <div className=\"flex items-center space-x-2\">\n           <button\n             onClick={() => {\n               setTool(\"pencil\");\n+              setColor(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n             }}\n             onMouseDown={(e) => e.preventDefault()}\n             className={`flex items-center justify-center p-2 border ${\n               tool === \"pencil\"\n"
                },
                {
                    "date": 1731691690143,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -492,15 +492,9 @@\n         {chunk.map((item) => (\n           <path\n             key={`${item.id}-${item.color}-${item.size}`}\n             d={item.path}\n-            stroke={\n-              isDarkMode\n-                ? item.color === \"#000000\"\n-                  ? \"#FFFFFF\"\n-                  : item.color\n-                : item.color\n-            }\n+            stroke={adjustColorForMode(item.color)}\n             strokeWidth={item.size}\n             opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n             fill=\"none\"\n             vectorEffect=\"non-scaling-stroke\"\n"
                },
                {
                    "date": 1731691697568,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -711,9 +711,9 @@\n           {path && (\n             <path\n               ref={activePathRef}\n               d={path}\n-              stroke={color}\n+              stroke={adjustColorForMode(color)}\n               strokeWidth={size}\n               opacity={tool === \"highlighter\" ? 0.3 : 1}\n               fill=\"none\"\n               vectorEffect=\"non-scaling-stroke\"\n"
                },
                {
                    "date": 1731701747831,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,728 @@\n+import React, { useState, useRef, useEffect, useMemo } from \"react\";\n+import * as d3 from \"d3\";\n+import { v4 as uuid } from \"uuid\";\n+import { Keyboard } from \"@capacitor/keyboard\";\n+import Icons from \"../../../remixicon-react\";\n+\n+const thicknessOptions = {\n+  thin: 2,\n+  medium: 3,\n+  thick: 4,\n+  thicker: 5,\n+  thickest: 6,\n+};\n+\n+const backgroundStyles = {\n+  none: \"\",\n+  grid: \"grid\",\n+  ruled: \"ruled\",\n+  dotted: \"dotted\",\n+};\n+\n+const BUFFER_ZONE = 50;\n+const INCREMENT_HEIGHT = 200;\n+const PREVIEW_HEIGHT = 500;\n+\n+const DrawMode = ({ onClose, updateAttributes, node }) => {\n+  const isDarkMode = document.documentElement.classList.contains(\"dark\");\n+  const [isDrawing, setIsDrawing] = useState(false);\n+  const [drawingPath, setDrawingPath] = useState(\"\");\n+  const [lines, setLines] = useState([]);\n+  const pointsRef = useRef([]);\n+  const historyRef = useRef([]);\n+  const redoStackRef = useRef([]);\n+  const svgRef = useRef(null);\n+  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n+  const [size, setSize] = useState(thicknessOptions.thin);\n+  const [drawing, setDrawing] = useState(false);\n+  const [points, setPoints] = useState([]);\n+  const [path, setPath] = useState(\"\");\n+  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n+  const [svgWidth] = useState(500);\n+  const [tool, setTool] = useState(\"pencil\");\n+  const [history, setHistory] = useState([]);\n+  const [redoStack, setRedoStack] = useState([]);\n+  const [isResizing, setIsResizing] = useState(false);\n+  const [startY, setStartY] = useState(0);\n+  const [id] = useState(() => node.attrs.id || uuid());\n+  const colorInputRef = useRef(null);\n+  const [background, setBackground] = useState(\n+    node.attrs.paperType || backgroundStyles.none\n+  );\n+\n+  const linesRef = useRef(node.attrs.lines || []);\n+\n+  const handleBackgroundChange = (event) => {\n+    const newBackground = event.target.value;\n+    setBackground(newBackground);\n+    updateAttributes({ paperType: newBackground });\n+  };\n+\n+  useEffect(() => {\n+    const svg = d3.select(svgRef.current);\n+    const eraseRadius = 5;\n+    let isErasing = false;\n+    let penActive = false;\n+    let penTimeout = null;\n+\n+    const PEN_TIMEOUT_DURATION = 700;\n+\n+    const handlePointerEvent = (event) => {\n+      if (event.pointerType === \"pen\") {\n+        penActive = true;\n+        clearTimeout(penTimeout);\n+        event.preventDefault(); // Prevent touch interaction when pen is active\n+        event.stopPropagation();\n+\n+        const [x, y] = getPointerCoordinates(event);\n+\n+        if (event.type === \"pointerdown\") {\n+          if (tool === \"erase\") {\n+            isErasing = true;\n+            eraseOverlappingPaths(x, y);\n+          } else {\n+            startDrawing(x, y);\n+          }\n+        } else if (event.type === \"pointermove\") {\n+          if (tool === \"erase\" && isErasing) {\n+            eraseOverlappingPaths(x, y);\n+          } else if (tool !== \"erase\") {\n+            draw(x, y);\n+          }\n+        } else if (event.type === \"pointerup\") {\n+          if (tool === \"erase\") {\n+            isErasing = false;\n+          } else {\n+            stopDrawing();\n+          }\n+\n+          penTimeout = setTimeout(() => {\n+            penActive = false;\n+          }, PEN_TIMEOUT_DURATION);\n+        }\n+      }\n+    };\n+\n+    const eraseOverlappingPaths = (x, y) => {\n+      const eraserArea = {\n+        x: x - eraseRadius,\n+        y: y - eraseRadius,\n+        width: eraseRadius * 2,\n+        height: eraseRadius * 2,\n+      };\n+\n+      svg.selectAll(\"path\").each(function () {\n+        const path = d3.select(this);\n+        const pathNode = path.node();\n+        const pathBBox = pathNode.getBBox();\n+\n+        if (\n+          pathBBox.x < eraserArea.x + eraserArea.width &&\n+          pathBBox.x + pathBBox.width > eraserArea.x &&\n+          pathBBox.y < eraserArea.y + eraserArea.height &&\n+          pathBBox.y + pathBBox.height > eraserArea.y\n+        ) {\n+          deletePath(pathNode);\n+        }\n+      });\n+    };\n+\n+    // Prevent scrolling when the pencil (pen) is active\n+    const preventScrolling = (event) => {\n+      if (penActive) {\n+        event.preventDefault(); // Prevent scrolling\n+        event.stopPropagation();\n+      }\n+    };\n+\n+    // Attach pen input handlers on SVG\n+    svg\n+      .on(\"pointerdown\", handlePointerEvent)\n+      .on(\"pointermove\", handlePointerEvent)\n+      .on(\"pointerup\", handlePointerEvent);\n+\n+    // Block touch interactions (scrolling) when pen is active\n+    document.body.addEventListener(\"touchstart\", preventScrolling, {\n+      passive: false,\n+    });\n+    document.body.addEventListener(\"touchmove\", preventScrolling, {\n+      passive: false,\n+    });\n+    document.body.addEventListener(\"touchend\", preventScrolling, {\n+      passive: false,\n+    });\n+\n+    // Suppress context menu (e.g., copy/paste menu) on pen input\n+    svg.on(\"contextmenu\", (event) => {\n+      if (penActive) {\n+        event.preventDefault();\n+      }\n+    });\n+\n+    // Cleanup on component unmount\n+    return () => {\n+      clearTimeout(penTimeout);\n+      document.body.removeEventListener(\"touchstart\", preventScrolling);\n+      document.body.removeEventListener(\"touchmove\", preventScrolling);\n+      document.body.removeEventListener(\"touchend\", preventScrolling);\n+    };\n+  }, [tool, color, size, points]);\n+\n+  const deletePath = (pathElement) => {\n+    const clickedPathData = pathElement.getAttribute(\"d\");\n+    const pathIndex = linesRef.current.findIndex(\n+      (line) => line.path === clickedPathData\n+    );\n+\n+    if (pathIndex !== -1) {\n+      const removedLine = linesRef.current[pathIndex];\n+\n+      // Save the deletion action\n+      setHistory((prevHistory) => [\n+        ...prevHistory,\n+        { action: \"delete\", line: removedLine },\n+      ]);\n+\n+      linesRef.current.splice(pathIndex, 1);\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const handleMouseDown = (event) => {\n+    event.preventDefault();\n+  };\n+\n+  useEffect(() => {\n+    const svg = svgRef.current;\n+\n+    const preventContextMenu = (event) => event.preventDefault();\n+\n+    svg.addEventListener(\"contextmenu\", preventContextMenu);\n+\n+    return () => {\n+      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n+    };\n+  }, []);\n+\n+  useEffect(() => {\n+    const disableScroll = (event) => {\n+      if (isDrawing) {\n+        event.preventDefault();\n+      }\n+    };\n+\n+    document.addEventListener(\"touchmove\", disableScroll, { passive: false });\n+    document.addEventListener(\"wheel\", disableScroll, { passive: false });\n+\n+    return () => {\n+      document.removeEventListener(\"touchmove\", disableScroll);\n+      document.removeEventListener(\"wheel\", disableScroll);\n+    };\n+  }, [isDrawing]);\n+\n+  useEffect(() => {\n+    const handleMouseMove = (event) => {\n+      if (isResizing) {\n+        const currentY =\n+          event.clientY || (event.touches && event.touches[0].clientY);\n+        const deltaY = currentY - startY;\n+        setSvgHeight((prevHeight) => {\n+          const newHeight = Math.max(\n+            MIN_HEIGHT,\n+            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n+          );\n+          return newHeight;\n+        });\n+        setStartY(currentY);\n+      }\n+    };\n+\n+    const handleMouseUp = () => {\n+      if (isResizing) {\n+        setIsResizing(false);\n+        document.removeEventListener(\"mousemove\", handleMouseMove);\n+        document.removeEventListener(\"mouseup\", handleMouseUp);\n+        document.removeEventListener(\"touchmove\", handleMouseMove);\n+        document.removeEventListener(\"touchend\", handleMouseUp);\n+        saveHeight();\n+      }\n+    };\n+\n+    if (isResizing) {\n+      document.addEventListener(\"mousemove\", handleMouseMove);\n+      document.addEventListener(\"mouseup\", handleMouseUp);\n+      document.addEventListener(\"touchmove\", handleMouseMove);\n+      document.addEventListener(\"touchend\", handleMouseUp);\n+    }\n+\n+    return () => {\n+      document.removeEventListener(\"mousemove\", handleMouseMove);\n+      document.removeEventListener(\"mouseup\", handleMouseUp);\n+      document.removeEventListener(\"touchmove\", handleMouseMove);\n+      document.removeEventListener(\"touchend\", handleMouseUp);\n+    };\n+  }, [isResizing, startY]);\n+\n+  const getPointerCoordinates = (event) => {\n+    const svg = svgRef.current;\n+    const rect = svg.getBoundingClientRect();\n+\n+    // Get the correct pointer position, including page scroll and scale\n+    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n+    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n+\n+    // Calculate the mouse position relative to the SVG\n+    const scaleX = svg.viewBox.baseVal.width / rect.width;\n+    const scaleY = svg.viewBox.baseVal.height / rect.height;\n+\n+    const x = (clientX - rect.left) * scaleX;\n+    const y = (clientY - rect.top) * scaleY;\n+\n+    return [x, y];\n+  };\n+\n+  const startDrawing = (x, y) => {\n+    setDrawing(true);\n+    setPoints([{ x, y }]);\n+  };\n+\n+  const draw = (x, y) => {\n+    if (!drawing) return;\n+\n+    const newPoints = [...points, { x, y }];\n+    setPoints(newPoints);\n+    const newPath = lineGenerator(newPoints);\n+    setPath(newPath);\n+    if (y > svgHeight - BUFFER_ZONE) {\n+      const newHeight = svgHeight + INCREMENT_HEIGHT;\n+      setSvgHeight(newHeight);\n+      updateAttributes({ height: newHeight });\n+\n+      // Adjust scroll position to keep the drawing point in view\n+      const container = containerRef.current;\n+      if (container) {\n+        const scrollContainer = container.closest(\".drawing-component\");\n+        if (scrollContainer) {\n+          scrollContainer.scrollTo({\n+            top: scrollContainer.scrollHeight,\n+            behavior: \"smooth\",\n+          });\n+        }\n+      }\n+    }\n+  };\n+\n+  const stopDrawing = () => {\n+    if (drawing) {\n+      setDrawing(false);\n+      saveDrawing();\n+      setHistory((prevHistory) => [\n+        ...prevHistory,\n+        { id, path, color, size, tool },\n+      ]);\n+      setPath(\"\");\n+      setPoints([]);\n+    }\n+  };\n+\n+  const handleColorChange = (e) => {\n+    setColor(e.target.value);\n+  };\n+\n+  const openColorPicker = () => {\n+    colorInputRef.current.click();\n+  };\n+\n+  // Store only actions in history (add or delete)\n+  const undo = () => {\n+    if (history.length > 0) {\n+      const lastAction = history[history.length - 1];\n+      setHistory((prevHistory) => prevHistory.slice(0, -1));\n+      setRedoStack((prevStack) => [...prevStack, lastAction]);\n+\n+      if (lastAction.action === \"add\") {\n+        // Undo adding a line by removing it\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastAction.line.id\n+        );\n+      } else if (lastAction.action === \"delete\") {\n+        // Undo deleting a line by adding it back\n+        linesRef.current = [...linesRef.current, lastAction.line];\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const redo = () => {\n+    if (redoStack.length > 0) {\n+      const lastRedo = redoStack[redoStack.length - 1];\n+      setRedoStack((prevStack) => prevStack.slice(0, -1));\n+      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n+\n+      if (lastRedo.action === \"add\") {\n+        // Redo adding a line by adding it back\n+        linesRef.current = [...linesRef.current, lastRedo.line];\n+      } else if (lastRedo.action === \"delete\") {\n+        // Redo deleting a line by removing it again\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastRedo.line.id\n+        );\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const saveHeight = () => {\n+    updateAttributes({ height: svgHeight });\n+  };\n+\n+  useEffect(() => {\n+    const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n+      Keyboard.hide();\n+    });\n+\n+    return () => {\n+      showListener.remove();\n+    };\n+  }, []);\n+\n+  const pathsGroupRef = useRef(null);\n+  const activePathRef = useRef(null);\n+  const throttleRef = useRef(null);\n+  const batchUpdateTimeoutRef = useRef(null);\n+\n+  // Memoize the line generator to prevent recreation\n+  const lineGenerator = useMemo(\n+    () =>\n+      d3\n+        .line()\n+        .x((d) => d.x)\n+        .y((d) => d.y)\n+        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n+    []\n+  );\n+\n+  const smoothPoints = (points) => {\n+    if (points.length < 3) return points;\n+    return points.map((point, i, arr) => {\n+      if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n+      const prev = arr[i - 1];\n+      const next = arr[i + 1];\n+      return {\n+        x: (prev.x + point.x + next.x) / 3,\n+        y: (prev.y + point.y + next.y) / 3,\n+      };\n+    });\n+  };\n+\n+  // Batch update function for paths\n+  const batchUpdatePaths = () => {\n+    if (batchUpdateTimeoutRef.current) {\n+      clearTimeout(batchUpdateTimeoutRef.current);\n+    }\n+\n+    batchUpdateTimeoutRef.current = setTimeout(() => {\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }, 500); // Adjust timeout as needed\n+  };\n+\n+  // Throttle draw function\n+  const throttledDraw = (x, y) => {\n+    if (!throttleRef.current) {\n+      throttleRef.current = setTimeout(() => {\n+        throttleRef.current = null;\n+      }, 16); // ~60fps\n+\n+      if (!drawing) return;\n+\n+      const newPoints = [...points, { x, y }];\n+      setPoints(newPoints);\n+\n+      const newPath = lineGenerator(smoothPoints(newPoints));\n+      setPath(newPath);\n+\n+      // Update active path directly in DOM for better performance\n+      if (activePathRef.current) {\n+        activePathRef.current.setAttribute(\"d\", newPath);\n+      }\n+\n+      // Check for canvas expansion\n+      if (y > svgHeight - BUFFER_ZONE) {\n+        const newHeight = svgHeight + INCREMENT_HEIGHT;\n+        setSvgHeight(newHeight);\n+        updateAttributes({ height: newHeight });\n+      }\n+    }\n+  };\n+\n+  // Split paths into chunks for better rendering\n+  const chunkedLines = useMemo(() => {\n+    const chunkSize = 100; // Adjust based on performance needs\n+    const chunks = [];\n+    for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n+      chunks.push(linesRef.current.slice(i, i + chunkSize));\n+    }\n+    return chunks;\n+  }, [linesRef.current.length]);\n+\n+  const adjustColorForMode = (color) => {\n+    if (isDarkMode) {\n+      // Dark mode: Black turns to white; other colors unchanged\n+      return color === \"#000000\" ? \"#FFFFFF\" : color;\n+    } else {\n+      // Light mode: White turns to black; other colors unchanged\n+      return color === \"#FFFFFF\" ? \"#000000\" : color;\n+    }\n+  };\n+\n+  // Optimize path rendering\n+  const renderPaths = () =>\n+    chunkedLines.map((chunk, chunkIndex) => (\n+      <g key={`chunk-${chunkIndex}`}>\n+        {chunk.map((item) => (\n+          <path\n+            key={`${item.id}-${item.color}-${item.size}`}\n+            d={item.path}\n+            stroke={adjustColorForMode(item.color)}\n+            strokeWidth={item.size}\n+            opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n+            fill=\"none\"\n+            vectorEffect=\"non-scaling-stroke\"\n+          />\n+        ))}\n+      </g>\n+    ));\n+\n+  // Optimize save drawing function\n+  const saveDrawing = () => {\n+    if (!path) return;\n+\n+    const newLine = { id: uuid(), path, color, size, tool };\n+    linesRef.current = [...linesRef.current, newLine];\n+\n+    setHistory((prevHistory) => [\n+      ...prevHistory,\n+      { action: \"add\", line: newLine },\n+    ]);\n+\n+    setRedoStack([]);\n+    batchUpdatePaths();\n+  };\n+\n+  return (\n+    <div className=\"draw w-full min-h-screen flex flex-col\">\n+      {/* Top Toolbar */}\n+      <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n+        {/* Left side controls */}\n+        <div className=\"flex items-center space-x-2\">\n+          <button\n+            onClick={() => {\n+              setTool(\"pencil\");\n+              setColor(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n+            }}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-2 border ${\n+              tool === \"pencil\"\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n+                : \"border-gray-300 dark:border-neutral-600\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <Icons.BallPenLine className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={() => {\n+              setTool(\"highlighter\");\n+              setColor(\"#FFFF00\");\n+            }}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-2 border ${\n+              tool === \"highlighter\"\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n+                : \"border-gray-300 dark:border-neutral-600\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <Icons.MarkPenLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={() => setTool(\"erase\")}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-2 border ${\n+              tool === \"erase\"\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n+                : \"border-gray-300 dark:border-neutral-600\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <Icons.EraserLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <div className=\"relative\">\n+            <select\n+              className=\"border border-neutral-300 dark:border-neutral-600 rounded w-full p-2 text-neutral-800 bg-[#F8F8F7] dark:bg-[#2D2C2C] dark:text-[color:var(--selected-dark-text)] outline-none appearance-none mr-6\"\n+              value={background}\n+              onChange={handleBackgroundChange}\n+            >\n+              <option value=\"none\">None</option>\n+              <option value=\"grid\">Grid</option>\n+              <option value=\"ruled\">Ruled</option>\n+              <option value=\"dotted\">Dotted</option>\n+            </select>\n+            <Icons.ArrowDownSLineIcon className=\"dark:text-[color:var(--selected-dark-text)] ri-arrow-down-s-line absolute right-3 top-1/2 transform -translate-y-1/2 text-neutral-600 pointer-events-none\" />\n+          </div>\n+        </div>\n+        {/* Right side controls */}\n+        <div className=\"flex items-center space-x-2\">\n+          <button\n+            onClick={undo}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n+          >\n+            <Icons.ArrowGoBackLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={redo}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n+          >\n+            <Icons.ArrowGoForwardLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thin)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thin\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"3\"\n+              height=\"3\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.medium)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.medium\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"4\"\n+              height=\"4\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thick)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thick\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"5\"\n+              height=\"5\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thicker)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thicker\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"6\"\n+              height=\"6\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thickest)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thickest\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"7\"\n+              height=\"7\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <div className=\"relative inline-block\">\n+            {/* Hidden color input */}\n+            <input\n+              type=\"color\"\n+              value={color}\n+              onChange={handleColorChange}\n+              ref={colorInputRef}\n+              className=\"absolute inset-0 opacity-0 cursor-pointer\"\n+            />\n+            {/* Custom button */}\n+            <button\n+              onClick={openColorPicker}\n+              style={{ backgroundColor: color }}\n+              className={`flex items-center justify-center p-1 h-10 w-10 rounded-full hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+            />\n+          </div>\n+          <button\n+            onClick={onClose}\n+            className=\"p-2 rounded-full bg-gray-100 dark:bg-neutral-800 hover:bg-gray-200 dark:hover:bg-neutral-700 transition-colors\"\n+          >\n+            <Icons.CloseLineIcon className=\"w-6 h-6\" />\n+          </button>\n+        </div>\n+      </div>\n+\n+      {/* SVG Container */}\n+      <div className=\"relative flex-grow drawing-container\">\n+        <svg\n+          ref={svgRef}\n+          viewBox={`0 0 ${svgWidth} ${svgHeight}`}\n+          preserveAspectRatio=\"xMidYMid meet\"\n+          className={`w-full h-auto ${background} bg-neutral-100 dark:bg-neutral-800`}\n+        >\n+          <g ref={pathsGroupRef}>{renderPaths()}</g>\n+          {path && (\n+            <path\n+              ref={activePathRef}\n+              d={path}\n+              stroke={adjustColorForMode(color)}\n+              strokeWidth={size}\n+              opacity={tool === \"highlighter\" ? 0.3 : 1}\n+              fill=\"none\"\n+              vectorEffect=\"non-scaling-stroke\"\n+            />\n+          )}\n+        </svg>\n+      </div>\n+    </div>\n+  );\n+};\n+\n+export default DrawMode;\n"
                }
            ],
            "date": 1731678443885,
            "name": "Commit-0",
            "content": "import React, { useState, useRef, useEffect, useMemo } from \"react\";\nimport * as d3 from \"d3\";\nimport { v4 as uuid } from \"uuid\";\nimport { Keyboard } from \"@capacitor/keyboard\";\nimport Icons from \"../../../remixicon-react\";\n\nconst thicknessOptions = {\n  thin: 2,\n  medium: 3,\n  thick: 4,\n  thicker: 5,\n  thickest: 6,\n};\n\nconst backgroundStyles = {\n  none: \"\",\n  grid: \"grid\",\n  ruled: \"ruled\",\n  dotted: \"dotted\",\n};\n\nconst BUFFER_ZONE = 50;\nconst INCREMENT_HEIGHT = 200;\nconst PREVIEW_HEIGHT = 500;\n\nconst DrawMode = ({ onClose, updateAttributes, node }) => {\n  const isDarkMode = document.documentElement.classList.contains(\"dark\");\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [drawingPath, setDrawingPath] = useState(\"\");\n  const [lines, setLines] = useState([]);\n  const pointsRef = useRef([]);\n  const historyRef = useRef([]);\n  const redoStackRef = useRef([]);\n  const svgRef = useRef(null);\n  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n  const [size, setSize] = useState(thicknessOptions.thin);\n  const [drawing, setDrawing] = useState(false);\n  const [points, setPoints] = useState([]);\n  const [path, setPath] = useState(\"\");\n  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n  const [svgWidth] = useState(500);\n  const [tool, setTool] = useState(\"pencil\");\n  const [history, setHistory] = useState([]);\n  const [redoStack, setRedoStack] = useState([]);\n  const [isResizing, setIsResizing] = useState(false);\n  const [startY, setStartY] = useState(0);\n  const [id] = useState(() => node.attrs.id || uuid());\n  const colorInputRef = useRef(null);\n  const [background, setBackground] = useState(\n    node.attrs.paperType || backgroundStyles.none\n  );\n\n  const linesRef = useRef(node.attrs.lines || []);\n\n  const handleBackgroundChange = (event) => {\n    const newBackground = event.target.value;\n    setBackground(newBackground);\n    updateAttributes({ paperType: newBackground });\n  };\n\n  useEffect(() => {\n    const svg = d3.select(svgRef.current);\n    const eraseRadius = 5;\n    let isErasing = false;\n    let penActive = false;\n    let penTimeout = null;\n\n    const PEN_TIMEOUT_DURATION = 700;\n\n    const handlePointerEvent = (event) => {\n      if (event.pointerType === \"pen\") {\n        penActive = true;\n        clearTimeout(penTimeout);\n        event.preventDefault(); // Prevent touch interaction when pen is active\n        event.stopPropagation();\n\n        const [x, y] = getPointerCoordinates(event);\n\n        if (event.type === \"pointerdown\") {\n          if (tool === \"erase\") {\n            isErasing = true;\n            eraseOverlappingPaths(x, y);\n          } else {\n            startDrawing(x, y);\n          }\n        } else if (event.type === \"pointermove\") {\n          if (tool === \"erase\" && isErasing) {\n            eraseOverlappingPaths(x, y);\n          } else if (tool !== \"erase\") {\n            draw(x, y);\n          }\n        } else if (event.type === \"pointerup\") {\n          if (tool === \"erase\") {\n            isErasing = false;\n          } else {\n            stopDrawing();\n          }\n\n          penTimeout = setTimeout(() => {\n            penActive = false;\n          }, PEN_TIMEOUT_DURATION);\n        }\n      }\n    };\n\n    const eraseOverlappingPaths = (x, y) => {\n      const eraserArea = {\n        x: x - eraseRadius,\n        y: y - eraseRadius,\n        width: eraseRadius * 2,\n        height: eraseRadius * 2,\n      };\n\n      svg.selectAll(\"path\").each(function () {\n        const path = d3.select(this);\n        const pathNode = path.node();\n        const pathBBox = pathNode.getBBox();\n\n        if (\n          pathBBox.x < eraserArea.x + eraserArea.width &&\n          pathBBox.x + pathBBox.width > eraserArea.x &&\n          pathBBox.y < eraserArea.y + eraserArea.height &&\n          pathBBox.y + pathBBox.height > eraserArea.y\n        ) {\n          deletePath(pathNode);\n        }\n      });\n    };\n\n    // Prevent scrolling when the pencil (pen) is active\n    const preventScrolling = (event) => {\n      if (penActive) {\n        event.preventDefault(); // Prevent scrolling\n        event.stopPropagation();\n      }\n    };\n\n    // Attach pen input handlers on SVG\n    svg\n      .on(\"pointerdown\", handlePointerEvent)\n      .on(\"pointermove\", handlePointerEvent)\n      .on(\"pointerup\", handlePointerEvent);\n\n    // Block touch interactions (scrolling) when pen is active\n    document.body.addEventListener(\"touchstart\", preventScrolling, {\n      passive: false,\n    });\n    document.body.addEventListener(\"touchmove\", preventScrolling, {\n      passive: false,\n    });\n    document.body.addEventListener(\"touchend\", preventScrolling, {\n      passive: false,\n    });\n\n    // Suppress context menu (e.g., copy/paste menu) on pen input\n    svg.on(\"contextmenu\", (event) => {\n      if (penActive) {\n        event.preventDefault();\n      }\n    });\n\n    // Cleanup on component unmount\n    return () => {\n      clearTimeout(penTimeout);\n      document.body.removeEventListener(\"touchstart\", preventScrolling);\n      document.body.removeEventListener(\"touchmove\", preventScrolling);\n      document.body.removeEventListener(\"touchend\", preventScrolling);\n    };\n  }, [tool, color, size, points]);\n\n  const deletePath = (pathElement) => {\n    const clickedPathData = pathElement.getAttribute(\"d\");\n    const pathIndex = linesRef.current.findIndex(\n      (line) => line.path === clickedPathData\n    );\n\n    if (pathIndex !== -1) {\n      const removedLine = linesRef.current[pathIndex];\n\n      // Save the deletion action\n      setHistory((prevHistory) => [\n        ...prevHistory,\n        { action: \"delete\", line: removedLine },\n      ]);\n\n      linesRef.current.splice(pathIndex, 1);\n      updateAttributes({\n        lines: linesRef.current,\n      });\n    }\n  };\n\n  const handleMouseDown = (event) => {\n    event.preventDefault();\n  };\n\n  useEffect(() => {\n    const svg = svgRef.current;\n\n    const preventContextMenu = (event) => event.preventDefault();\n\n    svg.addEventListener(\"contextmenu\", preventContextMenu);\n\n    return () => {\n      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n    };\n  }, []);\n\n  useEffect(() => {\n    const disableScroll = (event) => {\n      if (isDrawing) {\n        event.preventDefault();\n      }\n    };\n\n    document.addEventListener(\"touchmove\", disableScroll, { passive: false });\n    document.addEventListener(\"wheel\", disableScroll, { passive: false });\n\n    return () => {\n      document.removeEventListener(\"touchmove\", disableScroll);\n      document.removeEventListener(\"wheel\", disableScroll);\n    };\n  }, [isDrawing]);\n\n  useEffect(() => {\n    const handleMouseMove = (event) => {\n      if (isResizing) {\n        const currentY =\n          event.clientY || (event.touches && event.touches[0].clientY);\n        const deltaY = currentY - startY;\n        setSvgHeight((prevHeight) => {\n          const newHeight = Math.max(\n            MIN_HEIGHT,\n            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n          );\n          return newHeight;\n        });\n        setStartY(currentY);\n      }\n    };\n\n    const handleMouseUp = () => {\n      if (isResizing) {\n        setIsResizing(false);\n        document.removeEventListener(\"mousemove\", handleMouseMove);\n        document.removeEventListener(\"mouseup\", handleMouseUp);\n        document.removeEventListener(\"touchmove\", handleMouseMove);\n        document.removeEventListener(\"touchend\", handleMouseUp);\n        saveHeight();\n      }\n    };\n\n    if (isResizing) {\n      document.addEventListener(\"mousemove\", handleMouseMove);\n      document.addEventListener(\"mouseup\", handleMouseUp);\n      document.addEventListener(\"touchmove\", handleMouseMove);\n      document.addEventListener(\"touchend\", handleMouseUp);\n    }\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n      document.removeEventListener(\"touchmove\", handleMouseMove);\n      document.removeEventListener(\"touchend\", handleMouseUp);\n    };\n  }, [isResizing, startY]);\n\n  const getPointerCoordinates = (event) => {\n    const svg = svgRef.current;\n    const rect = svg.getBoundingClientRect();\n\n    // Get the correct pointer position, including page scroll and scale\n    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n\n    // Calculate the mouse position relative to the SVG\n    const scaleX = svg.viewBox.baseVal.width / rect.width;\n    const scaleY = svg.viewBox.baseVal.height / rect.height;\n\n    const x = (clientX - rect.left) * scaleX;\n    const y = (clientY - rect.top) * scaleY;\n\n    return [x, y];\n  };\n\n  const startDrawing = (x, y) => {\n    setDrawing(true);\n    setPoints([{ x, y }]);\n  };\n\n  const draw = (x, y) => {\n    if (!drawing) return;\n\n    const newPoints = [...points, { x, y }];\n    setPoints(newPoints);\n    const newPath = lineGenerator(newPoints);\n    setPath(newPath);\n    if (y > svgHeight - BUFFER_ZONE) {\n      const newHeight = svgHeight + INCREMENT_HEIGHT;\n      setSvgHeight(newHeight);\n      updateAttributes({ height: newHeight });\n\n      // Adjust scroll position to keep the drawing point in view\n      const container = containerRef.current;\n      if (container) {\n        const scrollContainer = container.closest(\".drawing-component\");\n        if (scrollContainer) {\n          scrollContainer.scrollTo({\n            top: scrollContainer.scrollHeight,\n            behavior: \"smooth\",\n          });\n        }\n      }\n    }\n  };\n\n  const stopDrawing = () => {\n    if (drawing) {\n      setDrawing(false);\n      saveDrawing();\n      setHistory((prevHistory) => [\n        ...prevHistory,\n        { id, path, color, size, tool },\n      ]);\n      setPath(\"\");\n      setPoints([]);\n    }\n  };\n\n  const handleColorChange = (e) => {\n    setColor(e.target.value);\n  };\n\n  const openColorPicker = () => {\n    colorInputRef.current.click();\n  };\n\n  // Store only actions in history (add or delete)\n  const undo = () => {\n    if (history.length > 0) {\n      const lastAction = history[history.length - 1];\n      setHistory((prevHistory) => prevHistory.slice(0, -1));\n      setRedoStack((prevStack) => [...prevStack, lastAction]);\n\n      if (lastAction.action === \"add\") {\n        // Undo adding a line by removing it\n        linesRef.current = linesRef.current.filter(\n          (line) => line.id !== lastAction.line.id\n        );\n      } else if (lastAction.action === \"delete\") {\n        // Undo deleting a line by adding it back\n        linesRef.current = [...linesRef.current, lastAction.line];\n      }\n\n      updateAttributes({\n        lines: linesRef.current,\n      });\n    }\n  };\n\n  const redo = () => {\n    if (redoStack.length > 0) {\n      const lastRedo = redoStack[redoStack.length - 1];\n      setRedoStack((prevStack) => prevStack.slice(0, -1));\n      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n\n      if (lastRedo.action === \"add\") {\n        // Redo adding a line by adding it back\n        linesRef.current = [...linesRef.current, lastRedo.line];\n      } else if (lastRedo.action === \"delete\") {\n        // Redo deleting a line by removing it again\n        linesRef.current = linesRef.current.filter(\n          (line) => line.id !== lastRedo.line.id\n        );\n      }\n\n      updateAttributes({\n        lines: linesRef.current,\n      });\n    }\n  };\n\n  const saveHeight = () => {\n    updateAttributes({ height: svgHeight });\n  };\n\n  useEffect(() => {\n    const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n      Keyboard.hide();\n    });\n\n    return () => {\n      showListener.remove();\n    };\n  }, []);\n\n  const pathsGroupRef = useRef(null);\n  const activePathRef = useRef(null);\n  const throttleRef = useRef(null);\n  const batchUpdateTimeoutRef = useRef(null);\n\n  // Memoize the line generator to prevent recreation\n  const lineGenerator = useMemo(\n    () =>\n      d3\n        .line()\n        .x((d) => d.x)\n        .y((d) => d.y)\n        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n    []\n  );\n\n  const smoothPoints = (points) => {\n    if (points.length < 3) return points;\n    return points.map((point, i, arr) => {\n      if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n      const prev = arr[i - 1];\n      const next = arr[i + 1];\n      return {\n        x: (prev.x + point.x + next.x) / 3,\n        y: (prev.y + point.y + next.y) / 3,\n      };\n    });\n  };\n\n  // Batch update function for paths\n  const batchUpdatePaths = () => {\n    if (batchUpdateTimeoutRef.current) {\n      clearTimeout(batchUpdateTimeoutRef.current);\n    }\n\n    batchUpdateTimeoutRef.current = setTimeout(() => {\n      updateAttributes({\n        lines: linesRef.current,\n      });\n    }, 500); // Adjust timeout as needed\n  };\n\n  // Throttle draw function\n  const throttledDraw = (x, y) => {\n    if (!throttleRef.current) {\n      throttleRef.current = setTimeout(() => {\n        throttleRef.current = null;\n      }, 16); // ~60fps\n\n      if (!drawing) return;\n\n      const newPoints = [...points, { x, y }];\n      setPoints(newPoints);\n\n      const newPath = lineGenerator(smoothPoints(newPoints));\n      setPath(newPath);\n\n      // Update active path directly in DOM for better performance\n      if (activePathRef.current) {\n        activePathRef.current.setAttribute(\"d\", newPath);\n      }\n\n      // Check for canvas expansion\n      if (y > svgHeight - BUFFER_ZONE) {\n        const newHeight = svgHeight + INCREMENT_HEIGHT;\n        setSvgHeight(newHeight);\n        updateAttributes({ height: newHeight });\n      }\n    }\n  };\n\n  // Split paths into chunks for better rendering\n  const chunkedLines = useMemo(() => {\n    const chunkSize = 100; // Adjust based on performance needs\n    const chunks = [];\n    for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n      chunks.push(linesRef.current.slice(i, i + chunkSize));\n    }\n    return chunks;\n  }, [linesRef.current.length]);\n\n  // Optimize path rendering\n  const renderPaths = () =>\n    chunkedLines.map((chunk, chunkIndex) => (\n      <g key={`chunk-${chunkIndex}`}>\n        {chunk.map((item) => (\n          <path\n            key={`${item.id}-${item.color}-${item.size}`}\n            d={item.path}\n            stroke={\n              isDarkMode\n                ? item.color === \"#FFFFFF\"\n                  ? \"#FFFFFF\" // White text for dark mode\n                  : item.color // Keep original color\n                : item.color === \"#FFFFFF\"\n                ? \"#000000\"\n                : item.color // Keep original color\n            }\n            strokeWidth={item.size}\n            opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n            fill=\"none\"\n            vectorEffect=\"non-scaling-stroke\"\n          />\n        ))}\n      </g>\n    ));\n\n  // Optimize save drawing function\n  const saveDrawing = () => {\n    if (!path) return;\n\n    const newLine = { id: uuid(), path, color, size, tool };\n    linesRef.current = [...linesRef.current, newLine];\n\n    setHistory((prevHistory) => [\n      ...prevHistory,\n      { action: \"add\", line: newLine },\n    ]);\n\n    setRedoStack([]);\n    batchUpdatePaths();\n  };\n\n  return (\n    <div className=\"draw w-full min-h-screen flex flex-col\">\n      {/* Top Toolbar */}\n      <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n        {/* Left side controls */}\n        <div className=\"flex items-center space-x-2\">\n          <button\n            onClick={() => {\n              setTool(\"pencil\");\n            }}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-2 border ${\n              tool === \"pencil\"\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n                : \"border-gray-300 dark:border-neutral-600\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <Icons.BallPenLine className=\"w-6 h-6\" />\n          </button>\n          <button\n            onClick={() => {\n              setTool(\"highlighter\");\n              setColor(\"#FFFF00\");\n            }}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-2 border ${\n              tool === \"highlighter\"\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n                : \"border-gray-300 dark:border-neutral-600\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <Icons.MarkPenLineIcon className=\"w-6 h-6\" />\n          </button>\n          <button\n            onClick={() => setTool(\"erase\")}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-2 border ${\n              tool === \"erase\"\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n                : \"border-gray-300 dark:border-neutral-600\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <Icons.EraserLineIcon className=\"w-6 h-6\" />\n          </button>\n          <div className=\"relative\">\n            <select\n              className=\"border border-neutral-300 dark:border-neutral-600 rounded w-full p-2 text-neutral-800 bg-[#F8F8F7] dark:bg-[#2D2C2C] dark:text-[color:var(--selected-dark-text)] outline-none appearance-none mr-6\"\n              value={background}\n              onChange={handleBackgroundChange}\n            >\n              <option value=\"none\">None</option>\n              <option value=\"grid\">Grid</option>\n              <option value=\"ruled\">Ruled</option>\n              <option value=\"dotted\">Dotted</option>\n            </select>\n            <Icons.ArrowDownSLineIcon className=\"dark:text-[color:var(--selected-dark-text)] ri-arrow-down-s-line absolute right-3 top-1/2 transform -translate-y-1/2 text-neutral-600 pointer-events-none\" />\n          </div>\n        </div>\n        {/* Right side controls */}\n        <div className=\"flex items-center space-x-2\">\n          <button\n            onClick={undo}\n            onMouseDown={(e) => e.preventDefault()}\n            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n          >\n            <Icons.ArrowGoBackLineIcon className=\"w-6 h-6\" />\n          </button>\n          <button\n            onClick={redo}\n            onMouseDown={(e) => e.preventDefault()}\n            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n          >\n            <Icons.ArrowGoForwardLineIcon className=\"w-6 h-6\" />\n          </button>\n          <button\n            onClick={() => setSize(thicknessOptions.thin)}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-1 border ${\n              size === thicknessOptions.thin\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <svg\n              width=\"3\"\n              height=\"3\"\n              className=\"rounded-full\"\n              style={{ backgroundColor: color }}\n            />\n          </button>\n          <button\n            onClick={() => setSize(thicknessOptions.medium)}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-1 border ${\n              size === thicknessOptions.medium\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <svg\n              width=\"4\"\n              height=\"4\"\n              className=\"rounded-full\"\n              style={{ backgroundColor: color }}\n            />\n          </button>\n          <button\n            onClick={() => setSize(thicknessOptions.thick)}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-1 border ${\n              size === thicknessOptions.thick\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <svg\n              width=\"5\"\n              height=\"5\"\n              className=\"rounded-full\"\n              style={{ backgroundColor: color }}\n            />\n          </button>\n          <button\n            onClick={() => setSize(thicknessOptions.thicker)}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-1 border ${\n              size === thicknessOptions.thicker\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <svg\n              width=\"6\"\n              height=\"6\"\n              className=\"rounded-full\"\n              style={{ backgroundColor: color }}\n            />\n          </button>\n          <button\n            onClick={() => setSize(thicknessOptions.thickest)}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-1 border ${\n              size === thicknessOptions.thickest\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <svg\n              width=\"7\"\n              height=\"7\"\n              className=\"rounded-full\"\n              style={{ backgroundColor: color }}\n            />\n          </button>\n          <div className=\"relative inline-block\">\n            {/* Hidden color input */}\n            <input\n              type=\"color\"\n              value={color}\n              onChange={handleColorChange}\n              ref={colorInputRef}\n              className=\"absolute inset-0 opacity-0 cursor-pointer\"\n            />\n            {/* Custom button */}\n            <button\n              onClick={openColorPicker}\n              style={{ backgroundColor: color }}\n              className={`flex items-center justify-center p-1 h-10 w-10 rounded-full hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n            />\n          </div>\n          <button\n            onClick={onClose}\n            className=\"p-2 rounded-full bg-gray-100 dark:bg-neutral-800 hover:bg-gray-200 dark:hover:bg-neutral-700 transition-colors\"\n          >\n            <Icons.CloseLineIcon className=\"w-6 h-6\" />\n          </button>\n        </div>\n      </div>\n\n      {/* SVG Container */}\n      <div className=\"relative flex-grow drawing-container\">\n        <svg\n          ref={svgRef}\n          viewBox={`0 0 ${svgWidth} ${svgHeight}`}\n          preserveAspectRatio=\"xMidYMid meet\"\n          className={`w-full h-auto ${background}`}\n        >\n          <g ref={pathsGroupRef}>{renderPaths()}</g>\n          {path && (\n            <path\n              ref={activePathRef}\n              d={path}\n              stroke={color}\n              strokeWidth={size}\n              opacity={tool === \"highlighter\" ? 0.3 : 1}\n              fill=\"none\"\n              vectorEffect=\"non-scaling-stroke\"\n            />\n          )}\n        </svg>\n      </div>\n    </div>\n  );\n};\n\nexport default DrawMode;"
        }
    ]
}