{
    "sourceFile": "src/lib/tiptap/exts/paper-block/DrawMode.jsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 76,
            "patches": [
                {
                    "date": 1731678443885,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1731678452868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -485,11 +485,11 @@\n             d={item.path}\n             stroke={\n               isDarkMode\n                 ? item.color === \"#FFFFFF\"\n-                  ? \"#FFFFFF\" // White text for dark mode\n+                  ? \"#000000\" // White text for dark mode\n                   : item.color // Keep original color\n-                : item.color === \"#FFFFFF\"\n+                : item.color === \"#000000\"\n                 ? \"#000000\"\n                 : item.color // Keep original color\n             }\n             strokeWidth={item.size}\n"
                },
                {
                    "date": 1731678601973,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -487,11 +487,8 @@\n               isDarkMode\n                 ? item.color === \"#FFFFFF\"\n                   ? \"#000000\" // White text for dark mode\n                   : item.color // Keep original color\n-                : item.color === \"#000000\"\n-                ? \"#000000\"\n-                : item.color // Keep original color\n             }\n             strokeWidth={item.size}\n             opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n             fill=\"none\"\n@@ -721,5 +718,5 @@\n     </div>\n   );\n };\n \n-export default DrawMode;\n\\ No newline at end of file\n+export default DrawMode;\n"
                },
                {
                    "date": 1731678800264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -484,11 +484,12 @@\n             key={`${item.id}-${item.color}-${item.size}`}\n             d={item.path}\n             stroke={\n               isDarkMode\n-                ? item.color === \"#FFFFFF\"\n-                  ? \"#000000\" // White text for dark mode\n-                  : item.color // Keep original color\n+                ? item.color === \"#000000\"\n+                  ? \"#FFFFFF\"\n+                  : item.color\n+                : item.color\n             }\n             strokeWidth={item.size}\n             opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n             fill=\"none\"\n"
                },
                {
                    "date": 1731691174865,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -523,8 +523,9 @@\n         <div className=\"flex items-center space-x-2\">\n           <button\n             onClick={() => {\n               setTool(\"pencil\");\n+              setColor(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n             }}\n             onMouseDown={(e) => e.preventDefault()}\n             className={`flex items-center justify-center p-2 border ${\n               tool === \"pencil\"\n"
                },
                {
                    "date": 1731691336474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -474,8 +474,16 @@\n     }\n     return chunks;\n   }, [linesRef.current.length]);\n \n+  const adjustColorForMode = (color) => {\n+    if (isDarkMode) {\n+      return color === \"#000000\" ? \"#FFFFFF\" : color === \"#FFFFFF\" ? \"#000000\" : color;\n+    } else {\n+      return color === \"#FFFFFF\" ? \"#000000\" : color === \"#000000\" ? \"#FFFFFF\" : color;\n+    }\n+  };  \n+\n   // Optimize path rendering\n   const renderPaths = () =>\n     chunkedLines.map((chunk, chunkIndex) => (\n       <g key={`chunk-${chunkIndex}`}>\n"
                },
                {
                    "date": 1731691346594,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -490,15 +490,9 @@\n         {chunk.map((item) => (\n           <path\n             key={`${item.id}-${item.color}-${item.size}`}\n             d={item.path}\n-            stroke={\n-              isDarkMode\n-                ? item.color === \"#000000\"\n-                  ? \"#FFFFFF\"\n-                  : item.color\n-                : item.color\n-            }\n+            stroke={adjustColorForMode(item.color)}\n             strokeWidth={item.size}\n             opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n             fill=\"none\"\n             vectorEffect=\"non-scaling-stroke\"\n"
                },
                {
                    "date": 1731691358595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -709,10 +709,9 @@\n           {path && (\n             <path\n               ref={activePathRef}\n               d={path}\n-              stroke={color}\n-              strokeWidth={size}\n+              stroke={adjustColorForMode(color)}               strokeWidth={size}\n               opacity={tool === \"highlighter\" ? 0.3 : 1}\n               fill=\"none\"\n               vectorEffect=\"non-scaling-stroke\"\n             />\n"
                },
                {
                    "date": 1731691597124,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -474,25 +474,23 @@\n     }\n     return chunks;\n   }, [linesRef.current.length]);\n \n-  const adjustColorForMode = (color) => {\n-    if (isDarkMode) {\n-      return color === \"#000000\" ? \"#FFFFFF\" : color === \"#FFFFFF\" ? \"#000000\" : color;\n-    } else {\n-      return color === \"#FFFFFF\" ? \"#000000\" : color === \"#000000\" ? \"#FFFFFF\" : color;\n-    }\n-  };  \n-\n   // Optimize path rendering\n   const renderPaths = () =>\n     chunkedLines.map((chunk, chunkIndex) => (\n       <g key={`chunk-${chunkIndex}`}>\n         {chunk.map((item) => (\n           <path\n             key={`${item.id}-${item.color}-${item.size}`}\n             d={item.path}\n-            stroke={adjustColorForMode(item.color)}\n+            stroke={\n+              isDarkMode\n+                ? item.color === \"#000000\"\n+                  ? \"#FFFFFF\"\n+                  : item.color\n+                : item.color\n+            }\n             strokeWidth={item.size}\n             opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n             fill=\"none\"\n             vectorEffect=\"non-scaling-stroke\"\n@@ -525,9 +523,8 @@\n         <div className=\"flex items-center space-x-2\">\n           <button\n             onClick={() => {\n               setTool(\"pencil\");\n-              setColor(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n             }}\n             onMouseDown={(e) => e.preventDefault()}\n             className={`flex items-center justify-center p-2 border ${\n               tool === \"pencil\"\n@@ -709,9 +706,10 @@\n           {path && (\n             <path\n               ref={activePathRef}\n               d={path}\n-              stroke={adjustColorForMode(color)}               strokeWidth={size}\n+              stroke={color}\n+              strokeWidth={size}\n               opacity={tool === \"highlighter\" ? 0.3 : 1}\n               fill=\"none\"\n               vectorEffect=\"non-scaling-stroke\"\n             />\n"
                },
                {
                    "date": 1731691680424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -474,8 +474,18 @@\n     }\n     return chunks;\n   }, [linesRef.current.length]);\n \n+  const adjustColorForMode = (color) => {\n+    if (isDarkMode) {\n+      // Dark mode: Black turns to white; other colors unchanged\n+      return color === \"#000000\" ? \"#FFFFFF\" : color;\n+    } else {\n+      // Light mode: White turns to black; other colors unchanged\n+      return color === \"#FFFFFF\" ? \"#000000\" : color;\n+    }\n+  };\n+\n   // Optimize path rendering\n   const renderPaths = () =>\n     chunkedLines.map((chunk, chunkIndex) => (\n       <g key={`chunk-${chunkIndex}`}>\n@@ -523,8 +533,9 @@\n         <div className=\"flex items-center space-x-2\">\n           <button\n             onClick={() => {\n               setTool(\"pencil\");\n+              setColor(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n             }}\n             onMouseDown={(e) => e.preventDefault()}\n             className={`flex items-center justify-center p-2 border ${\n               tool === \"pencil\"\n"
                },
                {
                    "date": 1731691690143,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -492,15 +492,9 @@\n         {chunk.map((item) => (\n           <path\n             key={`${item.id}-${item.color}-${item.size}`}\n             d={item.path}\n-            stroke={\n-              isDarkMode\n-                ? item.color === \"#000000\"\n-                  ? \"#FFFFFF\"\n-                  : item.color\n-                : item.color\n-            }\n+            stroke={adjustColorForMode(item.color)}\n             strokeWidth={item.size}\n             opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n             fill=\"none\"\n             vectorEffect=\"non-scaling-stroke\"\n"
                },
                {
                    "date": 1731691697568,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -711,9 +711,9 @@\n           {path && (\n             <path\n               ref={activePathRef}\n               d={path}\n-              stroke={color}\n+              stroke={adjustColorForMode(color)}\n               strokeWidth={size}\n               opacity={tool === \"highlighter\" ? 0.3 : 1}\n               fill=\"none\"\n               vectorEffect=\"non-scaling-stroke\"\n"
                },
                {
                    "date": 1731701747831,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,728 @@\n+import React, { useState, useRef, useEffect, useMemo } from \"react\";\n+import * as d3 from \"d3\";\n+import { v4 as uuid } from \"uuid\";\n+import { Keyboard } from \"@capacitor/keyboard\";\n+import Icons from \"../../../remixicon-react\";\n+\n+const thicknessOptions = {\n+  thin: 2,\n+  medium: 3,\n+  thick: 4,\n+  thicker: 5,\n+  thickest: 6,\n+};\n+\n+const backgroundStyles = {\n+  none: \"\",\n+  grid: \"grid\",\n+  ruled: \"ruled\",\n+  dotted: \"dotted\",\n+};\n+\n+const BUFFER_ZONE = 50;\n+const INCREMENT_HEIGHT = 200;\n+const PREVIEW_HEIGHT = 500;\n+\n+const DrawMode = ({ onClose, updateAttributes, node }) => {\n+  const isDarkMode = document.documentElement.classList.contains(\"dark\");\n+  const [isDrawing, setIsDrawing] = useState(false);\n+  const [drawingPath, setDrawingPath] = useState(\"\");\n+  const [lines, setLines] = useState([]);\n+  const pointsRef = useRef([]);\n+  const historyRef = useRef([]);\n+  const redoStackRef = useRef([]);\n+  const svgRef = useRef(null);\n+  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n+  const [size, setSize] = useState(thicknessOptions.thin);\n+  const [drawing, setDrawing] = useState(false);\n+  const [points, setPoints] = useState([]);\n+  const [path, setPath] = useState(\"\");\n+  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n+  const [svgWidth] = useState(500);\n+  const [tool, setTool] = useState(\"pencil\");\n+  const [history, setHistory] = useState([]);\n+  const [redoStack, setRedoStack] = useState([]);\n+  const [isResizing, setIsResizing] = useState(false);\n+  const [startY, setStartY] = useState(0);\n+  const [id] = useState(() => node.attrs.id || uuid());\n+  const colorInputRef = useRef(null);\n+  const [background, setBackground] = useState(\n+    node.attrs.paperType || backgroundStyles.none\n+  );\n+\n+  const linesRef = useRef(node.attrs.lines || []);\n+\n+  const handleBackgroundChange = (event) => {\n+    const newBackground = event.target.value;\n+    setBackground(newBackground);\n+    updateAttributes({ paperType: newBackground });\n+  };\n+\n+  useEffect(() => {\n+    const svg = d3.select(svgRef.current);\n+    const eraseRadius = 5;\n+    let isErasing = false;\n+    let penActive = false;\n+    let penTimeout = null;\n+\n+    const PEN_TIMEOUT_DURATION = 700;\n+\n+    const handlePointerEvent = (event) => {\n+      if (event.pointerType === \"pen\") {\n+        penActive = true;\n+        clearTimeout(penTimeout);\n+        event.preventDefault(); // Prevent touch interaction when pen is active\n+        event.stopPropagation();\n+\n+        const [x, y] = getPointerCoordinates(event);\n+\n+        if (event.type === \"pointerdown\") {\n+          if (tool === \"erase\") {\n+            isErasing = true;\n+            eraseOverlappingPaths(x, y);\n+          } else {\n+            startDrawing(x, y);\n+          }\n+        } else if (event.type === \"pointermove\") {\n+          if (tool === \"erase\" && isErasing) {\n+            eraseOverlappingPaths(x, y);\n+          } else if (tool !== \"erase\") {\n+            draw(x, y);\n+          }\n+        } else if (event.type === \"pointerup\") {\n+          if (tool === \"erase\") {\n+            isErasing = false;\n+          } else {\n+            stopDrawing();\n+          }\n+\n+          penTimeout = setTimeout(() => {\n+            penActive = false;\n+          }, PEN_TIMEOUT_DURATION);\n+        }\n+      }\n+    };\n+\n+    const eraseOverlappingPaths = (x, y) => {\n+      const eraserArea = {\n+        x: x - eraseRadius,\n+        y: y - eraseRadius,\n+        width: eraseRadius * 2,\n+        height: eraseRadius * 2,\n+      };\n+\n+      svg.selectAll(\"path\").each(function () {\n+        const path = d3.select(this);\n+        const pathNode = path.node();\n+        const pathBBox = pathNode.getBBox();\n+\n+        if (\n+          pathBBox.x < eraserArea.x + eraserArea.width &&\n+          pathBBox.x + pathBBox.width > eraserArea.x &&\n+          pathBBox.y < eraserArea.y + eraserArea.height &&\n+          pathBBox.y + pathBBox.height > eraserArea.y\n+        ) {\n+          deletePath(pathNode);\n+        }\n+      });\n+    };\n+\n+    // Prevent scrolling when the pencil (pen) is active\n+    const preventScrolling = (event) => {\n+      if (penActive) {\n+        event.preventDefault(); // Prevent scrolling\n+        event.stopPropagation();\n+      }\n+    };\n+\n+    // Attach pen input handlers on SVG\n+    svg\n+      .on(\"pointerdown\", handlePointerEvent)\n+      .on(\"pointermove\", handlePointerEvent)\n+      .on(\"pointerup\", handlePointerEvent);\n+\n+    // Block touch interactions (scrolling) when pen is active\n+    document.body.addEventListener(\"touchstart\", preventScrolling, {\n+      passive: false,\n+    });\n+    document.body.addEventListener(\"touchmove\", preventScrolling, {\n+      passive: false,\n+    });\n+    document.body.addEventListener(\"touchend\", preventScrolling, {\n+      passive: false,\n+    });\n+\n+    // Suppress context menu (e.g., copy/paste menu) on pen input\n+    svg.on(\"contextmenu\", (event) => {\n+      if (penActive) {\n+        event.preventDefault();\n+      }\n+    });\n+\n+    // Cleanup on component unmount\n+    return () => {\n+      clearTimeout(penTimeout);\n+      document.body.removeEventListener(\"touchstart\", preventScrolling);\n+      document.body.removeEventListener(\"touchmove\", preventScrolling);\n+      document.body.removeEventListener(\"touchend\", preventScrolling);\n+    };\n+  }, [tool, color, size, points]);\n+\n+  const deletePath = (pathElement) => {\n+    const clickedPathData = pathElement.getAttribute(\"d\");\n+    const pathIndex = linesRef.current.findIndex(\n+      (line) => line.path === clickedPathData\n+    );\n+\n+    if (pathIndex !== -1) {\n+      const removedLine = linesRef.current[pathIndex];\n+\n+      // Save the deletion action\n+      setHistory((prevHistory) => [\n+        ...prevHistory,\n+        { action: \"delete\", line: removedLine },\n+      ]);\n+\n+      linesRef.current.splice(pathIndex, 1);\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const handleMouseDown = (event) => {\n+    event.preventDefault();\n+  };\n+\n+  useEffect(() => {\n+    const svg = svgRef.current;\n+\n+    const preventContextMenu = (event) => event.preventDefault();\n+\n+    svg.addEventListener(\"contextmenu\", preventContextMenu);\n+\n+    return () => {\n+      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n+    };\n+  }, []);\n+\n+  useEffect(() => {\n+    const disableScroll = (event) => {\n+      if (isDrawing) {\n+        event.preventDefault();\n+      }\n+    };\n+\n+    document.addEventListener(\"touchmove\", disableScroll, { passive: false });\n+    document.addEventListener(\"wheel\", disableScroll, { passive: false });\n+\n+    return () => {\n+      document.removeEventListener(\"touchmove\", disableScroll);\n+      document.removeEventListener(\"wheel\", disableScroll);\n+    };\n+  }, [isDrawing]);\n+\n+  useEffect(() => {\n+    const handleMouseMove = (event) => {\n+      if (isResizing) {\n+        const currentY =\n+          event.clientY || (event.touches && event.touches[0].clientY);\n+        const deltaY = currentY - startY;\n+        setSvgHeight((prevHeight) => {\n+          const newHeight = Math.max(\n+            MIN_HEIGHT,\n+            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n+          );\n+          return newHeight;\n+        });\n+        setStartY(currentY);\n+      }\n+    };\n+\n+    const handleMouseUp = () => {\n+      if (isResizing) {\n+        setIsResizing(false);\n+        document.removeEventListener(\"mousemove\", handleMouseMove);\n+        document.removeEventListener(\"mouseup\", handleMouseUp);\n+        document.removeEventListener(\"touchmove\", handleMouseMove);\n+        document.removeEventListener(\"touchend\", handleMouseUp);\n+        saveHeight();\n+      }\n+    };\n+\n+    if (isResizing) {\n+      document.addEventListener(\"mousemove\", handleMouseMove);\n+      document.addEventListener(\"mouseup\", handleMouseUp);\n+      document.addEventListener(\"touchmove\", handleMouseMove);\n+      document.addEventListener(\"touchend\", handleMouseUp);\n+    }\n+\n+    return () => {\n+      document.removeEventListener(\"mousemove\", handleMouseMove);\n+      document.removeEventListener(\"mouseup\", handleMouseUp);\n+      document.removeEventListener(\"touchmove\", handleMouseMove);\n+      document.removeEventListener(\"touchend\", handleMouseUp);\n+    };\n+  }, [isResizing, startY]);\n+\n+  const getPointerCoordinates = (event) => {\n+    const svg = svgRef.current;\n+    const rect = svg.getBoundingClientRect();\n+\n+    // Get the correct pointer position, including page scroll and scale\n+    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n+    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n+\n+    // Calculate the mouse position relative to the SVG\n+    const scaleX = svg.viewBox.baseVal.width / rect.width;\n+    const scaleY = svg.viewBox.baseVal.height / rect.height;\n+\n+    const x = (clientX - rect.left) * scaleX;\n+    const y = (clientY - rect.top) * scaleY;\n+\n+    return [x, y];\n+  };\n+\n+  const startDrawing = (x, y) => {\n+    setDrawing(true);\n+    setPoints([{ x, y }]);\n+  };\n+\n+  const draw = (x, y) => {\n+    if (!drawing) return;\n+\n+    const newPoints = [...points, { x, y }];\n+    setPoints(newPoints);\n+    const newPath = lineGenerator(newPoints);\n+    setPath(newPath);\n+    if (y > svgHeight - BUFFER_ZONE) {\n+      const newHeight = svgHeight + INCREMENT_HEIGHT;\n+      setSvgHeight(newHeight);\n+      updateAttributes({ height: newHeight });\n+\n+      // Adjust scroll position to keep the drawing point in view\n+      const container = containerRef.current;\n+      if (container) {\n+        const scrollContainer = container.closest(\".drawing-component\");\n+        if (scrollContainer) {\n+          scrollContainer.scrollTo({\n+            top: scrollContainer.scrollHeight,\n+            behavior: \"smooth\",\n+          });\n+        }\n+      }\n+    }\n+  };\n+\n+  const stopDrawing = () => {\n+    if (drawing) {\n+      setDrawing(false);\n+      saveDrawing();\n+      setHistory((prevHistory) => [\n+        ...prevHistory,\n+        { id, path, color, size, tool },\n+      ]);\n+      setPath(\"\");\n+      setPoints([]);\n+    }\n+  };\n+\n+  const handleColorChange = (e) => {\n+    setColor(e.target.value);\n+  };\n+\n+  const openColorPicker = () => {\n+    colorInputRef.current.click();\n+  };\n+\n+  // Store only actions in history (add or delete)\n+  const undo = () => {\n+    if (history.length > 0) {\n+      const lastAction = history[history.length - 1];\n+      setHistory((prevHistory) => prevHistory.slice(0, -1));\n+      setRedoStack((prevStack) => [...prevStack, lastAction]);\n+\n+      if (lastAction.action === \"add\") {\n+        // Undo adding a line by removing it\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastAction.line.id\n+        );\n+      } else if (lastAction.action === \"delete\") {\n+        // Undo deleting a line by adding it back\n+        linesRef.current = [...linesRef.current, lastAction.line];\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const redo = () => {\n+    if (redoStack.length > 0) {\n+      const lastRedo = redoStack[redoStack.length - 1];\n+      setRedoStack((prevStack) => prevStack.slice(0, -1));\n+      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n+\n+      if (lastRedo.action === \"add\") {\n+        // Redo adding a line by adding it back\n+        linesRef.current = [...linesRef.current, lastRedo.line];\n+      } else if (lastRedo.action === \"delete\") {\n+        // Redo deleting a line by removing it again\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastRedo.line.id\n+        );\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const saveHeight = () => {\n+    updateAttributes({ height: svgHeight });\n+  };\n+\n+  useEffect(() => {\n+    const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n+      Keyboard.hide();\n+    });\n+\n+    return () => {\n+      showListener.remove();\n+    };\n+  }, []);\n+\n+  const pathsGroupRef = useRef(null);\n+  const activePathRef = useRef(null);\n+  const throttleRef = useRef(null);\n+  const batchUpdateTimeoutRef = useRef(null);\n+\n+  // Memoize the line generator to prevent recreation\n+  const lineGenerator = useMemo(\n+    () =>\n+      d3\n+        .line()\n+        .x((d) => d.x)\n+        .y((d) => d.y)\n+        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n+    []\n+  );\n+\n+  const smoothPoints = (points) => {\n+    if (points.length < 3) return points;\n+    return points.map((point, i, arr) => {\n+      if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n+      const prev = arr[i - 1];\n+      const next = arr[i + 1];\n+      return {\n+        x: (prev.x + point.x + next.x) / 3,\n+        y: (prev.y + point.y + next.y) / 3,\n+      };\n+    });\n+  };\n+\n+  // Batch update function for paths\n+  const batchUpdatePaths = () => {\n+    if (batchUpdateTimeoutRef.current) {\n+      clearTimeout(batchUpdateTimeoutRef.current);\n+    }\n+\n+    batchUpdateTimeoutRef.current = setTimeout(() => {\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }, 500); // Adjust timeout as needed\n+  };\n+\n+  // Throttle draw function\n+  const throttledDraw = (x, y) => {\n+    if (!throttleRef.current) {\n+      throttleRef.current = setTimeout(() => {\n+        throttleRef.current = null;\n+      }, 16); // ~60fps\n+\n+      if (!drawing) return;\n+\n+      const newPoints = [...points, { x, y }];\n+      setPoints(newPoints);\n+\n+      const newPath = lineGenerator(smoothPoints(newPoints));\n+      setPath(newPath);\n+\n+      // Update active path directly in DOM for better performance\n+      if (activePathRef.current) {\n+        activePathRef.current.setAttribute(\"d\", newPath);\n+      }\n+\n+      // Check for canvas expansion\n+      if (y > svgHeight - BUFFER_ZONE) {\n+        const newHeight = svgHeight + INCREMENT_HEIGHT;\n+        setSvgHeight(newHeight);\n+        updateAttributes({ height: newHeight });\n+      }\n+    }\n+  };\n+\n+  // Split paths into chunks for better rendering\n+  const chunkedLines = useMemo(() => {\n+    const chunkSize = 100; // Adjust based on performance needs\n+    const chunks = [];\n+    for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n+      chunks.push(linesRef.current.slice(i, i + chunkSize));\n+    }\n+    return chunks;\n+  }, [linesRef.current.length]);\n+\n+  const adjustColorForMode = (color) => {\n+    if (isDarkMode) {\n+      // Dark mode: Black turns to white; other colors unchanged\n+      return color === \"#000000\" ? \"#FFFFFF\" : color;\n+    } else {\n+      // Light mode: White turns to black; other colors unchanged\n+      return color === \"#FFFFFF\" ? \"#000000\" : color;\n+    }\n+  };\n+\n+  // Optimize path rendering\n+  const renderPaths = () =>\n+    chunkedLines.map((chunk, chunkIndex) => (\n+      <g key={`chunk-${chunkIndex}`}>\n+        {chunk.map((item) => (\n+          <path\n+            key={`${item.id}-${item.color}-${item.size}`}\n+            d={item.path}\n+            stroke={adjustColorForMode(item.color)}\n+            strokeWidth={item.size}\n+            opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n+            fill=\"none\"\n+            vectorEffect=\"non-scaling-stroke\"\n+          />\n+        ))}\n+      </g>\n+    ));\n+\n+  // Optimize save drawing function\n+  const saveDrawing = () => {\n+    if (!path) return;\n+\n+    const newLine = { id: uuid(), path, color, size, tool };\n+    linesRef.current = [...linesRef.current, newLine];\n+\n+    setHistory((prevHistory) => [\n+      ...prevHistory,\n+      { action: \"add\", line: newLine },\n+    ]);\n+\n+    setRedoStack([]);\n+    batchUpdatePaths();\n+  };\n+\n+  return (\n+    <div className=\"draw w-full min-h-screen flex flex-col\">\n+      {/* Top Toolbar */}\n+      <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n+        {/* Left side controls */}\n+        <div className=\"flex items-center space-x-2\">\n+          <button\n+            onClick={() => {\n+              setTool(\"pencil\");\n+              setColor(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n+            }}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-2 border ${\n+              tool === \"pencil\"\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n+                : \"border-gray-300 dark:border-neutral-600\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <Icons.BallPenLine className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={() => {\n+              setTool(\"highlighter\");\n+              setColor(\"#FFFF00\");\n+            }}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-2 border ${\n+              tool === \"highlighter\"\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n+                : \"border-gray-300 dark:border-neutral-600\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <Icons.MarkPenLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={() => setTool(\"erase\")}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-2 border ${\n+              tool === \"erase\"\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n+                : \"border-gray-300 dark:border-neutral-600\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <Icons.EraserLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <div className=\"relative\">\n+            <select\n+              className=\"border border-neutral-300 dark:border-neutral-600 rounded w-full p-2 text-neutral-800 bg-[#F8F8F7] dark:bg-[#2D2C2C] dark:text-[color:var(--selected-dark-text)] outline-none appearance-none mr-6\"\n+              value={background}\n+              onChange={handleBackgroundChange}\n+            >\n+              <option value=\"none\">None</option>\n+              <option value=\"grid\">Grid</option>\n+              <option value=\"ruled\">Ruled</option>\n+              <option value=\"dotted\">Dotted</option>\n+            </select>\n+            <Icons.ArrowDownSLineIcon className=\"dark:text-[color:var(--selected-dark-text)] ri-arrow-down-s-line absolute right-3 top-1/2 transform -translate-y-1/2 text-neutral-600 pointer-events-none\" />\n+          </div>\n+        </div>\n+        {/* Right side controls */}\n+        <div className=\"flex items-center space-x-2\">\n+          <button\n+            onClick={undo}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n+          >\n+            <Icons.ArrowGoBackLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={redo}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n+          >\n+            <Icons.ArrowGoForwardLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thin)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thin\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"3\"\n+              height=\"3\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.medium)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.medium\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"4\"\n+              height=\"4\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thick)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thick\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"5\"\n+              height=\"5\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thicker)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thicker\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"6\"\n+              height=\"6\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thickest)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thickest\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"7\"\n+              height=\"7\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <div className=\"relative inline-block\">\n+            {/* Hidden color input */}\n+            <input\n+              type=\"color\"\n+              value={color}\n+              onChange={handleColorChange}\n+              ref={colorInputRef}\n+              className=\"absolute inset-0 opacity-0 cursor-pointer\"\n+            />\n+            {/* Custom button */}\n+            <button\n+              onClick={openColorPicker}\n+              style={{ backgroundColor: color }}\n+              className={`flex items-center justify-center p-1 h-10 w-10 rounded-full hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+            />\n+          </div>\n+          <button\n+            onClick={onClose}\n+            className=\"p-2 rounded-full bg-gray-100 dark:bg-neutral-800 hover:bg-gray-200 dark:hover:bg-neutral-700 transition-colors\"\n+          >\n+            <Icons.CloseLineIcon className=\"w-6 h-6\" />\n+          </button>\n+        </div>\n+      </div>\n+\n+      {/* SVG Container */}\n+      <div className=\"relative flex-grow drawing-container\">\n+        <svg\n+          ref={svgRef}\n+          viewBox={`0 0 ${svgWidth} ${svgHeight}`}\n+          preserveAspectRatio=\"xMidYMid meet\"\n+          className={`w-full h-auto ${background} bg-neutral-100 dark:bg-neutral-800`}\n+        >\n+          <g ref={pathsGroupRef}>{renderPaths()}</g>\n+          {path && (\n+            <path\n+              ref={activePathRef}\n+              d={path}\n+              stroke={adjustColorForMode(color)}\n+              strokeWidth={size}\n+              opacity={tool === \"highlighter\" ? 0.3 : 1}\n+              fill=\"none\"\n+              vectorEffect=\"non-scaling-stroke\"\n+            />\n+          )}\n+        </svg>\n+      </div>\n+    </div>\n+  );\n+};\n+\n+export default DrawMode;\n"
                },
                {
                    "date": 1732016844610,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,391 +1,46 @@\n-import React, { useState, useRef, useEffect, useMemo } from \"react\";\n-import * as d3 from \"d3\";\n-import { v4 as uuid } from \"uuid\";\n+import React, { useRef, useEffect } from \"react\";\n import { Keyboard } from \"@capacitor/keyboard\";\n import Icons from \"../../../remixicon-react\";\n+import { useDrawing, thicknessOptions, backgroundStyles } from \"./useDrawing\";\n \n-const thicknessOptions = {\n-  thin: 2,\n-  medium: 3,\n-  thick: 4,\n-  thicker: 5,\n-  thickest: 6,\n-};\n-\n-const backgroundStyles = {\n-  none: \"\",\n-  grid: \"grid\",\n-  ruled: \"ruled\",\n-  dotted: \"dotted\",\n-};\n-\n-const BUFFER_ZONE = 50;\n-const INCREMENT_HEIGHT = 200;\n-const PREVIEW_HEIGHT = 500;\n-\n const DrawMode = ({ onClose, updateAttributes, node }) => {\n-  const isDarkMode = document.documentElement.classList.contains(\"dark\");\n-  const [isDrawing, setIsDrawing] = useState(false);\n-  const [drawingPath, setDrawingPath] = useState(\"\");\n-  const [lines, setLines] = useState([]);\n-  const pointsRef = useRef([]);\n-  const historyRef = useRef([]);\n-  const redoStackRef = useRef([]);\n-  const svgRef = useRef(null);\n-  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n-  const [size, setSize] = useState(thicknessOptions.thin);\n-  const [drawing, setDrawing] = useState(false);\n-  const [points, setPoints] = useState([]);\n-  const [path, setPath] = useState(\"\");\n-  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n-  const [svgWidth] = useState(500);\n-  const [tool, setTool] = useState(\"pencil\");\n-  const [history, setHistory] = useState([]);\n-  const [redoStack, setRedoStack] = useState([]);\n-  const [isResizing, setIsResizing] = useState(false);\n-  const [startY, setStartY] = useState(0);\n-  const [id] = useState(() => node.attrs.id || uuid());\n   const colorInputRef = useRef(null);\n-  const [background, setBackground] = useState(\n-    node.attrs.paperType || backgroundStyles.none\n-  );\n+  \n+  const {\n+    drawing,\n+    path,\n+    svgHeight,\n+    tool,\n+    color,\n+    size,\n+    background,\n+    svgRef,\n+    linesRef,\n+    pathsGroupRef,\n+    activePathRef,\n+    setTool,\n+    setColor,\n+    setSize,\n+    setBackground,\n+    startDrawing,\n+    draw,\n+    stopDrawing,\n+    undo,\n+    redo,\n+    deletePath,\n+    getPointerCoordinates,\n+    adjustColorForMode,\n+  } = useDrawing({\n+    initialHeight: node.attrs.height || 400,\n+    initialLines: node.attrs.lines || [],\n+    onUpdateAttributes: updateAttributes,\n+  });\n \n-  const linesRef = useRef(node.attrs.lines || []);\n+  const svgWidth = 500;\n+  const isDarkMode = document.documentElement.classList.contains(\"dark\");\n \n-  const handleBackgroundChange = (event) => {\n-    const newBackground = event.target.value;\n-    setBackground(newBackground);\n-    updateAttributes({ paperType: newBackground });\n-  };\n-\n   useEffect(() => {\n-    const svg = d3.select(svgRef.current);\n-    const eraseRadius = 5;\n-    let isErasing = false;\n-    let penActive = false;\n-    let penTimeout = null;\n-\n-    const PEN_TIMEOUT_DURATION = 700;\n-\n-    const handlePointerEvent = (event) => {\n-      if (event.pointerType === \"pen\") {\n-        penActive = true;\n-        clearTimeout(penTimeout);\n-        event.preventDefault(); // Prevent touch interaction when pen is active\n-        event.stopPropagation();\n-\n-        const [x, y] = getPointerCoordinates(event);\n-\n-        if (event.type === \"pointerdown\") {\n-          if (tool === \"erase\") {\n-            isErasing = true;\n-            eraseOverlappingPaths(x, y);\n-          } else {\n-            startDrawing(x, y);\n-          }\n-        } else if (event.type === \"pointermove\") {\n-          if (tool === \"erase\" && isErasing) {\n-            eraseOverlappingPaths(x, y);\n-          } else if (tool !== \"erase\") {\n-            draw(x, y);\n-          }\n-        } else if (event.type === \"pointerup\") {\n-          if (tool === \"erase\") {\n-            isErasing = false;\n-          } else {\n-            stopDrawing();\n-          }\n-\n-          penTimeout = setTimeout(() => {\n-            penActive = false;\n-          }, PEN_TIMEOUT_DURATION);\n-        }\n-      }\n-    };\n-\n-    const eraseOverlappingPaths = (x, y) => {\n-      const eraserArea = {\n-        x: x - eraseRadius,\n-        y: y - eraseRadius,\n-        width: eraseRadius * 2,\n-        height: eraseRadius * 2,\n-      };\n-\n-      svg.selectAll(\"path\").each(function () {\n-        const path = d3.select(this);\n-        const pathNode = path.node();\n-        const pathBBox = pathNode.getBBox();\n-\n-        if (\n-          pathBBox.x < eraserArea.x + eraserArea.width &&\n-          pathBBox.x + pathBBox.width > eraserArea.x &&\n-          pathBBox.y < eraserArea.y + eraserArea.height &&\n-          pathBBox.y + pathBBox.height > eraserArea.y\n-        ) {\n-          deletePath(pathNode);\n-        }\n-      });\n-    };\n-\n-    // Prevent scrolling when the pencil (pen) is active\n-    const preventScrolling = (event) => {\n-      if (penActive) {\n-        event.preventDefault(); // Prevent scrolling\n-        event.stopPropagation();\n-      }\n-    };\n-\n-    // Attach pen input handlers on SVG\n-    svg\n-      .on(\"pointerdown\", handlePointerEvent)\n-      .on(\"pointermove\", handlePointerEvent)\n-      .on(\"pointerup\", handlePointerEvent);\n-\n-    // Block touch interactions (scrolling) when pen is active\n-    document.body.addEventListener(\"touchstart\", preventScrolling, {\n-      passive: false,\n-    });\n-    document.body.addEventListener(\"touchmove\", preventScrolling, {\n-      passive: false,\n-    });\n-    document.body.addEventListener(\"touchend\", preventScrolling, {\n-      passive: false,\n-    });\n-\n-    // Suppress context menu (e.g., copy/paste menu) on pen input\n-    svg.on(\"contextmenu\", (event) => {\n-      if (penActive) {\n-        event.preventDefault();\n-      }\n-    });\n-\n-    // Cleanup on component unmount\n-    return () => {\n-      clearTimeout(penTimeout);\n-      document.body.removeEventListener(\"touchstart\", preventScrolling);\n-      document.body.removeEventListener(\"touchmove\", preventScrolling);\n-      document.body.removeEventListener(\"touchend\", preventScrolling);\n-    };\n-  }, [tool, color, size, points]);\n-\n-  const deletePath = (pathElement) => {\n-    const clickedPathData = pathElement.getAttribute(\"d\");\n-    const pathIndex = linesRef.current.findIndex(\n-      (line) => line.path === clickedPathData\n-    );\n-\n-    if (pathIndex !== -1) {\n-      const removedLine = linesRef.current[pathIndex];\n-\n-      // Save the deletion action\n-      setHistory((prevHistory) => [\n-        ...prevHistory,\n-        { action: \"delete\", line: removedLine },\n-      ]);\n-\n-      linesRef.current.splice(pathIndex, 1);\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n-  const handleMouseDown = (event) => {\n-    event.preventDefault();\n-  };\n-\n-  useEffect(() => {\n-    const svg = svgRef.current;\n-\n-    const preventContextMenu = (event) => event.preventDefault();\n-\n-    svg.addEventListener(\"contextmenu\", preventContextMenu);\n-\n-    return () => {\n-      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n-    };\n-  }, []);\n-\n-  useEffect(() => {\n-    const disableScroll = (event) => {\n-      if (isDrawing) {\n-        event.preventDefault();\n-      }\n-    };\n-\n-    document.addEventListener(\"touchmove\", disableScroll, { passive: false });\n-    document.addEventListener(\"wheel\", disableScroll, { passive: false });\n-\n-    return () => {\n-      document.removeEventListener(\"touchmove\", disableScroll);\n-      document.removeEventListener(\"wheel\", disableScroll);\n-    };\n-  }, [isDrawing]);\n-\n-  useEffect(() => {\n-    const handleMouseMove = (event) => {\n-      if (isResizing) {\n-        const currentY =\n-          event.clientY || (event.touches && event.touches[0].clientY);\n-        const deltaY = currentY - startY;\n-        setSvgHeight((prevHeight) => {\n-          const newHeight = Math.max(\n-            MIN_HEIGHT,\n-            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n-          );\n-          return newHeight;\n-        });\n-        setStartY(currentY);\n-      }\n-    };\n-\n-    const handleMouseUp = () => {\n-      if (isResizing) {\n-        setIsResizing(false);\n-        document.removeEventListener(\"mousemove\", handleMouseMove);\n-        document.removeEventListener(\"mouseup\", handleMouseUp);\n-        document.removeEventListener(\"touchmove\", handleMouseMove);\n-        document.removeEventListener(\"touchend\", handleMouseUp);\n-        saveHeight();\n-      }\n-    };\n-\n-    if (isResizing) {\n-      document.addEventListener(\"mousemove\", handleMouseMove);\n-      document.addEventListener(\"mouseup\", handleMouseUp);\n-      document.addEventListener(\"touchmove\", handleMouseMove);\n-      document.addEventListener(\"touchend\", handleMouseUp);\n-    }\n-\n-    return () => {\n-      document.removeEventListener(\"mousemove\", handleMouseMove);\n-      document.removeEventListener(\"mouseup\", handleMouseUp);\n-      document.removeEventListener(\"touchmove\", handleMouseMove);\n-      document.removeEventListener(\"touchend\", handleMouseUp);\n-    };\n-  }, [isResizing, startY]);\n-\n-  const getPointerCoordinates = (event) => {\n-    const svg = svgRef.current;\n-    const rect = svg.getBoundingClientRect();\n-\n-    // Get the correct pointer position, including page scroll and scale\n-    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n-    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n-\n-    // Calculate the mouse position relative to the SVG\n-    const scaleX = svg.viewBox.baseVal.width / rect.width;\n-    const scaleY = svg.viewBox.baseVal.height / rect.height;\n-\n-    const x = (clientX - rect.left) * scaleX;\n-    const y = (clientY - rect.top) * scaleY;\n-\n-    return [x, y];\n-  };\n-\n-  const startDrawing = (x, y) => {\n-    setDrawing(true);\n-    setPoints([{ x, y }]);\n-  };\n-\n-  const draw = (x, y) => {\n-    if (!drawing) return;\n-\n-    const newPoints = [...points, { x, y }];\n-    setPoints(newPoints);\n-    const newPath = lineGenerator(newPoints);\n-    setPath(newPath);\n-    if (y > svgHeight - BUFFER_ZONE) {\n-      const newHeight = svgHeight + INCREMENT_HEIGHT;\n-      setSvgHeight(newHeight);\n-      updateAttributes({ height: newHeight });\n-\n-      // Adjust scroll position to keep the drawing point in view\n-      const container = containerRef.current;\n-      if (container) {\n-        const scrollContainer = container.closest(\".drawing-component\");\n-        if (scrollContainer) {\n-          scrollContainer.scrollTo({\n-            top: scrollContainer.scrollHeight,\n-            behavior: \"smooth\",\n-          });\n-        }\n-      }\n-    }\n-  };\n-\n-  const stopDrawing = () => {\n-    if (drawing) {\n-      setDrawing(false);\n-      saveDrawing();\n-      setHistory((prevHistory) => [\n-        ...prevHistory,\n-        { id, path, color, size, tool },\n-      ]);\n-      setPath(\"\");\n-      setPoints([]);\n-    }\n-  };\n-\n-  const handleColorChange = (e) => {\n-    setColor(e.target.value);\n-  };\n-\n-  const openColorPicker = () => {\n-    colorInputRef.current.click();\n-  };\n-\n-  // Store only actions in history (add or delete)\n-  const undo = () => {\n-    if (history.length > 0) {\n-      const lastAction = history[history.length - 1];\n-      setHistory((prevHistory) => prevHistory.slice(0, -1));\n-      setRedoStack((prevStack) => [...prevStack, lastAction]);\n-\n-      if (lastAction.action === \"add\") {\n-        // Undo adding a line by removing it\n-        linesRef.current = linesRef.current.filter(\n-          (line) => line.id !== lastAction.line.id\n-        );\n-      } else if (lastAction.action === \"delete\") {\n-        // Undo deleting a line by adding it back\n-        linesRef.current = [...linesRef.current, lastAction.line];\n-      }\n-\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n-  const redo = () => {\n-    if (redoStack.length > 0) {\n-      const lastRedo = redoStack[redoStack.length - 1];\n-      setRedoStack((prevStack) => prevStack.slice(0, -1));\n-      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n-\n-      if (lastRedo.action === \"add\") {\n-        // Redo adding a line by adding it back\n-        linesRef.current = [...linesRef.current, lastRedo.line];\n-      } else if (lastRedo.action === \"delete\") {\n-        // Redo deleting a line by removing it again\n-        linesRef.current = linesRef.current.filter(\n-          (line) => line.id !== lastRedo.line.id\n-        );\n-      }\n-\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n-  const saveHeight = () => {\n-    updateAttributes({ height: svgHeight });\n-  };\n-\n-  useEffect(() => {\n     const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n       Keyboard.hide();\n     });\n \n@@ -393,402 +48,10 @@\n       showListener.remove();\n     };\n   }, []);\n \n-  const pathsGroupRef = useRef(null);\n-  const activePathRef = useRef(null);\n-  const throttleRef = useRef(null);\n-  const batchUpdateTimeoutRef = useRef(null);\n-\n-  // Memoize the line generator to prevent recreation\n-  const lineGenerator = useMemo(\n-    () =>\n-      d3\n-        .line()\n-        .x((d) => d.x)\n-        .y((d) => d.y)\n-        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n-    []\n-  );\n-\n-  const smoothPoints = (points) => {\n-    if (points.length < 3) return points;\n-    return points.map((point, i, arr) => {\n-      if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n-      const prev = arr[i - 1];\n-      const next = arr[i + 1];\n-      return {\n-        x: (prev.x + point.x + next.x) / 3,\n-        y: (prev.y + point.y + next.y) / 3,\n-      };\n-    });\n-  };\n-\n-  // Batch update function for paths\n-  const batchUpdatePaths = () => {\n-    if (batchUpdateTimeoutRef.current) {\n-      clearTimeout(batchUpdateTimeoutRef.current);\n-    }\n-\n-    batchUpdateTimeoutRef.current = setTimeout(() => {\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }, 500); // Adjust timeout as needed\n-  };\n-\n-  // Throttle draw function\n-  const throttledDraw = (x, y) => {\n-    if (!throttleRef.current) {\n-      throttleRef.current = setTimeout(() => {\n-        throttleRef.current = null;\n-      }, 16); // ~60fps\n-\n-      if (!drawing) return;\n-\n-      const newPoints = [...points, { x, y }];\n-      setPoints(newPoints);\n-\n-      const newPath = lineGenerator(smoothPoints(newPoints));\n-      setPath(newPath);\n-\n-      // Update active path directly in DOM for better performance\n-      if (activePathRef.current) {\n-        activePathRef.current.setAttribute(\"d\", newPath);\n-      }\n-\n-      // Check for canvas expansion\n-      if (y > svgHeight - BUFFER_ZONE) {\n-        const newHeight = svgHeight + INCREMENT_HEIGHT;\n-        setSvgHeight(newHeight);\n-        updateAttributes({ height: newHeight });\n-      }\n-    }\n-  };\n-\n-  // Split paths into chunks for better rendering\n-  const chunkedLines = useMemo(() => {\n-    const chunkSize = 100; // Adjust based on performance needs\n-    const chunks = [];\n-    for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n-      chunks.push(linesRef.current.slice(i, i + chunkSize));\n-    }\n-    return chunks;\n-  }, [linesRef.current.length]);\n-\n-  const adjustColorForMode = (color) => {\n-    if (isDarkMode) {\n-      // Dark mode: Black turns to white; other colors unchanged\n-      return color === \"#000000\" ? \"#FFFFFF\" : color;\n-    } else {\n-      // Light mode: White turns to black; other colors unchanged\n-      return color === \"#FFFFFF\" ? \"#000000\" : color;\n-    }\n-  };\n-\n-  // Optimize path rendering\n-  const renderPaths = () =>\n-    chunkedLines.map((chunk, chunkIndex) => (\n-      <g key={`chunk-${chunkIndex}`}>\n-        {chunk.map((item) => (\n-          <path\n-            key={`${item.id}-${item.color}-${item.size}`}\n-            d={item.path}\n-            stroke={adjustColorForMode(item.color)}\n-            strokeWidth={item.size}\n-            opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n-            fill=\"none\"\n-            vectorEffect=\"non-scaling-stroke\"\n-          />\n-        ))}\n-      </g>\n-    ));\n-\n-  // Optimize save drawing function\n-  const saveDrawing = () => {\n-    if (!path) return;\n-\n-    const newLine = { id: uuid(), path, color, size, tool };\n-    linesRef.current = [...linesRef.current, newLine];\n-\n-    setHistory((prevHistory) => [\n-      ...prevHistory,\n-      { action: \"add\", line: newLine },\n-    ]);\n-\n-    setRedoStack([]);\n-    batchUpdatePaths();\n-  };\n-\n-  return (\n-    <div className=\"draw w-full min-h-screen flex flex-col\">\n-      {/* Top Toolbar */}\n-      <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n-        {/* Left side controls */}\n-        <div className=\"flex items-center space-x-2\">\n-          <button\n-            onClick={() => {\n-              setTool(\"pencil\");\n-              setColor(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n-            }}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-2 border ${\n-              tool === \"pencil\"\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n-                : \"border-gray-300 dark:border-neutral-600\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <Icons.BallPenLine className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={() => {\n-              setTool(\"highlighter\");\n-              setColor(\"#FFFF00\");\n-            }}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-2 border ${\n-              tool === \"highlighter\"\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n-                : \"border-gray-300 dark:border-neutral-600\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <Icons.MarkPenLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={() => setTool(\"erase\")}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-2 border ${\n-              tool === \"erase\"\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n-                : \"border-gray-300 dark:border-neutral-600\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <Icons.EraserLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <div className=\"relative\">\n-            <select\n-              className=\"border border-neutral-300 dark:border-neutral-600 rounded w-full p-2 text-neutral-800 bg-[#F8F8F7] dark:bg-[#2D2C2C] dark:text-[color:var(--selected-dark-text)] outline-none appearance-none mr-6\"\n-              value={background}\n-              onChange={handleBackgroundChange}\n-            >\n-              <option value=\"none\">None</option>\n-              <option value=\"grid\">Grid</option>\n-              <option value=\"ruled\">Ruled</option>\n-              <option value=\"dotted\">Dotted</option>\n-            </select>\n-            <Icons.ArrowDownSLineIcon className=\"dark:text-[color:var(--selected-dark-text)] ri-arrow-down-s-line absolute right-3 top-1/2 transform -translate-y-1/2 text-neutral-600 pointer-events-none\" />\n-          </div>\n-        </div>\n-        {/* Right side controls */}\n-        <div className=\"flex items-center space-x-2\">\n-          <button\n-            onClick={undo}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n-          >\n-            <Icons.ArrowGoBackLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={redo}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n-          >\n-            <Icons.ArrowGoForwardLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thin)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thin\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"3\"\n-              height=\"3\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.medium)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.medium\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"4\"\n-              height=\"4\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thick)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thick\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"5\"\n-              height=\"5\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thicker)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thicker\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"6\"\n-              height=\"6\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thickest)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thickest\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"7\"\n-              height=\"7\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <div className=\"relative inline-block\">\n-            {/* Hidden color input */}\n-            <input\n-              type=\"color\"\n-              value={color}\n-              onChange={handleColorChange}\n-              ref={colorInputRef}\n-              className=\"absolute inset-0 opacity-0 cursor-pointer\"\n-            />\n-            {/* Custom button */}\n-            <button\n-              onClick={openColorPicker}\n-              style={{ backgroundColor: color }}\n-              className={`flex items-center justify-center p-1 h-10 w-10 rounded-full hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-            />\n-          </div>\n-          <button\n-            onClick={onClose}\n-            className=\"p-2 rounded-full bg-gray-100 dark:bg-neutral-800 hover:bg-gray-200 dark:hover:bg-neutral-700 transition-colors\"\n-          >\n-            <Icons.CloseLineIcon className=\"w-6 h-6\" />\n-          </button>\n-        </div>\n-      </div>\n-\n-      {/* SVG Container */}\n-      <div className=\"relative flex-grow drawing-container\">\n-        <svg\n-          ref={svgRef}\n-          viewBox={`0 0 ${svgWidth} ${svgHeight}`}\n-          preserveAspectRatio=\"xMidYMid meet\"\n-          className={`w-full h-auto ${background} bg-neutral-100 dark:bg-neutral-800`}\n-        >\n-          <g ref={pathsGroupRef}>{renderPaths()}</g>\n-          {path && (\n-            <path\n-              ref={activePathRef}\n-              d={path}\n-              stroke={adjustColorForMode(color)}\n-              strokeWidth={size}\n-              opacity={tool === \"highlighter\" ? 0.3 : 1}\n-              fill=\"none\"\n-              vectorEffect=\"non-scaling-stroke\"\n-            />\n-          )}\n-        </svg>\n-      </div>\n-    </div>\n-  );\n-};\n-\n-export default DrawMode;\n-import React, { useState, useRef, useEffect, useMemo } from \"react\";\n-import * as d3 from \"d3\";\n-import { v4 as uuid } from \"uuid\";\n-import { Keyboard } from \"@capacitor/keyboard\";\n-import Icons from \"../../../remixicon-react\";\n-\n-const thicknessOptions = {\n-  thin: 2,\n-  medium: 3,\n-  thick: 4,\n-  thicker: 5,\n-  thickest: 6,\n-};\n-\n-const backgroundStyles = {\n-  none: \"\",\n-  grid: \"grid\",\n-  ruled: \"ruled\",\n-  dotted: \"dotted\",\n-};\n-\n-const BUFFER_ZONE = 50;\n-const INCREMENT_HEIGHT = 200;\n-const PREVIEW_HEIGHT = 500;\n-\n-const DrawMode = ({ onClose, updateAttributes, node }) => {\n-  const isDarkMode = document.documentElement.classList.contains(\"dark\");\n-  const [isDrawing, setIsDrawing] = useState(false);\n-  const [drawingPath, setDrawingPath] = useState(\"\");\n-  const [lines, setLines] = useState([]);\n-  const pointsRef = useRef([]);\n-  const historyRef = useRef([]);\n-  const redoStackRef = useRef([]);\n-  const svgRef = useRef(null);\n-  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n-  const [size, setSize] = useState(thicknessOptions.thin);\n-  const [drawing, setDrawing] = useState(false);\n-  const [points, setPoints] = useState([]);\n-  const [path, setPath] = useState(\"\");\n-  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n-  const [svgWidth] = useState(500);\n-  const [tool, setTool] = useState(\"pencil\");\n-  const [history, setHistory] = useState([]);\n-  const [redoStack, setRedoStack] = useState([]);\n-  const [isResizing, setIsResizing] = useState(false);\n-  const [startY, setStartY] = useState(0);\n-  const [id] = useState(() => node.attrs.id || uuid());\n-  const colorInputRef = useRef(null);\n-  const [background, setBackground] = useState(\n-    node.attrs.paperType || backgroundStyles.none\n-  );\n-\n-  const linesRef = useRef(node.attrs.lines || []);\n-\n-  const handleBackgroundChange = (event) => {\n-    const newBackground = event.target.value;\n-    setBackground(newBackground);\n-    updateAttributes({ paperType: newBackground });\n-  };\n-\n   useEffect(() => {\n-    const svg = d3.select(svgRef.current);\n+    const svg = svgRef.current;\n     const eraseRadius = 5;\n     let isErasing = false;\n     let penActive = false;\n     let penTimeout = null;\n@@ -798,9 +61,9 @@\n     const handlePointerEvent = (event) => {\n       if (event.pointerType === \"pen\") {\n         penActive = true;\n         clearTimeout(penTimeout);\n-        event.preventDefault(); // Prevent touch interaction when pen is active\n+        event.preventDefault();\n         event.stopPropagation();\n \n         const [x, y] = getPointerCoordinates(event);\n \n@@ -838,11 +101,9 @@\n         width: eraseRadius * 2,\n         height: eraseRadius * 2,\n       };\n \n-      svg.selectAll(\"path\").each(function () {\n-        const path = d3.select(this);\n-        const pathNode = path.node();\n+      svg.querySelectorAll(\"path\").forEach((pathNode) => {\n         const pathBBox = pathNode.getBBox();\n \n         if (\n           pathBBox.x < eraserArea.x + eraserArea.width &&\n@@ -854,367 +115,56 @@\n         }\n       });\n     };\n \n-    // Prevent scrolling when the pencil (pen) is active\n     const preventScrolling = (event) => {\n       if (penActive) {\n-        event.preventDefault(); // Prevent scrolling\n+        event.preventDefault();\n         event.stopPropagation();\n       }\n     };\n \n-    // Attach pen input handlers on SVG\n-    svg\n-      .on(\"pointerdown\", handlePointerEvent)\n-      .on(\"pointermove\", handlePointerEvent)\n-      .on(\"pointerup\", handlePointerEvent);\n+    svg.addEventListener(\"pointerdown\", handlePointerEvent);\n+    svg.addEventListener(\"pointermove\", handlePointerEvent);\n+    svg.addEventListener(\"pointerup\", handlePointerEvent);\n+    document.body.addEventListener(\"touchstart\", preventScrolling, { passive: false });\n+    document.body.addEventListener(\"touchmove\", preventScrolling, { passive: false });\n+    document.body.addEventListener(\"touchend\", preventScrolling, { passive: false });\n \n-    // Block touch interactions (scrolling) when pen is active\n-    document.body.addEventListener(\"touchstart\", preventScrolling, {\n-      passive: false,\n-    });\n-    document.body.addEventListener(\"touchmove\", preventScrolling, {\n-      passive: false,\n-    });\n-    document.body.addEventListener(\"touchend\", preventScrolling, {\n-      passive: false,\n-    });\n-\n-    // Suppress context menu (e.g., copy/paste menu) on pen input\n-    svg.on(\"contextmenu\", (event) => {\n-      if (penActive) {\n-        event.preventDefault();\n-      }\n-    });\n-\n-    // Cleanup on component unmount\n     return () => {\n       clearTimeout(penTimeout);\n+      svg.removeEventListener(\"pointerdown\", handlePointerEvent);\n+      svg.removeEventListener(\"pointermove\", handlePointerEvent);\n+      svg.removeEventListener(\"pointerup\", handlePointerEvent);\n       document.body.removeEventListener(\"touchstart\", preventScrolling);\n       document.body.removeEventListener(\"touchmove\", preventScrolling);\n       document.body.removeEventListener(\"touchend\", preventScrolling);\n     };\n-  }, [tool, color, size, points]);\n+  }, [tool, deletePath, draw, startDrawing, stopDrawing, getPointerCoordinates]);\n \n-  const deletePath = (pathElement) => {\n-    const clickedPathData = pathElement.getAttribute(\"d\");\n-    const pathIndex = linesRef.current.findIndex(\n-      (line) => line.path === clickedPathData\n-    );\n-\n-    if (pathIndex !== -1) {\n-      const removedLine = linesRef.current[pathIndex];\n-\n-      // Save the deletion action\n-      setHistory((prevHistory) => [\n-        ...prevHistory,\n-        { action: \"delete\", line: removedLine },\n-      ]);\n-\n-      linesRef.current.splice(pathIndex, 1);\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n+  const handleBackgroundChange = (event) => {\n+    const newBackground = event.target.value;\n+    setBackground(newBackground);\n+    updateAttributes({ paperType: newBackground });\n   };\n \n-  const handleMouseDown = (event) => {\n-    event.preventDefault();\n-  };\n-\n-  useEffect(() => {\n-    const svg = svgRef.current;\n-\n-    const preventContextMenu = (event) => event.preventDefault();\n-\n-    svg.addEventListener(\"contextmenu\", preventContextMenu);\n-\n-    return () => {\n-      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n-    };\n-  }, []);\n-\n-  useEffect(() => {\n-    const disableScroll = (event) => {\n-      if (isDrawing) {\n-        event.preventDefault();\n-      }\n-    };\n-\n-    document.addEventListener(\"touchmove\", disableScroll, { passive: false });\n-    document.addEventListener(\"wheel\", disableScroll, { passive: false });\n-\n-    return () => {\n-      document.removeEventListener(\"touchmove\", disableScroll);\n-      document.removeEventListener(\"wheel\", disableScroll);\n-    };\n-  }, [isDrawing]);\n-\n-  useEffect(() => {\n-    const handleMouseMove = (event) => {\n-      if (isResizing) {\n-        const currentY =\n-          event.clientY || (event.touches && event.touches[0].clientY);\n-        const deltaY = currentY - startY;\n-        setSvgHeight((prevHeight) => {\n-          const newHeight = Math.max(\n-            MIN_HEIGHT,\n-            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n-          );\n-          return newHeight;\n-        });\n-        setStartY(currentY);\n-      }\n-    };\n-\n-    const handleMouseUp = () => {\n-      if (isResizing) {\n-        setIsResizing(false);\n-        document.removeEventListener(\"mousemove\", handleMouseMove);\n-        document.removeEventListener(\"mouseup\", handleMouseUp);\n-        document.removeEventListener(\"touchmove\", handleMouseMove);\n-        document.removeEventListener(\"touchend\", handleMouseUp);\n-        saveHeight();\n-      }\n-    };\n-\n-    if (isResizing) {\n-      document.addEventListener(\"mousemove\", handleMouseMove);\n-      document.addEventListener(\"mouseup\", handleMouseUp);\n-      document.addEventListener(\"touchmove\", handleMouseMove);\n-      document.addEventListener(\"touchend\", handleMouseUp);\n-    }\n-\n-    return () => {\n-      document.removeEventListener(\"mousemove\", handleMouseMove);\n-      document.removeEventListener(\"mouseup\", handleMouseUp);\n-      document.removeEventListener(\"touchmove\", handleMouseMove);\n-      document.removeEventListener(\"touchend\", handleMouseUp);\n-    };\n-  }, [isResizing, startY]);\n-\n-  const getPointerCoordinates = (event) => {\n-    const svg = svgRef.current;\n-    const rect = svg.getBoundingClientRect();\n-\n-    // Get the correct pointer position, including page scroll and scale\n-    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n-    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n-\n-    // Calculate the mouse position relative to the SVG\n-    const scaleX = svg.viewBox.baseVal.width / rect.width;\n-    const scaleY = svg.viewBox.baseVal.height / rect.height;\n-\n-    const x = (clientX - rect.left) * scaleX;\n-    const y = (clientY - rect.top) * scaleY;\n-\n-    return [x, y];\n-  };\n-\n-  const startDrawing = (x, y) => {\n-    setDrawing(true);\n-    setPoints([{ x, y }]);\n-  };\n-\n-  const draw = (x, y) => {\n-    if (!drawing) return;\n-\n-    const newPoints = [...points, { x, y }];\n-    setPoints(newPoints);\n-    const newPath = lineGenerator(newPoints);\n-    setPath(newPath);\n-    if (y > svgHeight - BUFFER_ZONE) {\n-      const newHeight = svgHeight + INCREMENT_HEIGHT;\n-      setSvgHeight(newHeight);\n-      updateAttributes({ height: newHeight });\n-\n-      // Adjust scroll position to keep the drawing point in view\n-      const container = containerRef.current;\n-      if (container) {\n-        const scrollContainer = container.closest(\".drawing-component\");\n-        if (scrollContainer) {\n-          scrollContainer.scrollTo({\n-            top: scrollContainer.scrollHeight,\n-            behavior: \"smooth\",\n-          });\n-        }\n-      }\n-    }\n-  };\n-\n-  const stopDrawing = () => {\n-    if (drawing) {\n-      setDrawing(false);\n-      saveDrawing();\n-      setHistory((prevHistory) => [\n-        ...prevHistory,\n-        { id, path, color, size, tool },\n-      ]);\n-      setPath(\"\");\n-      setPoints([]);\n-    }\n-  };\n-\n   const handleColorChange = (e) => {\n     setColor(e.target.value);\n   };\n \n   const openColorPicker = () => {\n     colorInputRef.current.click();\n   };\n \n-  // Store only actions in history (add or delete)\n-  const undo = () => {\n-    if (history.length > 0) {\n-      const lastAction = history[history.length - 1];\n-      setHistory((prevHistory) => prevHistory.slice(0, -1));\n-      setRedoStack((prevStack) => [...prevStack, lastAction]);\n-\n-      if (lastAction.action === \"add\") {\n-        // Undo adding a line by removing it\n-        linesRef.current = linesRef.current.filter(\n-          (line) => line.id !== lastAction.line.id\n-        );\n-      } else if (lastAction.action === \"delete\") {\n-        // Undo deleting a line by adding it back\n-        linesRef.current = [...linesRef.current, lastAction.line];\n-      }\n-\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n-  const redo = () => {\n-    if (redoStack.length > 0) {\n-      const lastRedo = redoStack[redoStack.length - 1];\n-      setRedoStack((prevStack) => prevStack.slice(0, -1));\n-      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n-\n-      if (lastRedo.action === \"add\") {\n-        // Redo adding a line by adding it back\n-        linesRef.current = [...linesRef.current, lastRedo.line];\n-      } else if (lastRedo.action === \"delete\") {\n-        // Redo deleting a line by removing it again\n-        linesRef.current = linesRef.current.filter(\n-          (line) => line.id !== lastRedo.line.id\n-        );\n-      }\n-\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n-  const saveHeight = () => {\n-    updateAttributes({ height: svgHeight });\n-  };\n-\n-  useEffect(() => {\n-    const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n-      Keyboard.hide();\n-    });\n-\n-    return () => {\n-      showListener.remove();\n-    };\n-  }, []);\n-\n-  const pathsGroupRef = useRef(null);\n-  const activePathRef = useRef(null);\n-  const throttleRef = useRef(null);\n-  const batchUpdateTimeoutRef = useRef(null);\n-\n-  // Memoize the line generator to prevent recreation\n-  const lineGenerator = useMemo(\n-    () =>\n-      d3\n-        .line()\n-        .x((d) => d.x)\n-        .y((d) => d.y)\n-        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n-    []\n-  );\n-\n-  const smoothPoints = (points) => {\n-    if (points.length < 3) return points;\n-    return points.map((point, i, arr) => {\n-      if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n-      const prev = arr[i - 1];\n-      const next = arr[i + 1];\n-      return {\n-        x: (prev.x + point.x + next.x) / 3,\n-        y: (prev.y + point.y + next.y) / 3,\n-      };\n-    });\n-  };\n-\n-  // Batch update function for paths\n-  const batchUpdatePaths = () => {\n-    if (batchUpdateTimeoutRef.current) {\n-      clearTimeout(batchUpdateTimeoutRef.current);\n-    }\n-\n-    batchUpdateTimeoutRef.current = setTimeout(() => {\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }, 500); // Adjust timeout as needed\n-  };\n-\n-  // Throttle draw function\n-  const throttledDraw = (x, y) => {\n-    if (!throttleRef.current) {\n-      throttleRef.current = setTimeout(() => {\n-        throttleRef.current = null;\n-      }, 16); // ~60fps\n-\n-      if (!drawing) return;\n-\n-      const newPoints = [...points, { x, y }];\n-      setPoints(newPoints);\n-\n-      const newPath = lineGenerator(smoothPoints(newPoints));\n-      setPath(newPath);\n-\n-      // Update active path directly in DOM for better performance\n-      if (activePathRef.current) {\n-        activePathRef.current.setAttribute(\"d\", newPath);\n-      }\n-\n-      // Check for canvas expansion\n-      if (y > svgHeight - BUFFER_ZONE) {\n-        const newHeight = svgHeight + INCREMENT_HEIGHT;\n-        setSvgHeight(newHeight);\n-        updateAttributes({ height: newHeight });\n-      }\n-    }\n-  };\n-\n-  // Split paths into chunks for better rendering\n-  const chunkedLines = useMemo(() => {\n-    const chunkSize = 100; // Adjust based on performance needs\n+  const chunkedLines = React.useMemo(() => {\n+    const chunkSize = 100;\n     const chunks = [];\n     for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n       chunks.push(linesRef.current.slice(i, i + chunkSize));\n     }\n     return chunks;\n   }, [linesRef.current.length]);\n \n-  const adjustColorForMode = (color) => {\n-    if (isDarkMode) {\n-      // Dark mode: Black turns to white; other colors unchanged\n-      return color === \"#000000\" ? \"#FFFFFF\" : color;\n-    } else {\n-      // Light mode: White turns to black; other colors unchanged\n-      return color === \"#FFFFFF\" ? \"#000000\" : color;\n-    }\n-  };\n-\n-  // Optimize path rendering\n   const renderPaths = () =>\n     chunkedLines.map((chunk, chunkIndex) => (\n       <g key={`chunk-${chunkIndex}`}>\n         {chunk.map((item) => (\n@@ -1230,227 +180,13 @@\n         ))}\n       </g>\n     ));\n \n-  // Optimize save drawing function\n-  const saveDrawing = () => {\n-    if (!path) return;\n-\n-    const newLine = { id: uuid(), path, color, size, tool };\n-    linesRef.current = [...linesRef.current, newLine];\n-\n-    setHistory((prevHistory) => [\n-      ...prevHistory,\n-      { action: \"add\", line: newLine },\n-    ]);\n-\n-    setRedoStack([]);\n-    batchUpdatePaths();\n-  };\n-\n+  // Rest of your JSX remains the same, just update the references to use the hook's values and methods\n   return (\n     <div className=\"draw w-full min-h-screen flex flex-col\">\n-      {/* Top Toolbar */}\n-      <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n-        {/* Left side controls */}\n-        <div className=\"flex items-center space-x-2\">\n-          <button\n-            onClick={() => {\n-              setTool(\"pencil\");\n-              setColor(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n-            }}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-2 border ${\n-              tool === \"pencil\"\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n-                : \"border-gray-300 dark:border-neutral-600\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <Icons.BallPenLine className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={() => {\n-              setTool(\"highlighter\");\n-              setColor(\"#FFFF00\");\n-            }}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-2 border ${\n-              tool === \"highlighter\"\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n-                : \"border-gray-300 dark:border-neutral-600\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <Icons.MarkPenLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={() => setTool(\"erase\")}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-2 border ${\n-              tool === \"erase\"\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n-                : \"border-gray-300 dark:border-neutral-600\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <Icons.EraserLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <div className=\"relative\">\n-            <select\n-              className=\"border border-neutral-300 dark:border-neutral-600 rounded w-full p-2 text-neutral-800 bg-[#F8F8F7] dark:bg-[#2D2C2C] dark:text-[color:var(--selected-dark-text)] outline-none appearance-none mr-6\"\n-              value={background}\n-              onChange={handleBackgroundChange}\n-            >\n-              <option value=\"none\">None</option>\n-              <option value=\"grid\">Grid</option>\n-              <option value=\"ruled\">Ruled</option>\n-              <option value=\"dotted\">Dotted</option>\n-            </select>\n-            <Icons.ArrowDownSLineIcon className=\"dark:text-[color:var(--selected-dark-text)] ri-arrow-down-s-line absolute right-3 top-1/2 transform -translate-y-1/2 text-neutral-600 pointer-events-none\" />\n-          </div>\n-        </div>\n-        {/* Right side controls */}\n-        <div className=\"flex items-center space-x-2\">\n-          <button\n-            onClick={undo}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n-          >\n-            <Icons.ArrowGoBackLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={redo}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n-          >\n-            <Icons.ArrowGoForwardLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thin)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thin\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"3\"\n-              height=\"3\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.medium)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.medium\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"4\"\n-              height=\"4\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thick)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thick\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"5\"\n-              height=\"5\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thicker)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thicker\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"6\"\n-              height=\"6\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thickest)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thickest\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"7\"\n-              height=\"7\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <div className=\"relative inline-block\">\n-            {/* Hidden color input */}\n-            <input\n-              type=\"color\"\n-              value={color}\n-              onChange={handleColorChange}\n-              ref={colorInputRef}\n-              className=\"absolute inset-0 opacity-0 cursor-pointer\"\n-            />\n-            {/* Custom button */}\n-            <button\n-              onClick={openColorPicker}\n-              style={{ backgroundColor: color }}\n-              className={`flex items-center justify-center p-1 h-10 w-10 rounded-full hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-            />\n-          </div>\n-          <button\n-            onClick={onClose}\n-            className=\"p-2 rounded-full bg-gray-100 dark:bg-neutral-800 hover:bg-gray-200 dark:hover:bg-neutral-700 transition-colors\"\n-          >\n-            <Icons.CloseLineIcon className=\"w-6 h-6\" />\n-          </button>\n-        </div>\n-      </div>\n-\n-      {/* SVG Container */}\n-      <div className=\"relative flex-grow drawing-container\">\n-        <svg\n-          ref={svgRef}\n-          viewBox={`0 0 ${svgWidth} ${svgHeight}`}\n-          preserveAspectRatio=\"xMidYMid meet\"\n-          className={`w-full h-auto ${background}`}\n-        >\n-          <g ref={pathsGroupRef}>{renderPaths()}</g>\n-          {path && (\n-            <path\n-              ref={activePathRef}\n-              d={path}\n-              stroke={adjustColorForMode(color)}\n-              strokeWidth={size}\n-              opacity={tool === \"highlighter\" ? 0.3 : 1}\n-              fill=\"none\"\n-              vectorEffect=\"non-scaling-stroke\"\n-            />\n-          )}\n-        </svg>\n-      </div>\n+      {/* Your existing JSX here, using the values and methods from the hook */}\n     </div>\n   );\n };\n \n-export default DrawMode;\n+export default DrawMode;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1732017090882,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,24 +50,26 @@\n   }, []);\n \n   useEffect(() => {\n     const svg = svgRef.current;\n+    if (!svg) return; // Exit if ref is not set\n+  \n     const eraseRadius = 5;\n     let isErasing = false;\n     let penActive = false;\n     let penTimeout = null;\n-\n+  \n     const PEN_TIMEOUT_DURATION = 700;\n-\n+  \n     const handlePointerEvent = (event) => {\n       if (event.pointerType === \"pen\") {\n         penActive = true;\n         clearTimeout(penTimeout);\n         event.preventDefault();\n         event.stopPropagation();\n-\n+  \n         const [x, y] = getPointerCoordinates(event);\n-\n+  \n         if (event.type === \"pointerdown\") {\n           if (tool === \"erase\") {\n             isErasing = true;\n             eraseOverlappingPaths(x, y);\n@@ -85,27 +87,27 @@\n             isErasing = false;\n           } else {\n             stopDrawing();\n           }\n-\n+  \n           penTimeout = setTimeout(() => {\n             penActive = false;\n           }, PEN_TIMEOUT_DURATION);\n         }\n       }\n     };\n-\n+  \n     const eraseOverlappingPaths = (x, y) => {\n       const eraserArea = {\n         x: x - eraseRadius,\n         y: y - eraseRadius,\n         width: eraseRadius * 2,\n         height: eraseRadius * 2,\n       };\n-\n+  \n       svg.querySelectorAll(\"path\").forEach((pathNode) => {\n         const pathBBox = pathNode.getBBox();\n-\n+  \n         if (\n           pathBBox.x < eraserArea.x + eraserArea.width &&\n           pathBBox.x + pathBBox.width > eraserArea.x &&\n           pathBBox.y < eraserArea.y + eraserArea.height &&\n@@ -114,23 +116,23 @@\n           deletePath(pathNode);\n         }\n       });\n     };\n-\n+  \n     const preventScrolling = (event) => {\n       if (penActive) {\n         event.preventDefault();\n         event.stopPropagation();\n       }\n     };\n-\n+  \n     svg.addEventListener(\"pointerdown\", handlePointerEvent);\n     svg.addEventListener(\"pointermove\", handlePointerEvent);\n     svg.addEventListener(\"pointerup\", handlePointerEvent);\n     document.body.addEventListener(\"touchstart\", preventScrolling, { passive: false });\n     document.body.addEventListener(\"touchmove\", preventScrolling, { passive: false });\n     document.body.addEventListener(\"touchend\", preventScrolling, { passive: false });\n-\n+  \n     return () => {\n       clearTimeout(penTimeout);\n       svg.removeEventListener(\"pointerdown\", handlePointerEvent);\n       svg.removeEventListener(\"pointermove\", handlePointerEvent);\n@@ -139,8 +141,9 @@\n       document.body.removeEventListener(\"touchmove\", preventScrolling);\n       document.body.removeEventListener(\"touchend\", preventScrolling);\n     };\n   }, [tool, deletePath, draw, startDrawing, stopDrawing, getPointerCoordinates]);\n+  \n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n     setBackground(newBackground);\n"
                },
                {
                    "date": 1732017127951,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -186,9 +186,208 @@\n \n   // Rest of your JSX remains the same, just update the references to use the hook's values and methods\n   return (\n     <div className=\"draw w-full min-h-screen flex flex-col\">\n-      {/* Your existing JSX here, using the values and methods from the hook */}\n+      {/* Top Toolbar */}\n+      <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n+        {/* Left side controls */}\n+        <div className=\"flex items-center space-x-2\">\n+          <button\n+            onClick={() => {\n+              setTool(\"pencil\");\n+              setColor(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n+            }}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-2 border ${\n+              tool === \"pencil\"\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n+                : \"border-gray-300 dark:border-neutral-600\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <Icons.BallPenLine className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={() => {\n+              setTool(\"highlighter\");\n+              setColor(\"#FFFF00\");\n+            }}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-2 border ${\n+              tool === \"highlighter\"\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n+                : \"border-gray-300 dark:border-neutral-600\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <Icons.MarkPenLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={() => setTool(\"erase\")}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-2 border ${\n+              tool === \"erase\"\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n+                : \"border-gray-300 dark:border-neutral-600\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <Icons.EraserLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <div className=\"relative\">\n+            <select\n+              className=\"border border-neutral-300 dark:border-neutral-600 rounded w-full p-2 text-neutral-800 bg-[#F8F8F7] dark:bg-[#2D2C2C] dark:text-[color:var(--selected-dark-text)] outline-none appearance-none mr-6\"\n+              value={background}\n+              onChange={handleBackgroundChange}\n+            >\n+              <option value=\"none\">None</option>\n+              <option value=\"grid\">Grid</option>\n+              <option value=\"ruled\">Ruled</option>\n+              <option value=\"dotted\">Dotted</option>\n+            </select>\n+            <Icons.ArrowDownSLineIcon className=\"dark:text-[color:var(--selected-dark-text)] ri-arrow-down-s-line absolute right-3 top-1/2 transform -translate-y-1/2 text-neutral-600 pointer-events-none\" />\n+          </div>\n+        </div>\n+        {/* Right side controls */}\n+        <div className=\"flex items-center space-x-2\">\n+          <button\n+            onClick={undo}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n+          >\n+            <Icons.ArrowGoBackLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={redo}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n+          >\n+            <Icons.ArrowGoForwardLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thin)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thin\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"3\"\n+              height=\"3\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.medium)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.medium\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"4\"\n+              height=\"4\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thick)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thick\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"5\"\n+              height=\"5\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thicker)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thicker\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"6\"\n+              height=\"6\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thickest)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thickest\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"7\"\n+              height=\"7\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <div className=\"relative inline-block\">\n+            {/* Hidden color input */}\n+            <input\n+              type=\"color\"\n+              value={color}\n+              onChange={handleColorChange}\n+              ref={colorInputRef}\n+              className=\"absolute inset-0 opacity-0 cursor-pointer\"\n+            />\n+            {/* Custom button */}\n+            <button\n+              onClick={openColorPicker}\n+              style={{ backgroundColor: color }}\n+              className={`flex items-center justify-center p-1 h-10 w-10 rounded-full hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+            />\n+          </div>\n+          <button\n+            onClick={onClose}\n+            className=\"p-2 rounded-full bg-gray-100 dark:bg-neutral-800 hover:bg-gray-200 dark:hover:bg-neutral-700 transition-colors\"\n+          >\n+            <Icons.CloseLineIcon className=\"w-6 h-6\" />\n+          </button>\n+        </div>\n+      </div>\n+\n+      {/* SVG Container */}\n+      <div className=\"relative flex-grow drawing-container\">\n+        <svg\n+          ref={svgRef}\n+          viewBox={`0 0 ${svgWidth} ${svgHeight}`}\n+          preserveAspectRatio=\"xMidYMid meet\"\n+          className={`w-full h-auto ${background} bg-neutral-100 dark:bg-neutral-800`}\n+        >\n+          <g ref={pathsGroupRef}>{renderPaths()}</g>\n+          {path && (\n+            <path\n+              ref={activePathRef}\n+              d={path}\n+              stroke={adjustColorForMode(color)}\n+              strokeWidth={size}\n+              opacity={tool === \"highlighter\" ? 0.3 : 1}\n+              fill=\"none\"\n+              vectorEffect=\"non-scaling-stroke\"\n+            />\n+          )}\n+        </svg>\n+      </div>\n     </div>\n   );\n };\n \n"
                },
                {
                    "date": 1732121952586,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n import { useDrawing, thicknessOptions, backgroundStyles } from \"./useDrawing\";\n \n const DrawMode = ({ onClose, updateAttributes, node }) => {\n   const colorInputRef = useRef(null);\n-  \n+\n   const {\n     drawing,\n     path,\n     svgHeight,\n@@ -33,8 +33,9 @@\n   } = useDrawing({\n     initialHeight: node.attrs.height || 400,\n     initialLines: node.attrs.lines || [],\n     onUpdateAttributes: updateAttributes,\n+    node: node,\n   });\n \n   const svgWidth = 500;\n   const isDarkMode = document.documentElement.classList.contains(\"dark\");\n@@ -51,25 +52,25 @@\n \n   useEffect(() => {\n     const svg = svgRef.current;\n     if (!svg) return; // Exit if ref is not set\n-  \n+\n     const eraseRadius = 5;\n     let isErasing = false;\n     let penActive = false;\n     let penTimeout = null;\n-  \n+\n     const PEN_TIMEOUT_DURATION = 700;\n-  \n+\n     const handlePointerEvent = (event) => {\n       if (event.pointerType === \"pen\") {\n         penActive = true;\n         clearTimeout(penTimeout);\n         event.preventDefault();\n         event.stopPropagation();\n-  \n+\n         const [x, y] = getPointerCoordinates(event);\n-  \n+\n         if (event.type === \"pointerdown\") {\n           if (tool === \"erase\") {\n             isErasing = true;\n             eraseOverlappingPaths(x, y);\n@@ -87,27 +88,27 @@\n             isErasing = false;\n           } else {\n             stopDrawing();\n           }\n-  \n+\n           penTimeout = setTimeout(() => {\n             penActive = false;\n           }, PEN_TIMEOUT_DURATION);\n         }\n       }\n     };\n-  \n+\n     const eraseOverlappingPaths = (x, y) => {\n       const eraserArea = {\n         x: x - eraseRadius,\n         y: y - eraseRadius,\n         width: eraseRadius * 2,\n         height: eraseRadius * 2,\n       };\n-  \n+\n       svg.querySelectorAll(\"path\").forEach((pathNode) => {\n         const pathBBox = pathNode.getBBox();\n-  \n+\n         if (\n           pathBBox.x < eraserArea.x + eraserArea.width &&\n           pathBBox.x + pathBBox.width > eraserArea.x &&\n           pathBBox.y < eraserArea.y + eraserArea.height &&\n@@ -116,23 +117,29 @@\n           deletePath(pathNode);\n         }\n       });\n     };\n-  \n+\n     const preventScrolling = (event) => {\n       if (penActive) {\n         event.preventDefault();\n         event.stopPropagation();\n       }\n     };\n-  \n+\n     svg.addEventListener(\"pointerdown\", handlePointerEvent);\n     svg.addEventListener(\"pointermove\", handlePointerEvent);\n     svg.addEventListener(\"pointerup\", handlePointerEvent);\n-    document.body.addEventListener(\"touchstart\", preventScrolling, { passive: false });\n-    document.body.addEventListener(\"touchmove\", preventScrolling, { passive: false });\n-    document.body.addEventListener(\"touchend\", preventScrolling, { passive: false });\n-  \n+    document.body.addEventListener(\"touchstart\", preventScrolling, {\n+      passive: false,\n+    });\n+    document.body.addEventListener(\"touchmove\", preventScrolling, {\n+      passive: false,\n+    });\n+    document.body.addEventListener(\"touchend\", preventScrolling, {\n+      passive: false,\n+    });\n+\n     return () => {\n       clearTimeout(penTimeout);\n       svg.removeEventListener(\"pointerdown\", handlePointerEvent);\n       svg.removeEventListener(\"pointermove\", handlePointerEvent);\n@@ -140,10 +147,16 @@\n       document.body.removeEventListener(\"touchstart\", preventScrolling);\n       document.body.removeEventListener(\"touchmove\", preventScrolling);\n       document.body.removeEventListener(\"touchend\", preventScrolling);\n     };\n-  }, [tool, deletePath, draw, startDrawing, stopDrawing, getPointerCoordinates]);\n-  \n+  }, [\n+    tool,\n+    deletePath,\n+    draw,\n+    startDrawing,\n+    stopDrawing,\n+    getPointerCoordinates,\n+  ]);\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n     setBackground(newBackground);\n@@ -390,5 +403,5 @@\n     </div>\n   );\n };\n \n-export default DrawMode;\n\\ No newline at end of file\n+export default DrawMode;\n"
                },
                {
                    "date": 1732137385879,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,8 @@\n   } = useDrawing({\n     initialHeight: node.attrs.height || 400,\n     initialLines: node.attrs.lines || [],\n     onUpdateAttributes: updateAttributes,\n-    node: node,\n   });\n \n   const svgWidth = 500;\n   const isDarkMode = document.documentElement.classList.contains(\"dark\");\n"
                },
                {
                    "date": 1732138218732,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,59 +1,67 @@\n-import React, { useRef, useEffect } from \"react\";\n+import React, { useState, useRef, useEffect, useMemo } from \"react\";\n+import * as d3 from \"d3\";\n+import { v4 as uuid } from \"uuid\";\n import { Keyboard } from \"@capacitor/keyboard\";\n import Icons from \"../../../remixicon-react\";\n-import { useDrawing, thicknessOptions, backgroundStyles } from \"./useDrawing\";\n+import { useDrawing } from \"./useDrawing\";\n \n-const DrawMode = ({ onClose, updateAttributes, node }) => {\n-  const colorInputRef = useRef(null);\n+const thicknessOptions = {\n+  thin: 2,\n+  medium: 3,\n+  thick: 4,\n+  thicker: 5,\n+  thickest: 6,\n+};\n \n-  const {\n-    drawing,\n-    path,\n-    svgHeight,\n-    tool,\n-    color,\n-    size,\n-    background,\n-    svgRef,\n-    linesRef,\n-    pathsGroupRef,\n-    activePathRef,\n-    setTool,\n-    setColor,\n-    setSize,\n-    setBackground,\n-    startDrawing,\n-    draw,\n-    stopDrawing,\n-    undo,\n-    redo,\n-    deletePath,\n-    getPointerCoordinates,\n-    adjustColorForMode,\n-  } = useDrawing({\n-    initialHeight: node.attrs.height || 400,\n-    initialLines: node.attrs.lines || [],\n-    onUpdateAttributes: updateAttributes,\n-  });\n+const backgroundStyles = {\n+  none: \"\",\n+  grid: \"grid\",\n+  ruled: \"ruled\",\n+  dotted: \"dotted\",\n+};\n \n-  const svgWidth = 500;\n+const BUFFER_ZONE = 50;\n+const INCREMENT_HEIGHT = 200;\n+const PREVIEW_HEIGHT = 500;\n+\n+const DrawMode = ({ onClose, updateAttributes, node }) => {\n   const isDarkMode = document.documentElement.classList.contains(\"dark\");\n+  const [isDrawing, setIsDrawing] = useState(false);\n+  const [drawingPath, setDrawingPath] = useState(\"\");\n+  const [lines, setLines] = useState([]);\n+  const pointsRef = useRef([]);\n+  const historyRef = useRef([]);\n+  const redoStackRef = useRef([]);\n+  const svgRef = useRef(null);\n+  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n+  const [size, setSize] = useState(thicknessOptions.thin);\n+  const [drawing, setDrawing] = useState(false);\n+  const [points, setPoints] = useState([]);\n+  const [path, setPath] = useState(\"\");\n+  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n+  const [svgWidth] = useState(500);\n+  const [tool, setTool] = useState(\"pencil\");\n+  const [history, setHistory] = useState([]);\n+  const [redoStack, setRedoStack] = useState([]);\n+  const [isResizing, setIsResizing] = useState(false);\n+  const [startY, setStartY] = useState(0);\n+  const [id] = useState(() => node.attrs.id || uuid());\n+  const colorInputRef = useRef(null);\n+  const [background, setBackground] = useState(\n+    node.attrs.paperType || backgroundStyles.none\n+  );\n \n-  useEffect(() => {\n-    const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n-      Keyboard.hide();\n-    });\n+  const linesRef = useRef(node.attrs.lines || []);\n \n-    return () => {\n-      showListener.remove();\n-    };\n-  }, []);\n+  const handleBackgroundChange = (event) => {\n+    const newBackground = event.target.value;\n+    setBackground(newBackground);\n+    updateAttributes({ paperType: newBackground });\n+  };\n \n   useEffect(() => {\n-    const svg = svgRef.current;\n-    if (!svg) return; // Exit if ref is not set\n-\n+    const svg = d3.select(svgRef.current);\n     const eraseRadius = 5;\n     let isErasing = false;\n     let penActive = false;\n     let penTimeout = null;\n@@ -63,9 +71,9 @@\n     const handlePointerEvent = (event) => {\n       if (event.pointerType === \"pen\") {\n         penActive = true;\n         clearTimeout(penTimeout);\n-        event.preventDefault();\n+        event.preventDefault(); // Prevent touch interaction when pen is active\n         event.stopPropagation();\n \n         const [x, y] = getPointerCoordinates(event);\n \n@@ -103,9 +111,11 @@\n         width: eraseRadius * 2,\n         height: eraseRadius * 2,\n       };\n \n-      svg.querySelectorAll(\"path\").forEach((pathNode) => {\n+      svg.selectAll(\"path\").each(function () {\n+        const path = d3.select(this);\n+        const pathNode = path.node();\n         const pathBBox = pathNode.getBBox();\n \n         if (\n           pathBBox.x < eraserArea.x + eraserArea.width &&\n@@ -117,18 +127,23 @@\n         }\n       });\n     };\n \n+    // Prevent scrolling when the pencil (pen) is active\n     const preventScrolling = (event) => {\n       if (penActive) {\n-        event.preventDefault();\n+        event.preventDefault(); // Prevent scrolling\n         event.stopPropagation();\n       }\n     };\n \n-    svg.addEventListener(\"pointerdown\", handlePointerEvent);\n-    svg.addEventListener(\"pointermove\", handlePointerEvent);\n-    svg.addEventListener(\"pointerup\", handlePointerEvent);\n+    // Attach pen input handlers on SVG\n+    svg\n+      .on(\"pointerdown\", handlePointerEvent)\n+      .on(\"pointermove\", handlePointerEvent)\n+      .on(\"pointerup\", handlePointerEvent);\n+\n+    // Block touch interactions (scrolling) when pen is active\n     document.body.addEventListener(\"touchstart\", preventScrolling, {\n       passive: false,\n     });\n     document.body.addEventListener(\"touchmove\", preventScrolling, {\n@@ -137,49 +152,342 @@\n     document.body.addEventListener(\"touchend\", preventScrolling, {\n       passive: false,\n     });\n \n+    // Suppress context menu (e.g., copy/paste menu) on pen input\n+    svg.on(\"contextmenu\", (event) => {\n+      if (penActive) {\n+        event.preventDefault();\n+      }\n+    });\n+\n+    // Cleanup on component unmount\n     return () => {\n       clearTimeout(penTimeout);\n-      svg.removeEventListener(\"pointerdown\", handlePointerEvent);\n-      svg.removeEventListener(\"pointermove\", handlePointerEvent);\n-      svg.removeEventListener(\"pointerup\", handlePointerEvent);\n       document.body.removeEventListener(\"touchstart\", preventScrolling);\n       document.body.removeEventListener(\"touchmove\", preventScrolling);\n       document.body.removeEventListener(\"touchend\", preventScrolling);\n     };\n-  }, [\n-    tool,\n-    deletePath,\n-    draw,\n-    startDrawing,\n-    stopDrawing,\n-    getPointerCoordinates,\n-  ]);\n+  }, [tool, color, size, points]);\n \n-  const handleBackgroundChange = (event) => {\n-    const newBackground = event.target.value;\n-    setBackground(newBackground);\n-    updateAttributes({ paperType: newBackground });\n+  const deletePath = (pathElement) => {\n+    const clickedPathData = pathElement.getAttribute(\"d\");\n+    const pathIndex = linesRef.current.findIndex(\n+      (line) => line.path === clickedPathData\n+    );\n+\n+    if (pathIndex !== -1) {\n+      const removedLine = linesRef.current[pathIndex];\n+\n+      // Save the deletion action\n+      setHistory((prevHistory) => [\n+        ...prevHistory,\n+        { action: \"delete\", line: removedLine },\n+      ]);\n+\n+      linesRef.current.splice(pathIndex, 1);\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n   };\n \n+  const handleMouseDown = (event) => {\n+    event.preventDefault();\n+  };\n+\n+  useEffect(() => {\n+    const svg = svgRef.current;\n+\n+    const preventContextMenu = (event) => event.preventDefault();\n+\n+    svg.addEventListener(\"contextmenu\", preventContextMenu);\n+\n+    return () => {\n+      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n+    };\n+  }, []);\n+\n+  useEffect(() => {\n+    const disableScroll = (event) => {\n+      if (isDrawing) {\n+        event.preventDefault();\n+      }\n+    };\n+\n+    document.addEventListener(\"touchmove\", disableScroll, { passive: false });\n+    document.addEventListener(\"wheel\", disableScroll, { passive: false });\n+\n+    return () => {\n+      document.removeEventListener(\"touchmove\", disableScroll);\n+      document.removeEventListener(\"wheel\", disableScroll);\n+    };\n+  }, [isDrawing]);\n+\n+  useEffect(() => {\n+    const handleMouseMove = (event) => {\n+      if (isResizing) {\n+        const currentY =\n+          event.clientY || (event.touches && event.touches[0].clientY);\n+        const deltaY = currentY - startY;\n+        setSvgHeight((prevHeight) => {\n+          const newHeight = Math.max(\n+            MIN_HEIGHT,\n+            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n+          );\n+          return newHeight;\n+        });\n+        setStartY(currentY);\n+      }\n+    };\n+\n+    const handleMouseUp = () => {\n+      if (isResizing) {\n+        setIsResizing(false);\n+        document.removeEventListener(\"mousemove\", handleMouseMove);\n+        document.removeEventListener(\"mouseup\", handleMouseUp);\n+        document.removeEventListener(\"touchmove\", handleMouseMove);\n+        document.removeEventListener(\"touchend\", handleMouseUp);\n+        saveHeight();\n+      }\n+    };\n+\n+    if (isResizing) {\n+      document.addEventListener(\"mousemove\", handleMouseMove);\n+      document.addEventListener(\"mouseup\", handleMouseUp);\n+      document.addEventListener(\"touchmove\", handleMouseMove);\n+      document.addEventListener(\"touchend\", handleMouseUp);\n+    }\n+\n+    return () => {\n+      document.removeEventListener(\"mousemove\", handleMouseMove);\n+      document.removeEventListener(\"mouseup\", handleMouseUp);\n+      document.removeEventListener(\"touchmove\", handleMouseMove);\n+      document.removeEventListener(\"touchend\", handleMouseUp);\n+    };\n+  }, [isResizing, startY]);\n+\n+  const getPointerCoordinates = (event) => {\n+    const svg = svgRef.current;\n+    const rect = svg.getBoundingClientRect();\n+\n+    // Get the correct pointer position, including page scroll and scale\n+    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n+    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n+\n+    // Calculate the mouse position relative to the SVG\n+    const scaleX = svg.viewBox.baseVal.width / rect.width;\n+    const scaleY = svg.viewBox.baseVal.height / rect.height;\n+\n+    const x = (clientX - rect.left) * scaleX;\n+    const y = (clientY - rect.top) * scaleY;\n+\n+    return [x, y];\n+  };\n+\n+  const startDrawing = (x, y) => {\n+    setDrawing(true);\n+    setPoints([{ x, y }]);\n+  };\n+\n+  const draw = (x, y) => {\n+    if (!drawing) return;\n+\n+    const newPoints = [...points, { x, y }];\n+    setPoints(newPoints);\n+    const newPath = lineGenerator(newPoints);\n+    setPath(newPath);\n+    if (y > svgHeight - BUFFER_ZONE) {\n+      const newHeight = svgHeight + INCREMENT_HEIGHT;\n+      setSvgHeight(newHeight);\n+      updateAttributes({ height: newHeight });\n+\n+      // Adjust scroll position to keep the drawing point in view\n+      const container = containerRef.current;\n+      if (container) {\n+        const scrollContainer = container.closest(\".drawing-component\");\n+        if (scrollContainer) {\n+          scrollContainer.scrollTo({\n+            top: scrollContainer.scrollHeight,\n+            behavior: \"smooth\",\n+          });\n+        }\n+      }\n+    }\n+  };\n+\n+  const stopDrawing = () => {\n+    if (drawing) {\n+      setDrawing(false);\n+      saveDrawing();\n+      setHistory((prevHistory) => [\n+        ...prevHistory,\n+        { id, path, color, size, tool },\n+      ]);\n+      setPath(\"\");\n+      setPoints([]);\n+    }\n+  };\n+\n   const handleColorChange = (e) => {\n     setColor(e.target.value);\n   };\n \n   const openColorPicker = () => {\n     colorInputRef.current.click();\n   };\n \n-  const chunkedLines = React.useMemo(() => {\n-    const chunkSize = 100;\n+  // Store only actions in history (add or delete)\n+  const undo = () => {\n+    if (history.length > 0) {\n+      const lastAction = history[history.length - 1];\n+      setHistory((prevHistory) => prevHistory.slice(0, -1));\n+      setRedoStack((prevStack) => [...prevStack, lastAction]);\n+\n+      if (lastAction.action === \"add\") {\n+        // Undo adding a line by removing it\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastAction.line.id\n+        );\n+      } else if (lastAction.action === \"delete\") {\n+        // Undo deleting a line by adding it back\n+        linesRef.current = [...linesRef.current, lastAction.line];\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const redo = () => {\n+    if (redoStack.length > 0) {\n+      const lastRedo = redoStack[redoStack.length - 1];\n+      setRedoStack((prevStack) => prevStack.slice(0, -1));\n+      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n+\n+      if (lastRedo.action === \"add\") {\n+        // Redo adding a line by adding it back\n+        linesRef.current = [...linesRef.current, lastRedo.line];\n+      } else if (lastRedo.action === \"delete\") {\n+        // Redo deleting a line by removing it again\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastRedo.line.id\n+        );\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const saveHeight = () => {\n+    updateAttributes({ height: svgHeight });\n+  };\n+\n+  useEffect(() => {\n+    const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n+      Keyboard.hide();\n+    });\n+\n+    return () => {\n+      showListener.remove();\n+    };\n+  }, []);\n+\n+  const pathsGroupRef = useRef(null);\n+  const activePathRef = useRef(null);\n+  const throttleRef = useRef(null);\n+  const batchUpdateTimeoutRef = useRef(null);\n+\n+  // Memoize the line generator to prevent recreation\n+  const lineGenerator = useMemo(\n+    () =>\n+      d3\n+        .line()\n+        .x((d) => d.x)\n+        .y((d) => d.y)\n+        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n+    []\n+  );\n+\n+  const smoothPoints = (points) => {\n+    if (points.length < 3) return points;\n+    return points.map((point, i, arr) => {\n+      if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n+      const prev = arr[i - 1];\n+      const next = arr[i + 1];\n+      return {\n+        x: (prev.x + point.x + next.x) / 3,\n+        y: (prev.y + point.y + next.y) / 3,\n+      };\n+    });\n+  };\n+\n+  // Batch update function for paths\n+  const batchUpdatePaths = () => {\n+    if (batchUpdateTimeoutRef.current) {\n+      clearTimeout(batchUpdateTimeoutRef.current);\n+    }\n+\n+    batchUpdateTimeoutRef.current = setTimeout(() => {\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }, 500); // Adjust timeout as needed\n+  };\n+\n+  // Throttle draw function\n+  const throttledDraw = (x, y) => {\n+    if (!throttleRef.current) {\n+      throttleRef.current = setTimeout(() => {\n+        throttleRef.current = null;\n+      }, 16); // ~60fps\n+\n+      if (!drawing) return;\n+\n+      const newPoints = [...points, { x, y }];\n+      setPoints(newPoints);\n+\n+      const newPath = lineGenerator(smoothPoints(newPoints));\n+      setPath(newPath);\n+\n+      // Update active path directly in DOM for better performance\n+      if (activePathRef.current) {\n+        activePathRef.current.setAttribute(\"d\", newPath);\n+      }\n+\n+      // Check for canvas expansion\n+      if (y > svgHeight - BUFFER_ZONE) {\n+        const newHeight = svgHeight + INCREMENT_HEIGHT;\n+        setSvgHeight(newHeight);\n+        updateAttributes({ height: newHeight });\n+      }\n+    }\n+  };\n+\n+  // Split paths into chunks for better rendering\n+  const chunkedLines = useMemo(() => {\n+    const chunkSize = 100; // Adjust based on performance needs\n     const chunks = [];\n     for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n       chunks.push(linesRef.current.slice(i, i + chunkSize));\n     }\n     return chunks;\n   }, [linesRef.current.length]);\n \n+  const adjustColorForMode = (color) => {\n+    if (isDarkMode) {\n+      // Dark mode: Black turns to white; other colors unchanged\n+      return color === \"#000000\" ? \"#FFFFFF\" : color;\n+    } else {\n+      // Light mode: White turns to black; other colors unchanged\n+      return color === \"#FFFFFF\" ? \"#000000\" : color;\n+    }\n+  };\n+\n+  // Optimize path rendering\n   const renderPaths = () =>\n     chunkedLines.map((chunk, chunkIndex) => (\n       <g key={`chunk-${chunkIndex}`}>\n         {chunk.map((item) => (\n@@ -195,9 +503,24 @@\n         ))}\n       </g>\n     ));\n \n-  // Rest of your JSX remains the same, just update the references to use the hook's values and methods\n+  // Optimize save drawing function\n+  const saveDrawing = () => {\n+    if (!path) return;\n+\n+    const newLine = { id: uuid(), path, color, size, tool };\n+    linesRef.current = [...linesRef.current, newLine];\n+\n+    setHistory((prevHistory) => [\n+      ...prevHistory,\n+      { action: \"add\", line: newLine },\n+    ]);\n+\n+    setRedoStack([]);\n+    batchUpdatePaths();\n+  };\n+\n   return (\n     <div className=\"draw w-full min-h-screen flex flex-col\">\n       {/* Top Toolbar */}\n       <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n"
                },
                {
                    "date": 1732138334077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,10 +49,12 @@\n   const colorInputRef = useRef(null);\n   const [background, setBackground] = useState(\n     node.attrs.paperType || backgroundStyles.none\n   );\n+  const {\n+  } = useDrawing({\n+  });\n \n-  const linesRef = useRef(node.attrs.lines || []);\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n     setBackground(newBackground);\n"
                },
                {
                    "date": 1732138383633,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,13 +49,10 @@\n   const colorInputRef = useRef(null);\n   const [background, setBackground] = useState(\n     node.attrs.paperType || backgroundStyles.none\n   );\n-  const {\n-  } = useDrawing({\n-  });\n+  const { deletePath } = useDrawing({});\n \n-\n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n     setBackground(newBackground);\n     updateAttributes({ paperType: newBackground });\n@@ -170,30 +167,8 @@\n       document.body.removeEventListener(\"touchend\", preventScrolling);\n     };\n   }, [tool, color, size, points]);\n \n-  const deletePath = (pathElement) => {\n-    const clickedPathData = pathElement.getAttribute(\"d\");\n-    const pathIndex = linesRef.current.findIndex(\n-      (line) => line.path === clickedPathData\n-    );\n-\n-    if (pathIndex !== -1) {\n-      const removedLine = linesRef.current[pathIndex];\n-\n-      // Save the deletion action\n-      setHistory((prevHistory) => [\n-        ...prevHistory,\n-        { action: \"delete\", line: removedLine },\n-      ]);\n-\n-      linesRef.current.splice(pathIndex, 1);\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n   const handleMouseDown = (event) => {\n     event.preventDefault();\n   };\n \n"
                },
                {
                    "date": 1732138451831,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,664 @@\n+import React, { useState, useRef, useEffect, useMemo } from \"react\";\n+import * as d3 from \"d3\";\n+import { v4 as uuid } from \"uuid\";\n+import { Keyboard } from \"@capacitor/keyboard\";\n+import Icons from \"../../../remixicon-react\";\n+import { useDrawing } from \"./useDrawing\";\n+\n+const thicknessOptions = {\n+  thin: 2,\n+  medium: 3,\n+  thick: 4,\n+  thicker: 5,\n+  thickest: 6,\n+};\n+\n+const backgroundStyles = {\n+  none: \"\",\n+  grid: \"grid\",\n+  ruled: \"ruled\",\n+  dotted: \"dotted\",\n+};\n+\n+const BUFFER_ZONE = 50;\n+const INCREMENT_HEIGHT = 200;\n+const PREVIEW_HEIGHT = 500;\n+\n+const DrawMode = ({ onClose, updateAttributes, node }) => {\n+  const isDarkMode = document.documentElement.classList.contains(\"dark\");\n+  const [isDrawing, setIsDrawing] = useState(false);\n+  const [drawingPath, setDrawingPath] = useState(\"\");\n+  const [lines, setLines] = useState([]);\n+  const pointsRef = useRef([]);\n+  const historyRef = useRef([]);\n+  const redoStackRef = useRef([]);\n+  const svgRef = useRef(null);\n+  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n+  const [size, setSize] = useState(thicknessOptions.thin);\n+  const [drawing, setDrawing] = useState(false);\n+  const [points, setPoints] = useState([]);\n+  const [path, setPath] = useState(\"\");\n+  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n+  const [svgWidth] = useState(500);\n+  const [tool, setTool] = useState(\"pencil\");\n+  const [history, setHistory] = useState([]);\n+  const [redoStack, setRedoStack] = useState([]);\n+  const [isResizing, setIsResizing] = useState(false);\n+  const [startY, setStartY] = useState(0);\n+  const [id] = useState(() => node.attrs.id || uuid());\n+  const colorInputRef = useRef(null);\n+  const [background, setBackground] = useState(\n+    node.attrs.paperType || backgroundStyles.none\n+  );\n+  const { deletePath, startDrawing, draw, stopDrawing } = useDrawing({});\n+\n+  const handleBackgroundChange = (event) => {\n+    const newBackground = event.target.value;\n+    setBackground(newBackground);\n+    updateAttributes({ paperType: newBackground });\n+  };\n+\n+  useEffect(() => {\n+    const svg = d3.select(svgRef.current);\n+    const eraseRadius = 5;\n+    let isErasing = false;\n+    let penActive = false;\n+    let penTimeout = null;\n+\n+    const PEN_TIMEOUT_DURATION = 700;\n+\n+    const handlePointerEvent = (event) => {\n+      if (event.pointerType === \"pen\") {\n+        penActive = true;\n+        clearTimeout(penTimeout);\n+        event.preventDefault(); // Prevent touch interaction when pen is active\n+        event.stopPropagation();\n+\n+        const [x, y] = getPointerCoordinates(event);\n+\n+        if (event.type === \"pointerdown\") {\n+          if (tool === \"erase\") {\n+            isErasing = true;\n+            eraseOverlappingPaths(x, y);\n+          } else {\n+            startDrawing(x, y);\n+          }\n+        } else if (event.type === \"pointermove\") {\n+          if (tool === \"erase\" && isErasing) {\n+            eraseOverlappingPaths(x, y);\n+          } else if (tool !== \"erase\") {\n+            draw(x, y);\n+          }\n+        } else if (event.type === \"pointerup\") {\n+          if (tool === \"erase\") {\n+            isErasing = false;\n+          } else {\n+            stopDrawing();\n+          }\n+\n+          penTimeout = setTimeout(() => {\n+            penActive = false;\n+          }, PEN_TIMEOUT_DURATION);\n+        }\n+      }\n+    };\n+\n+    const eraseOverlappingPaths = (x, y) => {\n+      const eraserArea = {\n+        x: x - eraseRadius,\n+        y: y - eraseRadius,\n+        width: eraseRadius * 2,\n+        height: eraseRadius * 2,\n+      };\n+\n+      svg.selectAll(\"path\").each(function () {\n+        const path = d3.select(this);\n+        const pathNode = path.node();\n+        const pathBBox = pathNode.getBBox();\n+\n+        if (\n+          pathBBox.x < eraserArea.x + eraserArea.width &&\n+          pathBBox.x + pathBBox.width > eraserArea.x &&\n+          pathBBox.y < eraserArea.y + eraserArea.height &&\n+          pathBBox.y + pathBBox.height > eraserArea.y\n+        ) {\n+          deletePath(pathNode);\n+        }\n+      });\n+    };\n+\n+    // Prevent scrolling when the pencil (pen) is active\n+    const preventScrolling = (event) => {\n+      if (penActive) {\n+        event.preventDefault(); // Prevent scrolling\n+        event.stopPropagation();\n+      }\n+    };\n+\n+    // Attach pen input handlers on SVG\n+    svg\n+      .on(\"pointerdown\", handlePointerEvent)\n+      .on(\"pointermove\", handlePointerEvent)\n+      .on(\"pointerup\", handlePointerEvent);\n+\n+    // Block touch interactions (scrolling) when pen is active\n+    document.body.addEventListener(\"touchstart\", preventScrolling, {\n+      passive: false,\n+    });\n+    document.body.addEventListener(\"touchmove\", preventScrolling, {\n+      passive: false,\n+    });\n+    document.body.addEventListener(\"touchend\", preventScrolling, {\n+      passive: false,\n+    });\n+\n+    // Suppress context menu (e.g., copy/paste menu) on pen input\n+    svg.on(\"contextmenu\", (event) => {\n+      if (penActive) {\n+        event.preventDefault();\n+      }\n+    });\n+\n+    // Cleanup on component unmount\n+    return () => {\n+      clearTimeout(penTimeout);\n+      document.body.removeEventListener(\"touchstart\", preventScrolling);\n+      document.body.removeEventListener(\"touchmove\", preventScrolling);\n+      document.body.removeEventListener(\"touchend\", preventScrolling);\n+    };\n+  }, [tool, color, size, points]);\n+\n+  const handleMouseDown = (event) => {\n+    event.preventDefault();\n+  };\n+\n+  useEffect(() => {\n+    const svg = svgRef.current;\n+\n+    const preventContextMenu = (event) => event.preventDefault();\n+\n+    svg.addEventListener(\"contextmenu\", preventContextMenu);\n+\n+    return () => {\n+      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n+    };\n+  }, []);\n+\n+  useEffect(() => {\n+    const disableScroll = (event) => {\n+      if (isDrawing) {\n+        event.preventDefault();\n+      }\n+    };\n+\n+    document.addEventListener(\"touchmove\", disableScroll, { passive: false });\n+    document.addEventListener(\"wheel\", disableScroll, { passive: false });\n+\n+    return () => {\n+      document.removeEventListener(\"touchmove\", disableScroll);\n+      document.removeEventListener(\"wheel\", disableScroll);\n+    };\n+  }, [isDrawing]);\n+\n+  useEffect(() => {\n+    const handleMouseMove = (event) => {\n+      if (isResizing) {\n+        const currentY =\n+          event.clientY || (event.touches && event.touches[0].clientY);\n+        const deltaY = currentY - startY;\n+        setSvgHeight((prevHeight) => {\n+          const newHeight = Math.max(\n+            MIN_HEIGHT,\n+            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n+          );\n+          return newHeight;\n+        });\n+        setStartY(currentY);\n+      }\n+    };\n+\n+    const handleMouseUp = () => {\n+      if (isResizing) {\n+        setIsResizing(false);\n+        document.removeEventListener(\"mousemove\", handleMouseMove);\n+        document.removeEventListener(\"mouseup\", handleMouseUp);\n+        document.removeEventListener(\"touchmove\", handleMouseMove);\n+        document.removeEventListener(\"touchend\", handleMouseUp);\n+        saveHeight();\n+      }\n+    };\n+\n+    if (isResizing) {\n+      document.addEventListener(\"mousemove\", handleMouseMove);\n+      document.addEventListener(\"mouseup\", handleMouseUp);\n+      document.addEventListener(\"touchmove\", handleMouseMove);\n+      document.addEventListener(\"touchend\", handleMouseUp);\n+    }\n+\n+    return () => {\n+      document.removeEventListener(\"mousemove\", handleMouseMove);\n+      document.removeEventListener(\"mouseup\", handleMouseUp);\n+      document.removeEventListener(\"touchmove\", handleMouseMove);\n+      document.removeEventListener(\"touchend\", handleMouseUp);\n+    };\n+  }, [isResizing, startY]);\n+\n+  const getPointerCoordinates = (event) => {\n+    const svg = svgRef.current;\n+    const rect = svg.getBoundingClientRect();\n+\n+    // Get the correct pointer position, including page scroll and scale\n+    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n+    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n+\n+    // Calculate the mouse position relative to the SVG\n+    const scaleX = svg.viewBox.baseVal.width / rect.width;\n+    const scaleY = svg.viewBox.baseVal.height / rect.height;\n+\n+    const x = (clientX - rect.left) * scaleX;\n+    const y = (clientY - rect.top) * scaleY;\n+\n+    return [x, y];\n+  };\n+\n+\n+\n+  const handleColorChange = (e) => {\n+    setColor(e.target.value);\n+  };\n+\n+  const openColorPicker = () => {\n+    colorInputRef.current.click();\n+  };\n+\n+  // Store only actions in history (add or delete)\n+  const undo = () => {\n+    if (history.length > 0) {\n+      const lastAction = history[history.length - 1];\n+      setHistory((prevHistory) => prevHistory.slice(0, -1));\n+      setRedoStack((prevStack) => [...prevStack, lastAction]);\n+\n+      if (lastAction.action === \"add\") {\n+        // Undo adding a line by removing it\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastAction.line.id\n+        );\n+      } else if (lastAction.action === \"delete\") {\n+        // Undo deleting a line by adding it back\n+        linesRef.current = [...linesRef.current, lastAction.line];\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const redo = () => {\n+    if (redoStack.length > 0) {\n+      const lastRedo = redoStack[redoStack.length - 1];\n+      setRedoStack((prevStack) => prevStack.slice(0, -1));\n+      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n+\n+      if (lastRedo.action === \"add\") {\n+        // Redo adding a line by adding it back\n+        linesRef.current = [...linesRef.current, lastRedo.line];\n+      } else if (lastRedo.action === \"delete\") {\n+        // Redo deleting a line by removing it again\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastRedo.line.id\n+        );\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const saveHeight = () => {\n+    updateAttributes({ height: svgHeight });\n+  };\n+\n+  useEffect(() => {\n+    const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n+      Keyboard.hide();\n+    });\n+\n+    return () => {\n+      showListener.remove();\n+    };\n+  }, []);\n+\n+  const pathsGroupRef = useRef(null);\n+  const activePathRef = useRef(null);\n+  const throttleRef = useRef(null);\n+  const batchUpdateTimeoutRef = useRef(null);\n+\n+  // Memoize the line generator to prevent recreation\n+  const lineGenerator = useMemo(\n+    () =>\n+      d3\n+        .line()\n+        .x((d) => d.x)\n+        .y((d) => d.y)\n+        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n+    []\n+  );\n+\n+  const smoothPoints = (points) => {\n+    if (points.length < 3) return points;\n+    return points.map((point, i, arr) => {\n+      if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n+      const prev = arr[i - 1];\n+      const next = arr[i + 1];\n+      return {\n+        x: (prev.x + point.x + next.x) / 3,\n+        y: (prev.y + point.y + next.y) / 3,\n+      };\n+    });\n+  };\n+\n+  // Batch update function for paths\n+  const batchUpdatePaths = () => {\n+    if (batchUpdateTimeoutRef.current) {\n+      clearTimeout(batchUpdateTimeoutRef.current);\n+    }\n+\n+    batchUpdateTimeoutRef.current = setTimeout(() => {\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }, 500); // Adjust timeout as needed\n+  };\n+\n+  // Throttle draw function\n+  const throttledDraw = (x, y) => {\n+    if (!throttleRef.current) {\n+      throttleRef.current = setTimeout(() => {\n+        throttleRef.current = null;\n+      }, 16); // ~60fps\n+\n+      if (!drawing) return;\n+\n+      const newPoints = [...points, { x, y }];\n+      setPoints(newPoints);\n+\n+      const newPath = lineGenerator(smoothPoints(newPoints));\n+      setPath(newPath);\n+\n+      // Update active path directly in DOM for better performance\n+      if (activePathRef.current) {\n+        activePathRef.current.setAttribute(\"d\", newPath);\n+      }\n+\n+      // Check for canvas expansion\n+      if (y > svgHeight - BUFFER_ZONE) {\n+        const newHeight = svgHeight + INCREMENT_HEIGHT;\n+        setSvgHeight(newHeight);\n+        updateAttributes({ height: newHeight });\n+      }\n+    }\n+  };\n+\n+  // Split paths into chunks for better rendering\n+  const chunkedLines = useMemo(() => {\n+    const chunkSize = 100; // Adjust based on performance needs\n+    const chunks = [];\n+    for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n+      chunks.push(linesRef.current.slice(i, i + chunkSize));\n+    }\n+    return chunks;\n+  }, [linesRef.current.length]);\n+\n+  const adjustColorForMode = (color) => {\n+    if (isDarkMode) {\n+      // Dark mode: Black turns to white; other colors unchanged\n+      return color === \"#000000\" ? \"#FFFFFF\" : color;\n+    } else {\n+      // Light mode: White turns to black; other colors unchanged\n+      return color === \"#FFFFFF\" ? \"#000000\" : color;\n+    }\n+  };\n+\n+  // Optimize path rendering\n+  const renderPaths = () =>\n+    chunkedLines.map((chunk, chunkIndex) => (\n+      <g key={`chunk-${chunkIndex}`}>\n+        {chunk.map((item) => (\n+          <path\n+            key={`${item.id}-${item.color}-${item.size}`}\n+            d={item.path}\n+            stroke={adjustColorForMode(item.color)}\n+            strokeWidth={item.size}\n+            opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n+            fill=\"none\"\n+            vectorEffect=\"non-scaling-stroke\"\n+          />\n+        ))}\n+      </g>\n+    ));\n+\n+  // Optimize save drawing function\n+  const saveDrawing = () => {\n+    if (!path) return;\n+\n+    const newLine = { id: uuid(), path, color, size, tool };\n+    linesRef.current = [...linesRef.current, newLine];\n+\n+    setHistory((prevHistory) => [\n+      ...prevHistory,\n+      { action: \"add\", line: newLine },\n+    ]);\n+\n+    setRedoStack([]);\n+    batchUpdatePaths();\n+  };\n+\n+  return (\n+    <div className=\"draw w-full min-h-screen flex flex-col\">\n+      {/* Top Toolbar */}\n+      <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n+        {/* Left side controls */}\n+        <div className=\"flex items-center space-x-2\">\n+          <button\n+            onClick={() => {\n+              setTool(\"pencil\");\n+              setColor(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n+            }}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-2 border ${\n+              tool === \"pencil\"\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n+                : \"border-gray-300 dark:border-neutral-600\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <Icons.BallPenLine className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={() => {\n+              setTool(\"highlighter\");\n+              setColor(\"#FFFF00\");\n+            }}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-2 border ${\n+              tool === \"highlighter\"\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n+                : \"border-gray-300 dark:border-neutral-600\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <Icons.MarkPenLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={() => setTool(\"erase\")}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-2 border ${\n+              tool === \"erase\"\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n+                : \"border-gray-300 dark:border-neutral-600\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <Icons.EraserLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <div className=\"relative\">\n+            <select\n+              className=\"border border-neutral-300 dark:border-neutral-600 rounded w-full p-2 text-neutral-800 bg-[#F8F8F7] dark:bg-[#2D2C2C] dark:text-[color:var(--selected-dark-text)] outline-none appearance-none mr-6\"\n+              value={background}\n+              onChange={handleBackgroundChange}\n+            >\n+              <option value=\"none\">None</option>\n+              <option value=\"grid\">Grid</option>\n+              <option value=\"ruled\">Ruled</option>\n+              <option value=\"dotted\">Dotted</option>\n+            </select>\n+            <Icons.ArrowDownSLineIcon className=\"dark:text-[color:var(--selected-dark-text)] ri-arrow-down-s-line absolute right-3 top-1/2 transform -translate-y-1/2 text-neutral-600 pointer-events-none\" />\n+          </div>\n+        </div>\n+        {/* Right side controls */}\n+        <div className=\"flex items-center space-x-2\">\n+          <button\n+            onClick={undo}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n+          >\n+            <Icons.ArrowGoBackLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={redo}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n+          >\n+            <Icons.ArrowGoForwardLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thin)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thin\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"3\"\n+              height=\"3\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.medium)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.medium\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"4\"\n+              height=\"4\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thick)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thick\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"5\"\n+              height=\"5\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thicker)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thicker\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"6\"\n+              height=\"6\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thickest)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thickest\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"7\"\n+              height=\"7\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <div className=\"relative inline-block\">\n+            {/* Hidden color input */}\n+            <input\n+              type=\"color\"\n+              value={color}\n+              onChange={handleColorChange}\n+              ref={colorInputRef}\n+              className=\"absolute inset-0 opacity-0 cursor-pointer\"\n+            />\n+            {/* Custom button */}\n+            <button\n+              onClick={openColorPicker}\n+              style={{ backgroundColor: color }}\n+              className={`flex items-center justify-center p-1 h-10 w-10 rounded-full hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+            />\n+          </div>\n+          <button\n+            onClick={onClose}\n+            className=\"p-2 rounded-full bg-gray-100 dark:bg-neutral-800 hover:bg-gray-200 dark:hover:bg-neutral-700 transition-colors\"\n+          >\n+            <Icons.CloseLineIcon className=\"w-6 h-6\" />\n+          </button>\n+        </div>\n+      </div>\n+\n+      {/* SVG Container */}\n+      <div className=\"relative flex-grow drawing-container\">\n+        <svg\n+          ref={svgRef}\n+          viewBox={`0 0 ${svgWidth} ${svgHeight}`}\n+          preserveAspectRatio=\"xMidYMid meet\"\n+          className={`w-full h-auto ${background} bg-neutral-100 dark:bg-neutral-800`}\n+        >\n+          <g ref={pathsGroupRef}>{renderPaths()}</g>\n+          {path && (\n+            <path\n+              ref={activePathRef}\n+              d={path}\n+              stroke={adjustColorForMode(color)}\n+              strokeWidth={size}\n+              opacity={tool === \"highlighter\" ? 0.3 : 1}\n+              fill=\"none\"\n+              vectorEffect=\"non-scaling-stroke\"\n+            />\n+          )}\n+        </svg>\n+      </div>\n+    </div>\n+  );\n+};\n+\n+export default DrawMode;\n"
                },
                {
                    "date": 1732138464796,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -270,53 +270,8 @@\n   const openColorPicker = () => {\n     colorInputRef.current.click();\n   };\n \n-  // Store only actions in history (add or delete)\n-  const undo = () => {\n-    if (history.length > 0) {\n-      const lastAction = history[history.length - 1];\n-      setHistory((prevHistory) => prevHistory.slice(0, -1));\n-      setRedoStack((prevStack) => [...prevStack, lastAction]);\n-\n-      if (lastAction.action === \"add\") {\n-        // Undo adding a line by removing it\n-        linesRef.current = linesRef.current.filter(\n-          (line) => line.id !== lastAction.line.id\n-        );\n-      } else if (lastAction.action === \"delete\") {\n-        // Undo deleting a line by adding it back\n-        linesRef.current = [...linesRef.current, lastAction.line];\n-      }\n-\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n-  const redo = () => {\n-    if (redoStack.length > 0) {\n-      const lastRedo = redoStack[redoStack.length - 1];\n-      setRedoStack((prevStack) => prevStack.slice(0, -1));\n-      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n-\n-      if (lastRedo.action === \"add\") {\n-        // Redo adding a line by adding it back\n-        linesRef.current = [...linesRef.current, lastRedo.line];\n-      } else if (lastRedo.action === \"delete\") {\n-        // Redo deleting a line by removing it again\n-        linesRef.current = linesRef.current.filter(\n-          (line) => line.id !== lastRedo.line.id\n-        );\n-      }\n-\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n   const saveHeight = () => {\n     updateAttributes({ height: svgHeight });\n   };\n \n@@ -661,710 +616,4 @@\n   );\n };\n \n export default DrawMode;\n-import React, { useState, useRef, useEffect, useMemo } from \"react\";\n-import * as d3 from \"d3\";\n-import { v4 as uuid } from \"uuid\";\n-import { Keyboard } from \"@capacitor/keyboard\";\n-import Icons from \"../../../remixicon-react\";\n-import { useDrawing } from \"./useDrawing\";\n-\n-const thicknessOptions = {\n-  thin: 2,\n-  medium: 3,\n-  thick: 4,\n-  thicker: 5,\n-  thickest: 6,\n-};\n-\n-const backgroundStyles = {\n-  none: \"\",\n-  grid: \"grid\",\n-  ruled: \"ruled\",\n-  dotted: \"dotted\",\n-};\n-\n-const BUFFER_ZONE = 50;\n-const INCREMENT_HEIGHT = 200;\n-const PREVIEW_HEIGHT = 500;\n-\n-const DrawMode = ({ onClose, updateAttributes, node }) => {\n-  const isDarkMode = document.documentElement.classList.contains(\"dark\");\n-  const [isDrawing, setIsDrawing] = useState(false);\n-  const [drawingPath, setDrawingPath] = useState(\"\");\n-  const [lines, setLines] = useState([]);\n-  const pointsRef = useRef([]);\n-  const historyRef = useRef([]);\n-  const redoStackRef = useRef([]);\n-  const svgRef = useRef(null);\n-  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n-  const [size, setSize] = useState(thicknessOptions.thin);\n-  const [drawing, setDrawing] = useState(false);\n-  const [points, setPoints] = useState([]);\n-  const [path, setPath] = useState(\"\");\n-  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n-  const [svgWidth] = useState(500);\n-  const [tool, setTool] = useState(\"pencil\");\n-  const [history, setHistory] = useState([]);\n-  const [redoStack, setRedoStack] = useState([]);\n-  const [isResizing, setIsResizing] = useState(false);\n-  const [startY, setStartY] = useState(0);\n-  const [id] = useState(() => node.attrs.id || uuid());\n-  const colorInputRef = useRef(null);\n-  const [background, setBackground] = useState(\n-    node.attrs.paperType || backgroundStyles.none\n-  );\n-  const { deletePath } = useDrawing({});\n-\n-  const handleBackgroundChange = (event) => {\n-    const newBackground = event.target.value;\n-    setBackground(newBackground);\n-    updateAttributes({ paperType: newBackground });\n-  };\n-\n-  useEffect(() => {\n-    const svg = d3.select(svgRef.current);\n-    const eraseRadius = 5;\n-    let isErasing = false;\n-    let penActive = false;\n-    let penTimeout = null;\n-\n-    const PEN_TIMEOUT_DURATION = 700;\n-\n-    const handlePointerEvent = (event) => {\n-      if (event.pointerType === \"pen\") {\n-        penActive = true;\n-        clearTimeout(penTimeout);\n-        event.preventDefault(); // Prevent touch interaction when pen is active\n-        event.stopPropagation();\n-\n-        const [x, y] = getPointerCoordinates(event);\n-\n-        if (event.type === \"pointerdown\") {\n-          if (tool === \"erase\") {\n-            isErasing = true;\n-            eraseOverlappingPaths(x, y);\n-          } else {\n-            startDrawing(x, y);\n-          }\n-        } else if (event.type === \"pointermove\") {\n-          if (tool === \"erase\" && isErasing) {\n-            eraseOverlappingPaths(x, y);\n-          } else if (tool !== \"erase\") {\n-            draw(x, y);\n-          }\n-        } else if (event.type === \"pointerup\") {\n-          if (tool === \"erase\") {\n-            isErasing = false;\n-          } else {\n-            stopDrawing();\n-          }\n-\n-          penTimeout = setTimeout(() => {\n-            penActive = false;\n-          }, PEN_TIMEOUT_DURATION);\n-        }\n-      }\n-    };\n-\n-    const eraseOverlappingPaths = (x, y) => {\n-      const eraserArea = {\n-        x: x - eraseRadius,\n-        y: y - eraseRadius,\n-        width: eraseRadius * 2,\n-        height: eraseRadius * 2,\n-      };\n-\n-      svg.selectAll(\"path\").each(function () {\n-        const path = d3.select(this);\n-        const pathNode = path.node();\n-        const pathBBox = pathNode.getBBox();\n-\n-        if (\n-          pathBBox.x < eraserArea.x + eraserArea.width &&\n-          pathBBox.x + pathBBox.width > eraserArea.x &&\n-          pathBBox.y < eraserArea.y + eraserArea.height &&\n-          pathBBox.y + pathBBox.height > eraserArea.y\n-        ) {\n-          deletePath(pathNode);\n-        }\n-      });\n-    };\n-\n-    // Prevent scrolling when the pencil (pen) is active\n-    const preventScrolling = (event) => {\n-      if (penActive) {\n-        event.preventDefault(); // Prevent scrolling\n-        event.stopPropagation();\n-      }\n-    };\n-\n-    // Attach pen input handlers on SVG\n-    svg\n-      .on(\"pointerdown\", handlePointerEvent)\n-      .on(\"pointermove\", handlePointerEvent)\n-      .on(\"pointerup\", handlePointerEvent);\n-\n-    // Block touch interactions (scrolling) when pen is active\n-    document.body.addEventListener(\"touchstart\", preventScrolling, {\n-      passive: false,\n-    });\n-    document.body.addEventListener(\"touchmove\", preventScrolling, {\n-      passive: false,\n-    });\n-    document.body.addEventListener(\"touchend\", preventScrolling, {\n-      passive: false,\n-    });\n-\n-    // Suppress context menu (e.g., copy/paste menu) on pen input\n-    svg.on(\"contextmenu\", (event) => {\n-      if (penActive) {\n-        event.preventDefault();\n-      }\n-    });\n-\n-    // Cleanup on component unmount\n-    return () => {\n-      clearTimeout(penTimeout);\n-      document.body.removeEventListener(\"touchstart\", preventScrolling);\n-      document.body.removeEventListener(\"touchmove\", preventScrolling);\n-      document.body.removeEventListener(\"touchend\", preventScrolling);\n-    };\n-  }, [tool, color, size, points]);\n-\n-  const handleMouseDown = (event) => {\n-    event.preventDefault();\n-  };\n-\n-  useEffect(() => {\n-    const svg = svgRef.current;\n-\n-    const preventContextMenu = (event) => event.preventDefault();\n-\n-    svg.addEventListener(\"contextmenu\", preventContextMenu);\n-\n-    return () => {\n-      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n-    };\n-  }, []);\n-\n-  useEffect(() => {\n-    const disableScroll = (event) => {\n-      if (isDrawing) {\n-        event.preventDefault();\n-      }\n-    };\n-\n-    document.addEventListener(\"touchmove\", disableScroll, { passive: false });\n-    document.addEventListener(\"wheel\", disableScroll, { passive: false });\n-\n-    return () => {\n-      document.removeEventListener(\"touchmove\", disableScroll);\n-      document.removeEventListener(\"wheel\", disableScroll);\n-    };\n-  }, [isDrawing]);\n-\n-  useEffect(() => {\n-    const handleMouseMove = (event) => {\n-      if (isResizing) {\n-        const currentY =\n-          event.clientY || (event.touches && event.touches[0].clientY);\n-        const deltaY = currentY - startY;\n-        setSvgHeight((prevHeight) => {\n-          const newHeight = Math.max(\n-            MIN_HEIGHT,\n-            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n-          );\n-          return newHeight;\n-        });\n-        setStartY(currentY);\n-      }\n-    };\n-\n-    const handleMouseUp = () => {\n-      if (isResizing) {\n-        setIsResizing(false);\n-        document.removeEventListener(\"mousemove\", handleMouseMove);\n-        document.removeEventListener(\"mouseup\", handleMouseUp);\n-        document.removeEventListener(\"touchmove\", handleMouseMove);\n-        document.removeEventListener(\"touchend\", handleMouseUp);\n-        saveHeight();\n-      }\n-    };\n-\n-    if (isResizing) {\n-      document.addEventListener(\"mousemove\", handleMouseMove);\n-      document.addEventListener(\"mouseup\", handleMouseUp);\n-      document.addEventListener(\"touchmove\", handleMouseMove);\n-      document.addEventListener(\"touchend\", handleMouseUp);\n-    }\n-\n-    return () => {\n-      document.removeEventListener(\"mousemove\", handleMouseMove);\n-      document.removeEventListener(\"mouseup\", handleMouseUp);\n-      document.removeEventListener(\"touchmove\", handleMouseMove);\n-      document.removeEventListener(\"touchend\", handleMouseUp);\n-    };\n-  }, [isResizing, startY]);\n-\n-  const getPointerCoordinates = (event) => {\n-    const svg = svgRef.current;\n-    const rect = svg.getBoundingClientRect();\n-\n-    // Get the correct pointer position, including page scroll and scale\n-    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n-    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n-\n-    // Calculate the mouse position relative to the SVG\n-    const scaleX = svg.viewBox.baseVal.width / rect.width;\n-    const scaleY = svg.viewBox.baseVal.height / rect.height;\n-\n-    const x = (clientX - rect.left) * scaleX;\n-    const y = (clientY - rect.top) * scaleY;\n-\n-    return [x, y];\n-  };\n-\n-  const startDrawing = (x, y) => {\n-    setDrawing(true);\n-    setPoints([{ x, y }]);\n-  };\n-\n-  const draw = (x, y) => {\n-    if (!drawing) return;\n-\n-    const newPoints = [...points, { x, y }];\n-    setPoints(newPoints);\n-    const newPath = lineGenerator(newPoints);\n-    setPath(newPath);\n-    if (y > svgHeight - BUFFER_ZONE) {\n-      const newHeight = svgHeight + INCREMENT_HEIGHT;\n-      setSvgHeight(newHeight);\n-      updateAttributes({ height: newHeight });\n-\n-      // Adjust scroll position to keep the drawing point in view\n-      const container = containerRef.current;\n-      if (container) {\n-        const scrollContainer = container.closest(\".drawing-component\");\n-        if (scrollContainer) {\n-          scrollContainer.scrollTo({\n-            top: scrollContainer.scrollHeight,\n-            behavior: \"smooth\",\n-          });\n-        }\n-      }\n-    }\n-  };\n-\n-  const stopDrawing = () => {\n-    if (drawing) {\n-      setDrawing(false);\n-      saveDrawing();\n-      setHistory((prevHistory) => [\n-        ...prevHistory,\n-        { id, path, color, size, tool },\n-      ]);\n-      setPath(\"\");\n-      setPoints([]);\n-    }\n-  };\n-\n-  const handleColorChange = (e) => {\n-    setColor(e.target.value);\n-  };\n-\n-  const openColorPicker = () => {\n-    colorInputRef.current.click();\n-  };\n-\n-  // Store only actions in history (add or delete)\n-  const undo = () => {\n-    if (history.length > 0) {\n-      const lastAction = history[history.length - 1];\n-      setHistory((prevHistory) => prevHistory.slice(0, -1));\n-      setRedoStack((prevStack) => [...prevStack, lastAction]);\n-\n-      if (lastAction.action === \"add\") {\n-        // Undo adding a line by removing it\n-        linesRef.current = linesRef.current.filter(\n-          (line) => line.id !== lastAction.line.id\n-        );\n-      } else if (lastAction.action === \"delete\") {\n-        // Undo deleting a line by adding it back\n-        linesRef.current = [...linesRef.current, lastAction.line];\n-      }\n-\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n-  const redo = () => {\n-    if (redoStack.length > 0) {\n-      const lastRedo = redoStack[redoStack.length - 1];\n-      setRedoStack((prevStack) => prevStack.slice(0, -1));\n-      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n-\n-      if (lastRedo.action === \"add\") {\n-        // Redo adding a line by adding it back\n-        linesRef.current = [...linesRef.current, lastRedo.line];\n-      } else if (lastRedo.action === \"delete\") {\n-        // Redo deleting a line by removing it again\n-        linesRef.current = linesRef.current.filter(\n-          (line) => line.id !== lastRedo.line.id\n-        );\n-      }\n-\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n-  const saveHeight = () => {\n-    updateAttributes({ height: svgHeight });\n-  };\n-\n-  useEffect(() => {\n-    const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n-      Keyboard.hide();\n-    });\n-\n-    return () => {\n-      showListener.remove();\n-    };\n-  }, []);\n-\n-  const pathsGroupRef = useRef(null);\n-  const activePathRef = useRef(null);\n-  const throttleRef = useRef(null);\n-  const batchUpdateTimeoutRef = useRef(null);\n-\n-  // Memoize the line generator to prevent recreation\n-  const lineGenerator = useMemo(\n-    () =>\n-      d3\n-        .line()\n-        .x((d) => d.x)\n-        .y((d) => d.y)\n-        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n-    []\n-  );\n-\n-  const smoothPoints = (points) => {\n-    if (points.length < 3) return points;\n-    return points.map((point, i, arr) => {\n-      if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n-      const prev = arr[i - 1];\n-      const next = arr[i + 1];\n-      return {\n-        x: (prev.x + point.x + next.x) / 3,\n-        y: (prev.y + point.y + next.y) / 3,\n-      };\n-    });\n-  };\n-\n-  // Batch update function for paths\n-  const batchUpdatePaths = () => {\n-    if (batchUpdateTimeoutRef.current) {\n-      clearTimeout(batchUpdateTimeoutRef.current);\n-    }\n-\n-    batchUpdateTimeoutRef.current = setTimeout(() => {\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }, 500); // Adjust timeout as needed\n-  };\n-\n-  // Throttle draw function\n-  const throttledDraw = (x, y) => {\n-    if (!throttleRef.current) {\n-      throttleRef.current = setTimeout(() => {\n-        throttleRef.current = null;\n-      }, 16); // ~60fps\n-\n-      if (!drawing) return;\n-\n-      const newPoints = [...points, { x, y }];\n-      setPoints(newPoints);\n-\n-      const newPath = lineGenerator(smoothPoints(newPoints));\n-      setPath(newPath);\n-\n-      // Update active path directly in DOM for better performance\n-      if (activePathRef.current) {\n-        activePathRef.current.setAttribute(\"d\", newPath);\n-      }\n-\n-      // Check for canvas expansion\n-      if (y > svgHeight - BUFFER_ZONE) {\n-        const newHeight = svgHeight + INCREMENT_HEIGHT;\n-        setSvgHeight(newHeight);\n-        updateAttributes({ height: newHeight });\n-      }\n-    }\n-  };\n-\n-  // Split paths into chunks for better rendering\n-  const chunkedLines = useMemo(() => {\n-    const chunkSize = 100; // Adjust based on performance needs\n-    const chunks = [];\n-    for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n-      chunks.push(linesRef.current.slice(i, i + chunkSize));\n-    }\n-    return chunks;\n-  }, [linesRef.current.length]);\n-\n-  const adjustColorForMode = (color) => {\n-    if (isDarkMode) {\n-      // Dark mode: Black turns to white; other colors unchanged\n-      return color === \"#000000\" ? \"#FFFFFF\" : color;\n-    } else {\n-      // Light mode: White turns to black; other colors unchanged\n-      return color === \"#FFFFFF\" ? \"#000000\" : color;\n-    }\n-  };\n-\n-  // Optimize path rendering\n-  const renderPaths = () =>\n-    chunkedLines.map((chunk, chunkIndex) => (\n-      <g key={`chunk-${chunkIndex}`}>\n-        {chunk.map((item) => (\n-          <path\n-            key={`${item.id}-${item.color}-${item.size}`}\n-            d={item.path}\n-            stroke={adjustColorForMode(item.color)}\n-            strokeWidth={item.size}\n-            opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n-            fill=\"none\"\n-            vectorEffect=\"non-scaling-stroke\"\n-          />\n-        ))}\n-      </g>\n-    ));\n-\n-  // Optimize save drawing function\n-  const saveDrawing = () => {\n-    if (!path) return;\n-\n-    const newLine = { id: uuid(), path, color, size, tool };\n-    linesRef.current = [...linesRef.current, newLine];\n-\n-    setHistory((prevHistory) => [\n-      ...prevHistory,\n-      { action: \"add\", line: newLine },\n-    ]);\n-\n-    setRedoStack([]);\n-    batchUpdatePaths();\n-  };\n-\n-  return (\n-    <div className=\"draw w-full min-h-screen flex flex-col\">\n-      {/* Top Toolbar */}\n-      <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n-        {/* Left side controls */}\n-        <div className=\"flex items-center space-x-2\">\n-          <button\n-            onClick={() => {\n-              setTool(\"pencil\");\n-              setColor(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n-            }}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-2 border ${\n-              tool === \"pencil\"\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n-                : \"border-gray-300 dark:border-neutral-600\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <Icons.BallPenLine className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={() => {\n-              setTool(\"highlighter\");\n-              setColor(\"#FFFF00\");\n-            }}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-2 border ${\n-              tool === \"highlighter\"\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n-                : \"border-gray-300 dark:border-neutral-600\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <Icons.MarkPenLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={() => setTool(\"erase\")}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-2 border ${\n-              tool === \"erase\"\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n-                : \"border-gray-300 dark:border-neutral-600\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <Icons.EraserLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <div className=\"relative\">\n-            <select\n-              className=\"border border-neutral-300 dark:border-neutral-600 rounded w-full p-2 text-neutral-800 bg-[#F8F8F7] dark:bg-[#2D2C2C] dark:text-[color:var(--selected-dark-text)] outline-none appearance-none mr-6\"\n-              value={background}\n-              onChange={handleBackgroundChange}\n-            >\n-              <option value=\"none\">None</option>\n-              <option value=\"grid\">Grid</option>\n-              <option value=\"ruled\">Ruled</option>\n-              <option value=\"dotted\">Dotted</option>\n-            </select>\n-            <Icons.ArrowDownSLineIcon className=\"dark:text-[color:var(--selected-dark-text)] ri-arrow-down-s-line absolute right-3 top-1/2 transform -translate-y-1/2 text-neutral-600 pointer-events-none\" />\n-          </div>\n-        </div>\n-        {/* Right side controls */}\n-        <div className=\"flex items-center space-x-2\">\n-          <button\n-            onClick={undo}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n-          >\n-            <Icons.ArrowGoBackLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={redo}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n-          >\n-            <Icons.ArrowGoForwardLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thin)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thin\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"3\"\n-              height=\"3\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.medium)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.medium\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"4\"\n-              height=\"4\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thick)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thick\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"5\"\n-              height=\"5\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thicker)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thicker\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"6\"\n-              height=\"6\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thickest)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thickest\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"7\"\n-              height=\"7\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <div className=\"relative inline-block\">\n-            {/* Hidden color input */}\n-            <input\n-              type=\"color\"\n-              value={color}\n-              onChange={handleColorChange}\n-              ref={colorInputRef}\n-              className=\"absolute inset-0 opacity-0 cursor-pointer\"\n-            />\n-            {/* Custom button */}\n-            <button\n-              onClick={openColorPicker}\n-              style={{ backgroundColor: color }}\n-              className={`flex items-center justify-center p-1 h-10 w-10 rounded-full hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-            />\n-          </div>\n-          <button\n-            onClick={onClose}\n-            className=\"p-2 rounded-full bg-gray-100 dark:bg-neutral-800 hover:bg-gray-200 dark:hover:bg-neutral-700 transition-colors\"\n-          >\n-            <Icons.CloseLineIcon className=\"w-6 h-6\" />\n-          </button>\n-        </div>\n-      </div>\n-\n-      {/* SVG Container */}\n-      <div className=\"relative flex-grow drawing-container\">\n-        <svg\n-          ref={svgRef}\n-          viewBox={`0 0 ${svgWidth} ${svgHeight}`}\n-          preserveAspectRatio=\"xMidYMid meet\"\n-          className={`w-full h-auto ${background} bg-neutral-100 dark:bg-neutral-800`}\n-        >\n-          <g ref={pathsGroupRef}>{renderPaths()}</g>\n-          {path && (\n-            <path\n-              ref={activePathRef}\n-              d={path}\n-              stroke={adjustColorForMode(color)}\n-              strokeWidth={size}\n-              opacity={tool === \"highlighter\" ? 0.3 : 1}\n-              fill=\"none\"\n-              vectorEffect=\"non-scaling-stroke\"\n-            />\n-          )}\n-        </svg>\n-      </div>\n-    </div>\n-  );\n-};\n-\n-export default DrawMode;\n"
                },
                {
                    "date": 1732138506953,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,10 +32,8 @@\n   const pointsRef = useRef([]);\n   const historyRef = useRef([]);\n   const redoStackRef = useRef([]);\n   const svgRef = useRef(null);\n-  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n-  const [size, setSize] = useState(thicknessOptions.thin);\n   const [drawing, setDrawing] = useState(false);\n   const [points, setPoints] = useState([]);\n   const [path, setPath] = useState(\"\");\n   const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n@@ -49,9 +47,9 @@\n   const colorInputRef = useRef(null);\n   const [background, setBackground] = useState(\n     node.attrs.paperType || backgroundStyles.none\n   );\n-  const { deletePath, startDrawing, draw, stopDrawing } = useDrawing({});\n+  const { deletePath, startDrawing, draw, stopDrawing, undo, redo, color, setColor, size, setSize } = useDrawing({});\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n     setBackground(newBackground);\n"
                },
                {
                    "date": 1732138531109,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n import * as d3 from \"d3\";\n import { v4 as uuid } from \"uuid\";\n import { Keyboard } from \"@capacitor/keyboard\";\n import Icons from \"../../../remixicon-react\";\n-import { useDrawing } from \"./useDrawing\";\n+import { useDrawing } from \"./drawing\";\n \n const thicknessOptions = {\n   thin: 2,\n   medium: 3,\n"
                },
                {
                    "date": 1732138546590,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,20 @@\n   const colorInputRef = useRef(null);\n   const [background, setBackground] = useState(\n     node.attrs.paperType || backgroundStyles.none\n   );\n-  const { deletePath, startDrawing, draw, stopDrawing, undo, redo, color, setColor, size, setSize } = useDrawing({});\n+  const {\n+    deletePath,\n+    startDrawing,\n+    draw,\n+    stopDrawing,\n+    undo,\n+    redo,\n+    color,\n+    setColor,\n+    size,\n+    setSize,\n+  } = useDrawing({ node: node });\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n     setBackground(newBackground);\n@@ -258,10 +269,8 @@\n \n     return [x, y];\n   };\n \n-\n-\n   const handleColorChange = (e) => {\n     setColor(e.target.value);\n   };\n \n"
                },
                {
                    "date": 1732138615853,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -291,37 +291,8 @@\n       showListener.remove();\n     };\n   }, []);\n \n-  const pathsGroupRef = useRef(null);\n-  const activePathRef = useRef(null);\n-  const throttleRef = useRef(null);\n-  const batchUpdateTimeoutRef = useRef(null);\n-\n-  // Memoize the line generator to prevent recreation\n-  const lineGenerator = useMemo(\n-    () =>\n-      d3\n-        .line()\n-        .x((d) => d.x)\n-        .y((d) => d.y)\n-        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n-    []\n-  );\n-\n-  const smoothPoints = (points) => {\n-    if (points.length < 3) return points;\n-    return points.map((point, i, arr) => {\n-      if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n-      const prev = arr[i - 1];\n-      const next = arr[i + 1];\n-      return {\n-        x: (prev.x + point.x + next.x) / 3,\n-        y: (prev.y + point.y + next.y) / 3,\n-      };\n-    });\n-  };\n-\n   // Batch update function for paths\n   const batchUpdatePaths = () => {\n     if (batchUpdateTimeoutRef.current) {\n       clearTimeout(batchUpdateTimeoutRef.current);\n"
                },
                {
                    "date": 1732138636953,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -291,70 +291,8 @@\n       showListener.remove();\n     };\n   }, []);\n \n-  // Batch update function for paths\n-  const batchUpdatePaths = () => {\n-    if (batchUpdateTimeoutRef.current) {\n-      clearTimeout(batchUpdateTimeoutRef.current);\n-    }\n-\n-    batchUpdateTimeoutRef.current = setTimeout(() => {\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }, 500); // Adjust timeout as needed\n-  };\n-\n-  // Throttle draw function\n-  const throttledDraw = (x, y) => {\n-    if (!throttleRef.current) {\n-      throttleRef.current = setTimeout(() => {\n-        throttleRef.current = null;\n-      }, 16); // ~60fps\n-\n-      if (!drawing) return;\n-\n-      const newPoints = [...points, { x, y }];\n-      setPoints(newPoints);\n-\n-      const newPath = lineGenerator(smoothPoints(newPoints));\n-      setPath(newPath);\n-\n-      // Update active path directly in DOM for better performance\n-      if (activePathRef.current) {\n-        activePathRef.current.setAttribute(\"d\", newPath);\n-      }\n-\n-      // Check for canvas expansion\n-      if (y > svgHeight - BUFFER_ZONE) {\n-        const newHeight = svgHeight + INCREMENT_HEIGHT;\n-        setSvgHeight(newHeight);\n-        updateAttributes({ height: newHeight });\n-      }\n-    }\n-  };\n-\n-  // Split paths into chunks for better rendering\n-  const chunkedLines = useMemo(() => {\n-    const chunkSize = 100; // Adjust based on performance needs\n-    const chunks = [];\n-    for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n-      chunks.push(linesRef.current.slice(i, i + chunkSize));\n-    }\n-    return chunks;\n-  }, [linesRef.current.length]);\n-\n-  const adjustColorForMode = (color) => {\n-    if (isDarkMode) {\n-      // Dark mode: Black turns to white; other colors unchanged\n-      return color === \"#000000\" ? \"#FFFFFF\" : color;\n-    } else {\n-      // Light mode: White turns to black; other colors unchanged\n-      return color === \"#FFFFFF\" ? \"#000000\" : color;\n-    }\n-  };\n-\n   // Optimize path rendering\n   const renderPaths = () =>\n     chunkedLines.map((chunk, chunkIndex) => (\n       <g key={`chunk-${chunkIndex}`}>\n"
                },
                {
                    "date": 1732138647960,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -309,24 +309,8 @@\n         ))}\n       </g>\n     ));\n \n-  // Optimize save drawing function\n-  const saveDrawing = () => {\n-    if (!path) return;\n-\n-    const newLine = { id: uuid(), path, color, size, tool };\n-    linesRef.current = [...linesRef.current, newLine];\n-\n-    setHistory((prevHistory) => [\n-      ...prevHistory,\n-      { action: \"add\", line: newLine },\n-    ]);\n-\n-    setRedoStack([]);\n-    batchUpdatePaths();\n-  };\n-\n   return (\n     <div className=\"draw w-full min-h-screen flex flex-col\">\n       {/* Top Toolbar */}\n       <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n"
                },
                {
                    "date": 1732138751652,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,8 +58,9 @@\n     color,\n     setColor,\n     size,\n     setSize,\n+    pathsGroupRef,\n   } = useDrawing({ node: node });\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n"
                },
                {
                    "date": 1732138768904,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,8 +59,9 @@\n     setColor,\n     size,\n     setSize,\n     pathsGroupRef,\n+    chunkedLines\n   } = useDrawing({ node: node });\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n"
                },
                {
                    "date": 1732138786486,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,9 +78,9 @@\n \n     const PEN_TIMEOUT_DURATION = 700;\n \n     const handlePointerEvent = (event) => {\n-      if (event.pointerType === \"pen\") {\n+      if (event.pointerType === \"pen\" || event.pointerType === \"mouse\") {\n         penActive = true;\n         clearTimeout(penTimeout);\n         event.preventDefault(); // Prevent touch interaction when pen is active\n         event.stopPropagation();\n"
                },
                {
                    "date": 1732138841474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n         event.stopPropagation();\n \n         const [x, y] = getPointerCoordinates(event);\n \n-        if (event.type === \"pointerdown\") {\n+        if (event.type === \"pointerdown\" || event.type === \"pointer\") {\n           if (tool === \"erase\") {\n             isErasing = true;\n             eraseOverlappingPaths(x, y);\n           } else {\n"
                },
                {
                    "date": 1732138849611,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,17 +78,17 @@\n \n     const PEN_TIMEOUT_DURATION = 700;\n \n     const handlePointerEvent = (event) => {\n-      if (event.pointerType === \"pen\" || event.pointerType === \"mouse\") {\n+      if (event.pointerType === \"pen\") {\n         penActive = true;\n         clearTimeout(penTimeout);\n         event.preventDefault(); // Prevent touch interaction when pen is active\n         event.stopPropagation();\n \n         const [x, y] = getPointerCoordinates(event);\n \n-        if (event.type === \"pointerdown\" || event.type === \"pointer\") {\n+        if (event.type === \"pointerdown\") {\n           if (tool === \"erase\") {\n             isErasing = true;\n             eraseOverlappingPaths(x, y);\n           } else {\n"
                },
                {
                    "date": 1732138985397,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,10 @@\n     setColor,\n     size,\n     setSize,\n     pathsGroupRef,\n-    chunkedLines\n+    chunkedLines,\n+    adjustColorForMode\n   } = useDrawing({ node: node });\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n"
                },
                {
                    "date": 1732139210735,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,78 +1,59 @@\n-import React, { useState, useRef, useEffect, useMemo } from \"react\";\n-import * as d3 from \"d3\";\n-import { v4 as uuid } from \"uuid\";\n+import React, { useRef, useEffect } from \"react\";\n import { Keyboard } from \"@capacitor/keyboard\";\n import Icons from \"../../../remixicon-react\";\n-import { useDrawing } from \"./drawing\";\n+import { useDrawing, thicknessOptions, backgroundStyles } from \"./useDrawing\";\n \n-const thicknessOptions = {\n-  thin: 2,\n-  medium: 3,\n-  thick: 4,\n-  thicker: 5,\n-  thickest: 6,\n-};\n-\n-const backgroundStyles = {\n-  none: \"\",\n-  grid: \"grid\",\n-  ruled: \"ruled\",\n-  dotted: \"dotted\",\n-};\n-\n-const BUFFER_ZONE = 50;\n-const INCREMENT_HEIGHT = 200;\n-const PREVIEW_HEIGHT = 500;\n-\n const DrawMode = ({ onClose, updateAttributes, node }) => {\n-  const isDarkMode = document.documentElement.classList.contains(\"dark\");\n-  const [isDrawing, setIsDrawing] = useState(false);\n-  const [drawingPath, setDrawingPath] = useState(\"\");\n-  const [lines, setLines] = useState([]);\n-  const pointsRef = useRef([]);\n-  const historyRef = useRef([]);\n-  const redoStackRef = useRef([]);\n-  const svgRef = useRef(null);\n-  const [drawing, setDrawing] = useState(false);\n-  const [points, setPoints] = useState([]);\n-  const [path, setPath] = useState(\"\");\n-  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n-  const [svgWidth] = useState(500);\n-  const [tool, setTool] = useState(\"pencil\");\n-  const [history, setHistory] = useState([]);\n-  const [redoStack, setRedoStack] = useState([]);\n-  const [isResizing, setIsResizing] = useState(false);\n-  const [startY, setStartY] = useState(0);\n-  const [id] = useState(() => node.attrs.id || uuid());\n   const colorInputRef = useRef(null);\n-  const [background, setBackground] = useState(\n-    node.attrs.paperType || backgroundStyles.none\n-  );\n+\n   const {\n-    deletePath,\n+    drawing,\n+    path,\n+    svgHeight,\n+    tool,\n+    color,\n+    size,\n+    background,\n+    svgRef,\n+    linesRef,\n+    pathsGroupRef,\n+    activePathRef,\n+    setTool,\n+    setColor,\n+    setSize,\n+    setBackground,\n     startDrawing,\n     draw,\n     stopDrawing,\n     undo,\n     redo,\n-    color,\n-    setColor,\n-    size,\n-    setSize,\n-    pathsGroupRef,\n-    chunkedLines,\n-    adjustColorForMode\n-  } = useDrawing({ node: node });\n+    deletePath,\n+    getPointerCoordinates,\n+    adjustColorForMode,\n+  } = useDrawing({\n+    initialHeight: node.attrs.height || 400,\n+    initialLines: node.attrs.lines || [],\n+    onUpdateAttributes: updateAttributes,\n+  });\n \n-  const handleBackgroundChange = (event) => {\n-    const newBackground = event.target.value;\n-    setBackground(newBackground);\n-    updateAttributes({ paperType: newBackground });\n-  };\n+  const svgWidth = 500;\n+  const isDarkMode = document.documentElement.classList.contains(\"dark\");\n \n   useEffect(() => {\n-    const svg = d3.select(svgRef.current);\n+    const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n+      Keyboard.hide();\n+    });\n+\n+    return () => {\n+      showListener.remove();\n+    };\n+  }, []);\n+\n+  useEffect(() => {\n+    const svg = svgRef.current;\n+    if (!svg) return; // Exit if ref is not set\n+\n     const eraseRadius = 5;\n     let isErasing = false;\n     let penActive = false;\n     let penTimeout = null;\n@@ -82,9 +63,9 @@\n     const handlePointerEvent = (event) => {\n       if (event.pointerType === \"pen\") {\n         penActive = true;\n         clearTimeout(penTimeout);\n-        event.preventDefault(); // Prevent touch interaction when pen is active\n+        event.preventDefault();\n         event.stopPropagation();\n \n         const [x, y] = getPointerCoordinates(event);\n \n@@ -122,11 +103,9 @@\n         width: eraseRadius * 2,\n         height: eraseRadius * 2,\n       };\n \n-      svg.selectAll(\"path\").each(function () {\n-        const path = d3.select(this);\n-        const pathNode = path.node();\n+      svg.querySelectorAll(\"path\").forEach((pathNode) => {\n         const pathBBox = pathNode.getBBox();\n \n         if (\n           pathBBox.x < eraserArea.x + eraserArea.width &&\n@@ -138,23 +117,18 @@\n         }\n       });\n     };\n \n-    // Prevent scrolling when the pencil (pen) is active\n     const preventScrolling = (event) => {\n       if (penActive) {\n-        event.preventDefault(); // Prevent scrolling\n+        event.preventDefault();\n         event.stopPropagation();\n       }\n     };\n \n-    // Attach pen input handlers on SVG\n-    svg\n-      .on(\"pointerdown\", handlePointerEvent)\n-      .on(\"pointermove\", handlePointerEvent)\n-      .on(\"pointerup\", handlePointerEvent);\n-\n-    // Block touch interactions (scrolling) when pen is active\n+    svg.addEventListener(\"pointerdown\", handlePointerEvent);\n+    svg.addEventListener(\"pointermove\", handlePointerEvent);\n+    svg.addEventListener(\"pointerup\", handlePointerEvent);\n     document.body.addEventListener(\"touchstart\", preventScrolling, {\n       passive: false,\n     });\n     document.body.addEventListener(\"touchmove\", preventScrolling, {\n@@ -163,140 +137,49 @@\n     document.body.addEventListener(\"touchend\", preventScrolling, {\n       passive: false,\n     });\n \n-    // Suppress context menu (e.g., copy/paste menu) on pen input\n-    svg.on(\"contextmenu\", (event) => {\n-      if (penActive) {\n-        event.preventDefault();\n-      }\n-    });\n-\n-    // Cleanup on component unmount\n     return () => {\n       clearTimeout(penTimeout);\n+      svg.removeEventListener(\"pointerdown\", handlePointerEvent);\n+      svg.removeEventListener(\"pointermove\", handlePointerEvent);\n+      svg.removeEventListener(\"pointerup\", handlePointerEvent);\n       document.body.removeEventListener(\"touchstart\", preventScrolling);\n       document.body.removeEventListener(\"touchmove\", preventScrolling);\n       document.body.removeEventListener(\"touchend\", preventScrolling);\n     };\n-  }, [tool, color, size, points]);\n+  }, [\n+    tool,\n+    deletePath,\n+    draw,\n+    startDrawing,\n+    stopDrawing,\n+    getPointerCoordinates,\n+  ]);\n \n-  const handleMouseDown = (event) => {\n-    event.preventDefault();\n+  const handleBackgroundChange = (event) => {\n+    const newBackground = event.target.value;\n+    setBackground(newBackground);\n+    updateAttributes({ paperType: newBackground });\n   };\n \n-  useEffect(() => {\n-    const svg = svgRef.current;\n-\n-    const preventContextMenu = (event) => event.preventDefault();\n-\n-    svg.addEventListener(\"contextmenu\", preventContextMenu);\n-\n-    return () => {\n-      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n-    };\n-  }, []);\n-\n-  useEffect(() => {\n-    const disableScroll = (event) => {\n-      if (isDrawing) {\n-        event.preventDefault();\n-      }\n-    };\n-\n-    document.addEventListener(\"touchmove\", disableScroll, { passive: false });\n-    document.addEventListener(\"wheel\", disableScroll, { passive: false });\n-\n-    return () => {\n-      document.removeEventListener(\"touchmove\", disableScroll);\n-      document.removeEventListener(\"wheel\", disableScroll);\n-    };\n-  }, [isDrawing]);\n-\n-  useEffect(() => {\n-    const handleMouseMove = (event) => {\n-      if (isResizing) {\n-        const currentY =\n-          event.clientY || (event.touches && event.touches[0].clientY);\n-        const deltaY = currentY - startY;\n-        setSvgHeight((prevHeight) => {\n-          const newHeight = Math.max(\n-            MIN_HEIGHT,\n-            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n-          );\n-          return newHeight;\n-        });\n-        setStartY(currentY);\n-      }\n-    };\n-\n-    const handleMouseUp = () => {\n-      if (isResizing) {\n-        setIsResizing(false);\n-        document.removeEventListener(\"mousemove\", handleMouseMove);\n-        document.removeEventListener(\"mouseup\", handleMouseUp);\n-        document.removeEventListener(\"touchmove\", handleMouseMove);\n-        document.removeEventListener(\"touchend\", handleMouseUp);\n-        saveHeight();\n-      }\n-    };\n-\n-    if (isResizing) {\n-      document.addEventListener(\"mousemove\", handleMouseMove);\n-      document.addEventListener(\"mouseup\", handleMouseUp);\n-      document.addEventListener(\"touchmove\", handleMouseMove);\n-      document.addEventListener(\"touchend\", handleMouseUp);\n-    }\n-\n-    return () => {\n-      document.removeEventListener(\"mousemove\", handleMouseMove);\n-      document.removeEventListener(\"mouseup\", handleMouseUp);\n-      document.removeEventListener(\"touchmove\", handleMouseMove);\n-      document.removeEventListener(\"touchend\", handleMouseUp);\n-    };\n-  }, [isResizing, startY]);\n-\n-  const getPointerCoordinates = (event) => {\n-    const svg = svgRef.current;\n-    const rect = svg.getBoundingClientRect();\n-\n-    // Get the correct pointer position, including page scroll and scale\n-    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n-    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n-\n-    // Calculate the mouse position relative to the SVG\n-    const scaleX = svg.viewBox.baseVal.width / rect.width;\n-    const scaleY = svg.viewBox.baseVal.height / rect.height;\n-\n-    const x = (clientX - rect.left) * scaleX;\n-    const y = (clientY - rect.top) * scaleY;\n-\n-    return [x, y];\n-  };\n-\n   const handleColorChange = (e) => {\n     setColor(e.target.value);\n   };\n \n   const openColorPicker = () => {\n     colorInputRef.current.click();\n   };\n \n-  const saveHeight = () => {\n-    updateAttributes({ height: svgHeight });\n-  };\n+  const chunkedLines = React.useMemo(() => {\n+    const chunkSize = 100;\n+    const chunks = [];\n+    for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n+      chunks.push(linesRef.current.slice(i, i + chunkSize));\n+    }\n+    return chunks;\n+  }, [linesRef.current.length]);\n \n-  useEffect(() => {\n-    const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n-      Keyboard.hide();\n-    });\n-\n-    return () => {\n-      showListener.remove();\n-    };\n-  }, []);\n-\n-  // Optimize path rendering\n   const renderPaths = () =>\n     chunkedLines.map((chunk, chunkIndex) => (\n       <g key={`chunk-${chunkIndex}`}>\n         {chunk.map((item) => (\n@@ -312,8 +195,9 @@\n         ))}\n       </g>\n     ));\n \n+  // Rest of your JSX remains the same, just update the references to use the hook's values and methods\n   return (\n     <div className=\"draw w-full min-h-screen flex flex-col\">\n       {/* Top Toolbar */}\n       <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n"
                },
                {
                    "date": 1732139303906,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,59 +1,66 @@\n-import React, { useRef, useEffect } from \"react\";\n+import React, { useState, useRef, useEffect, useMemo } from \"react\";\n+import * as d3 from \"d3\";\n+import { v4 as uuid } from \"uuid\";\n import { Keyboard } from \"@capacitor/keyboard\";\n import Icons from \"../../../remixicon-react\";\n-import { useDrawing, thicknessOptions, backgroundStyles } from \"./useDrawing\";\n \n-const DrawMode = ({ onClose, updateAttributes, node }) => {\n-  const colorInputRef = useRef(null);\n+const thicknessOptions = {\n+  thin: 2,\n+  medium: 3,\n+  thick: 4,\n+  thicker: 5,\n+  thickest: 6,\n+};\n \n-  const {\n-    drawing,\n-    path,\n-    svgHeight,\n-    tool,\n-    color,\n-    size,\n-    background,\n-    svgRef,\n-    linesRef,\n-    pathsGroupRef,\n-    activePathRef,\n-    setTool,\n-    setColor,\n-    setSize,\n-    setBackground,\n-    startDrawing,\n-    draw,\n-    stopDrawing,\n-    undo,\n-    redo,\n-    deletePath,\n-    getPointerCoordinates,\n-    adjustColorForMode,\n-  } = useDrawing({\n-    initialHeight: node.attrs.height || 400,\n-    initialLines: node.attrs.lines || [],\n-    onUpdateAttributes: updateAttributes,\n-  });\n+const backgroundStyles = {\n+  none: \"\",\n+  grid: \"grid\",\n+  ruled: \"ruled\",\n+  dotted: \"dotted\",\n+};\n \n-  const svgWidth = 500;\n+const BUFFER_ZONE = 50;\n+const INCREMENT_HEIGHT = 200;\n+const PREVIEW_HEIGHT = 500;\n+\n+const DrawMode = ({ onClose, updateAttributes, node }) => {\n   const isDarkMode = document.documentElement.classList.contains(\"dark\");\n+  const [isDrawing, setIsDrawing] = useState(false);\n+  const [drawingPath, setDrawingPath] = useState(\"\");\n+  const [lines, setLines] = useState([]);\n+  const pointsRef = useRef([]);\n+  const historyRef = useRef([]);\n+  const redoStackRef = useRef([]);\n+  const svgRef = useRef(null);\n+  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n+  const [size, setSize] = useState(thicknessOptions.thin);\n+  const [drawing, setDrawing] = useState(false);\n+  const [points, setPoints] = useState([]);\n+  const [path, setPath] = useState(\"\");\n+  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n+  const [svgWidth] = useState(500);\n+  const [tool, setTool] = useState(\"pencil\");\n+  const [history, setHistory] = useState([]);\n+  const [redoStack, setRedoStack] = useState([]);\n+  const [isResizing, setIsResizing] = useState(false);\n+  const [startY, setStartY] = useState(0);\n+  const [id] = useState(() => node.attrs.id || uuid());\n+  const colorInputRef = useRef(null);\n+  const [background, setBackground] = useState(\n+    node.attrs.paperType || backgroundStyles.none\n+  );\n \n-  useEffect(() => {\n-    const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n-      Keyboard.hide();\n-    });\n+  const linesRef = useRef(node.attrs.lines || []);\n \n-    return () => {\n-      showListener.remove();\n-    };\n-  }, []);\n+  const handleBackgroundChange = (event) => {\n+    const newBackground = event.target.value;\n+    setBackground(newBackground);\n+    updateAttributes({ paperType: newBackground });\n+  };\n \n   useEffect(() => {\n-    const svg = svgRef.current;\n-    if (!svg) return; // Exit if ref is not set\n-\n+    const svg = d3.select(svgRef.current);\n     const eraseRadius = 5;\n     let isErasing = false;\n     let penActive = false;\n     let penTimeout = null;\n@@ -63,9 +70,9 @@\n     const handlePointerEvent = (event) => {\n       if (event.pointerType === \"pen\") {\n         penActive = true;\n         clearTimeout(penTimeout);\n-        event.preventDefault();\n+        event.preventDefault(); // Prevent touch interaction when pen is active\n         event.stopPropagation();\n \n         const [x, y] = getPointerCoordinates(event);\n \n@@ -103,9 +110,11 @@\n         width: eraseRadius * 2,\n         height: eraseRadius * 2,\n       };\n \n-      svg.querySelectorAll(\"path\").forEach((pathNode) => {\n+      svg.selectAll(\"path\").each(function () {\n+        const path = d3.select(this);\n+        const pathNode = path.node();\n         const pathBBox = pathNode.getBBox();\n \n         if (\n           pathBBox.x < eraserArea.x + eraserArea.width &&\n@@ -117,18 +126,23 @@\n         }\n       });\n     };\n \n+    // Prevent scrolling when the pencil (pen) is active\n     const preventScrolling = (event) => {\n       if (penActive) {\n-        event.preventDefault();\n+        event.preventDefault(); // Prevent scrolling\n         event.stopPropagation();\n       }\n     };\n \n-    svg.addEventListener(\"pointerdown\", handlePointerEvent);\n-    svg.addEventListener(\"pointermove\", handlePointerEvent);\n-    svg.addEventListener(\"pointerup\", handlePointerEvent);\n+    // Attach pen input handlers on SVG\n+    svg\n+      .on(\"pointerdown\", handlePointerEvent)\n+      .on(\"pointermove\", handlePointerEvent)\n+      .on(\"pointerup\", handlePointerEvent);\n+\n+    // Block touch interactions (scrolling) when pen is active\n     document.body.addEventListener(\"touchstart\", preventScrolling, {\n       passive: false,\n     });\n     document.body.addEventListener(\"touchmove\", preventScrolling, {\n@@ -137,49 +151,335 @@\n     document.body.addEventListener(\"touchend\", preventScrolling, {\n       passive: false,\n     });\n \n+    // Cleanup on component unmount\n     return () => {\n       clearTimeout(penTimeout);\n-      svg.removeEventListener(\"pointerdown\", handlePointerEvent);\n-      svg.removeEventListener(\"pointermove\", handlePointerEvent);\n-      svg.removeEventListener(\"pointerup\", handlePointerEvent);\n       document.body.removeEventListener(\"touchstart\", preventScrolling);\n       document.body.removeEventListener(\"touchmove\", preventScrolling);\n       document.body.removeEventListener(\"touchend\", preventScrolling);\n     };\n-  }, [\n-    tool,\n-    deletePath,\n-    draw,\n-    startDrawing,\n-    stopDrawing,\n-    getPointerCoordinates,\n-  ]);\n+  }, [tool, color, size, points]);\n \n-  const handleBackgroundChange = (event) => {\n-    const newBackground = event.target.value;\n-    setBackground(newBackground);\n-    updateAttributes({ paperType: newBackground });\n+  const deletePath = (pathElement) => {\n+    const clickedPathData = pathElement.getAttribute(\"d\");\n+    const pathIndex = linesRef.current.findIndex(\n+      (line) => line.path === clickedPathData\n+    );\n+\n+    if (pathIndex !== -1) {\n+      const removedLine = linesRef.current[pathIndex];\n+\n+      // Save the deletion action\n+      setHistory((prevHistory) => [\n+        ...prevHistory,\n+        { action: \"delete\", line: removedLine },\n+      ]);\n+\n+      linesRef.current.splice(pathIndex, 1);\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n   };\n \n+  const handleMouseDown = (event) => {\n+    event.preventDefault();\n+  };\n+\n+  useEffect(() => {\n+    const svg = svgRef.current;\n+\n+    const preventContextMenu = (event) => event.preventDefault();\n+\n+    svg.addEventListener(\"contextmenu\", preventContextMenu);\n+\n+    return () => {\n+      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n+    };\n+  }, []);\n+\n+  useEffect(() => {\n+    const disableScroll = (event) => {\n+      if (isDrawing) {\n+        event.preventDefault();\n+      }\n+    };\n+\n+    document.addEventListener(\"touchmove\", disableScroll, { passive: false });\n+    document.addEventListener(\"wheel\", disableScroll, { passive: false });\n+\n+    return () => {\n+      document.removeEventListener(\"touchmove\", disableScroll);\n+      document.removeEventListener(\"wheel\", disableScroll);\n+    };\n+  }, [isDrawing]);\n+\n+  useEffect(() => {\n+    const handleMouseMove = (event) => {\n+      if (isResizing) {\n+        const currentY =\n+          event.clientY || (event.touches && event.touches[0].clientY);\n+        const deltaY = currentY - startY;\n+        setSvgHeight((prevHeight) => {\n+          const newHeight = Math.max(\n+            MIN_HEIGHT,\n+            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n+          );\n+          return newHeight;\n+        });\n+        setStartY(currentY);\n+      }\n+    };\n+\n+    const handleMouseUp = () => {\n+      if (isResizing) {\n+        setIsResizing(false);\n+        document.removeEventListener(\"mousemove\", handleMouseMove);\n+        document.removeEventListener(\"mouseup\", handleMouseUp);\n+        document.removeEventListener(\"touchmove\", handleMouseMove);\n+        document.removeEventListener(\"touchend\", handleMouseUp);\n+        saveHeight();\n+      }\n+    };\n+\n+    if (isResizing) {\n+      document.addEventListener(\"mousemove\", handleMouseMove);\n+      document.addEventListener(\"mouseup\", handleMouseUp);\n+      document.addEventListener(\"touchmove\", handleMouseMove);\n+      document.addEventListener(\"touchend\", handleMouseUp);\n+    }\n+\n+    return () => {\n+      document.removeEventListener(\"mousemove\", handleMouseMove);\n+      document.removeEventListener(\"mouseup\", handleMouseUp);\n+      document.removeEventListener(\"touchmove\", handleMouseMove);\n+      document.removeEventListener(\"touchend\", handleMouseUp);\n+    };\n+  }, [isResizing, startY]);\n+\n+  const getPointerCoordinates = (event) => {\n+    const svg = svgRef.current;\n+    const rect = svg.getBoundingClientRect();\n+\n+    // Get the correct pointer position, including page scroll and scale\n+    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n+    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n+\n+    // Calculate the mouse position relative to the SVG\n+    const scaleX = svg.viewBox.baseVal.width / rect.width;\n+    const scaleY = svg.viewBox.baseVal.height / rect.height;\n+\n+    const x = (clientX - rect.left) * scaleX;\n+    const y = (clientY - rect.top) * scaleY;\n+\n+    return [x, y];\n+  };\n+\n+  const startDrawing = (x, y) => {\n+    setDrawing(true);\n+    setPoints([{ x, y }]);\n+  };\n+\n+  const draw = (x, y) => {\n+    if (!drawing) return;\n+\n+    const newPoints = [...points, { x, y }];\n+    setPoints(newPoints);\n+    const newPath = lineGenerator(newPoints);\n+    setPath(newPath);\n+    if (y > svgHeight - BUFFER_ZONE) {\n+      const newHeight = svgHeight + INCREMENT_HEIGHT;\n+      setSvgHeight(newHeight);\n+      updateAttributes({ height: newHeight });\n+\n+      // Adjust scroll position to keep the drawing point in view\n+      const container = containerRef.current;\n+      if (container) {\n+        const scrollContainer = container.closest(\".drawing-component\");\n+        if (scrollContainer) {\n+          scrollContainer.scrollTo({\n+            top: scrollContainer.scrollHeight,\n+            behavior: \"smooth\",\n+          });\n+        }\n+      }\n+    }\n+  };\n+\n+  const stopDrawing = () => {\n+    if (drawing) {\n+      setDrawing(false);\n+      saveDrawing();\n+      setHistory((prevHistory) => [\n+        ...prevHistory,\n+        { id, path, color, size, tool },\n+      ]);\n+      setPath(\"\");\n+      setPoints([]);\n+    }\n+  };\n+\n   const handleColorChange = (e) => {\n     setColor(e.target.value);\n   };\n \n   const openColorPicker = () => {\n     colorInputRef.current.click();\n   };\n \n-  const chunkedLines = React.useMemo(() => {\n-    const chunkSize = 100;\n+  // Store only actions in history (add or delete)\n+  const undo = () => {\n+    if (history.length > 0) {\n+      const lastAction = history[history.length - 1];\n+      setHistory((prevHistory) => prevHistory.slice(0, -1));\n+      setRedoStack((prevStack) => [...prevStack, lastAction]);\n+\n+      if (lastAction.action === \"add\") {\n+        // Undo adding a line by removing it\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastAction.line.id\n+        );\n+      } else if (lastAction.action === \"delete\") {\n+        // Undo deleting a line by adding it back\n+        linesRef.current = [...linesRef.current, lastAction.line];\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const redo = () => {\n+    if (redoStack.length > 0) {\n+      const lastRedo = redoStack[redoStack.length - 1];\n+      setRedoStack((prevStack) => prevStack.slice(0, -1));\n+      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n+\n+      if (lastRedo.action === \"add\") {\n+        // Redo adding a line by adding it back\n+        linesRef.current = [...linesRef.current, lastRedo.line];\n+      } else if (lastRedo.action === \"delete\") {\n+        // Redo deleting a line by removing it again\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastRedo.line.id\n+        );\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const saveHeight = () => {\n+    updateAttributes({ height: svgHeight });\n+  };\n+\n+  useEffect(() => {\n+    const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n+      Keyboard.hide();\n+    });\n+\n+    return () => {\n+      showListener.remove();\n+    };\n+  }, []);\n+\n+  const pathsGroupRef = useRef(null);\n+  const activePathRef = useRef(null);\n+  const throttleRef = useRef(null);\n+  const batchUpdateTimeoutRef = useRef(null);\n+\n+  // Memoize the line generator to prevent recreation\n+  const lineGenerator = useMemo(\n+    () =>\n+      d3\n+        .line()\n+        .x((d) => d.x)\n+        .y((d) => d.y)\n+        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n+    []\n+  );\n+\n+  const smoothPoints = (points) => {\n+    if (points.length < 3) return points;\n+    return points.map((point, i, arr) => {\n+      if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n+      const prev = arr[i - 1];\n+      const next = arr[i + 1];\n+      return {\n+        x: (prev.x + point.x + next.x) / 3,\n+        y: (prev.y + point.y + next.y) / 3,\n+      };\n+    });\n+  };\n+\n+  // Batch update function for paths\n+  const batchUpdatePaths = () => {\n+    if (batchUpdateTimeoutRef.current) {\n+      clearTimeout(batchUpdateTimeoutRef.current);\n+    }\n+\n+    batchUpdateTimeoutRef.current = setTimeout(() => {\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }, 500); // Adjust timeout as needed\n+  };\n+\n+  // Throttle draw function\n+  const throttledDraw = (x, y) => {\n+    if (!throttleRef.current) {\n+      throttleRef.current = setTimeout(() => {\n+        throttleRef.current = null;\n+      }, 16); // ~60fps\n+\n+      if (!drawing) return;\n+\n+      const newPoints = [...points, { x, y }];\n+      setPoints(newPoints);\n+\n+      const newPath = lineGenerator(smoothPoints(newPoints));\n+      setPath(newPath);\n+\n+      // Update active path directly in DOM for better performance\n+      if (activePathRef.current) {\n+        activePathRef.current.setAttribute(\"d\", newPath);\n+      }\n+\n+      // Check for canvas expansion\n+      if (y > svgHeight - BUFFER_ZONE) {\n+        const newHeight = svgHeight + INCREMENT_HEIGHT;\n+        setSvgHeight(newHeight);\n+        updateAttributes({ height: newHeight });\n+      }\n+    }\n+  };\n+\n+  // Split paths into chunks for better rendering\n+  const chunkedLines = useMemo(() => {\n+    const chunkSize = 100; // Adjust based on performance needs\n     const chunks = [];\n     for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n       chunks.push(linesRef.current.slice(i, i + chunkSize));\n     }\n     return chunks;\n   }, [linesRef.current.length]);\n \n+  const adjustColorForMode = (color) => {\n+    if (isDarkMode) {\n+      // Dark mode: Black turns to white; other colors unchanged\n+      return color === \"#000000\" ? \"#FFFFFF\" : color;\n+    } else {\n+      // Light mode: White turns to black; other colors unchanged\n+      return color === \"#FFFFFF\" ? \"#000000\" : color;\n+    }\n+  };\n+\n+  // Optimize path rendering\n   const renderPaths = () =>\n     chunkedLines.map((chunk, chunkIndex) => (\n       <g key={`chunk-${chunkIndex}`}>\n         {chunk.map((item) => (\n@@ -195,9 +495,24 @@\n         ))}\n       </g>\n     ));\n \n-  // Rest of your JSX remains the same, just update the references to use the hook's values and methods\n+  // Optimize save drawing function\n+  const saveDrawing = () => {\n+    if (!path) return;\n+\n+    const newLine = { id: uuid(), path, color, size, tool };\n+    linesRef.current = [...linesRef.current, newLine];\n+\n+    setHistory((prevHistory) => [\n+      ...prevHistory,\n+      { action: \"add\", line: newLine },\n+    ]);\n+\n+    setRedoStack([]);\n+    batchUpdatePaths();\n+  };\n+\n   return (\n     <div className=\"draw w-full min-h-screen flex flex-col\">\n       {/* Top Toolbar */}\n       <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n"
                },
                {
                    "date": 1732139309099,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,9 +140,8 @@\n       .on(\"pointerdown\", handlePointerEvent)\n       .on(\"pointermove\", handlePointerEvent)\n       .on(\"pointerup\", handlePointerEvent);\n \n-    // Block touch interactions (scrolling) when pen is active\n     document.body.addEventListener(\"touchstart\", preventScrolling, {\n       passive: false,\n     });\n     document.body.addEventListener(\"touchmove\", preventScrolling, {\n@@ -151,9 +150,8 @@\n     document.body.addEventListener(\"touchend\", preventScrolling, {\n       passive: false,\n     });\n \n-    // Cleanup on component unmount\n     return () => {\n       clearTimeout(penTimeout);\n       document.body.removeEventListener(\"touchstart\", preventScrolling);\n       document.body.removeEventListener(\"touchmove\", preventScrolling);\n"
                },
                {
                    "date": 1732139315052,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,17 +126,15 @@\n         }\n       });\n     };\n \n-    // Prevent scrolling when the pencil (pen) is active\n     const preventScrolling = (event) => {\n       if (penActive) {\n-        event.preventDefault(); // Prevent scrolling\n+        event.preventDefault();\n         event.stopPropagation();\n       }\n     };\n \n-    // Attach pen input handlers on SVG\n     svg\n       .on(\"pointerdown\", handlePointerEvent)\n       .on(\"pointermove\", handlePointerEvent)\n       .on(\"pointerup\", handlePointerEvent);\n"
                },
                {
                    "date": 1732139321196,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,9 +70,9 @@\n     const handlePointerEvent = (event) => {\n       if (event.pointerType === \"pen\") {\n         penActive = true;\n         clearTimeout(penTimeout);\n-        event.preventDefault(); // Prevent touch interaction when pen is active\n+        event.preventDefault();\n         event.stopPropagation();\n \n         const [x, y] = getPointerCoordinates(event);\n \n"
                },
                {
                    "date": 1732139329364,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -183,20 +183,8 @@\n     event.preventDefault();\n   };\n \n   useEffect(() => {\n-    const svg = svgRef.current;\n-\n-    const preventContextMenu = (event) => event.preventDefault();\n-\n-    svg.addEventListener(\"contextmenu\", preventContextMenu);\n-\n-    return () => {\n-      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n-    };\n-  }, []);\n-\n-  useEffect(() => {\n     const disableScroll = (event) => {\n       if (isDrawing) {\n         event.preventDefault();\n       }\n"
                },
                {
                    "date": 1732139344283,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -182,41 +182,8 @@\n   const handleMouseDown = (event) => {\n     event.preventDefault();\n   };\n \n-  useEffect(() => {\n-    const disableScroll = (event) => {\n-      if (isDrawing) {\n-        event.preventDefault();\n-      }\n-    };\n-\n-    document.addEventListener(\"touchmove\", disableScroll, { passive: false });\n-    document.addEventListener(\"wheel\", disableScroll, { passive: false });\n-\n-    return () => {\n-      document.removeEventListener(\"touchmove\", disableScroll);\n-      document.removeEventListener(\"wheel\", disableScroll);\n-    };\n-  }, [isDrawing]);\n-\n-  useEffect(() => {\n-    const handleMouseMove = (event) => {\n-      if (isResizing) {\n-        const currentY =\n-          event.clientY || (event.touches && event.touches[0].clientY);\n-        const deltaY = currentY - startY;\n-        setSvgHeight((prevHeight) => {\n-          const newHeight = Math.max(\n-            MIN_HEIGHT,\n-            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n-          );\n-          return newHeight;\n-        });\n-        setStartY(currentY);\n-      }\n-    };\n-\n     const handleMouseUp = () => {\n       if (isResizing) {\n         setIsResizing(false);\n         document.removeEventListener(\"mousemove\", handleMouseMove);\n"
                },
                {
                    "date": 1732139352704,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -182,34 +182,8 @@\n   const handleMouseDown = (event) => {\n     event.preventDefault();\n   };\n \n-    const handleMouseUp = () => {\n-      if (isResizing) {\n-        setIsResizing(false);\n-        document.removeEventListener(\"mousemove\", handleMouseMove);\n-        document.removeEventListener(\"mouseup\", handleMouseUp);\n-        document.removeEventListener(\"touchmove\", handleMouseMove);\n-        document.removeEventListener(\"touchend\", handleMouseUp);\n-        saveHeight();\n-      }\n-    };\n-\n-    if (isResizing) {\n-      document.addEventListener(\"mousemove\", handleMouseMove);\n-      document.addEventListener(\"mouseup\", handleMouseUp);\n-      document.addEventListener(\"touchmove\", handleMouseMove);\n-      document.addEventListener(\"touchend\", handleMouseUp);\n-    }\n-\n-    return () => {\n-      document.removeEventListener(\"mousemove\", handleMouseMove);\n-      document.removeEventListener(\"mouseup\", handleMouseUp);\n-      document.removeEventListener(\"touchmove\", handleMouseMove);\n-      document.removeEventListener(\"touchend\", handleMouseUp);\n-    };\n-  }, [isResizing, startY]);\n-\n   const getPointerCoordinates = (event) => {\n     const svg = svgRef.current;\n     const rect = svg.getBoundingClientRect();\n \n"
                },
                {
                    "date": 1732139585991,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -182,8 +182,79 @@\n   const handleMouseDown = (event) => {\n     event.preventDefault();\n   };\n \n+  useEffect(() => {\n+    const svg = svgRef.current;\n+\n+    const preventContextMenu = (event) => event.preventDefault();\n+\n+    svg.addEventListener(\"contextmenu\", preventContextMenu);\n+\n+    return () => {\n+      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n+    };\n+  }, []);\n+\n+  useEffect(() => {\n+    const disableScroll = (event) => {\n+      if (isDrawing) {\n+        event.preventDefault();\n+      }\n+    };\n+\n+    document.addEventListener(\"touchmove\", disableScroll, { passive: false });\n+    document.addEventListener(\"wheel\", disableScroll, { passive: false });\n+\n+    return () => {\n+      document.removeEventListener(\"touchmove\", disableScroll);\n+      document.removeEventListener(\"wheel\", disableScroll);\n+    };\n+  }, [isDrawing]);\n+\n+  useEffect(() => {\n+    const handleMouseMove = (event) => {\n+      if (isResizing) {\n+        const currentY =\n+          event.clientY || (event.touches && event.touches[0].clientY);\n+        const deltaY = currentY - startY;\n+        setSvgHeight((prevHeight) => {\n+          const newHeight = Math.max(\n+            MIN_HEIGHT,\n+            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n+          );\n+          return newHeight;\n+        });\n+        setStartY(currentY);\n+      }\n+    };\n+\n+    const handleMouseUp = () => {\n+      if (isResizing) {\n+        setIsResizing(false);\n+        document.removeEventListener(\"mousemove\", handleMouseMove);\n+        document.removeEventListener(\"mouseup\", handleMouseUp);\n+        document.removeEventListener(\"touchmove\", handleMouseMove);\n+        document.removeEventListener(\"touchend\", handleMouseUp);\n+        saveHeight();\n+      }\n+    };\n+\n+    if (isResizing) {\n+      document.addEventListener(\"mousemove\", handleMouseMove);\n+      document.addEventListener(\"mouseup\", handleMouseUp);\n+      document.addEventListener(\"touchmove\", handleMouseMove);\n+      document.addEventListener(\"touchend\", handleMouseUp);\n+    }\n+\n+    return () => {\n+      document.removeEventListener(\"mousemove\", handleMouseMove);\n+      document.removeEventListener(\"mouseup\", handleMouseUp);\n+      document.removeEventListener(\"touchmove\", handleMouseMove);\n+      document.removeEventListener(\"touchend\", handleMouseUp);\n+    };\n+  }, [isResizing, startY]);\n+\n   const getPointerCoordinates = (event) => {\n     const svg = svgRef.current;\n     const rect = svg.getBoundingClientRect();\n \n"
                },
                {
                    "date": 1732139592901,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -183,20 +183,8 @@\n     event.preventDefault();\n   };\n \n   useEffect(() => {\n-    const svg = svgRef.current;\n-\n-    const preventContextMenu = (event) => event.preventDefault();\n-\n-    svg.addEventListener(\"contextmenu\", preventContextMenu);\n-\n-    return () => {\n-      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n-    };\n-  }, []);\n-\n-  useEffect(() => {\n     const disableScroll = (event) => {\n       if (isDrawing) {\n         event.preventDefault();\n       }\n@@ -209,52 +197,9 @@\n       document.removeEventListener(\"touchmove\", disableScroll);\n       document.removeEventListener(\"wheel\", disableScroll);\n     };\n   }, [isDrawing]);\n-\n-  useEffect(() => {\n-    const handleMouseMove = (event) => {\n-      if (isResizing) {\n-        const currentY =\n-          event.clientY || (event.touches && event.touches[0].clientY);\n-        const deltaY = currentY - startY;\n-        setSvgHeight((prevHeight) => {\n-          const newHeight = Math.max(\n-            MIN_HEIGHT,\n-            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n-          );\n-          return newHeight;\n-        });\n-        setStartY(currentY);\n-      }\n-    };\n-\n-    const handleMouseUp = () => {\n-      if (isResizing) {\n-        setIsResizing(false);\n-        document.removeEventListener(\"mousemove\", handleMouseMove);\n-        document.removeEventListener(\"mouseup\", handleMouseUp);\n-        document.removeEventListener(\"touchmove\", handleMouseMove);\n-        document.removeEventListener(\"touchend\", handleMouseUp);\n-        saveHeight();\n-      }\n-    };\n-\n-    if (isResizing) {\n-      document.addEventListener(\"mousemove\", handleMouseMove);\n-      document.addEventListener(\"mouseup\", handleMouseUp);\n-      document.addEventListener(\"touchmove\", handleMouseMove);\n-      document.addEventListener(\"touchend\", handleMouseUp);\n-    }\n-\n-    return () => {\n-      document.removeEventListener(\"mousemove\", handleMouseMove);\n-      document.removeEventListener(\"mouseup\", handleMouseUp);\n-      document.removeEventListener(\"touchmove\", handleMouseMove);\n-      document.removeEventListener(\"touchend\", handleMouseUp);\n-    };\n-  }, [isResizing, startY]);\n-\n+  \n   const getPointerCoordinates = (event) => {\n     const svg = svgRef.current;\n     const rect = svg.getBoundingClientRect();\n \n"
                },
                {
                    "date": 1732173525455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,8 +49,38 @@\n   const [background, setBackground] = useState(\n     node.attrs.paperType || backgroundStyles.none\n   );\n \n+  const {\n+    drawing,\n+    path,\n+    svgHeight,\n+    tool,\n+    color,\n+    size,\n+    background,\n+    svgRef,\n+    linesRef,\n+    pathsGroupRef,\n+    activePathRef,\n+    setTool,\n+    setColor,\n+    setSize,\n+    setBackground,\n+    startDrawing,\n+    draw,\n+    stopDrawing,\n+    undo,\n+    redo,\n+    deletePath,\n+    getPointerCoordinates,\n+    adjustColorForMode,\n+  } = useDrawing({\n+    initialHeight: node.attrs.height || 400,\n+    initialLines: node.attrs.lines || [],\n+    onUpdateAttributes: updateAttributes,\n+  });\n+\n   const linesRef = useRef(node.attrs.lines || []);\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n@@ -197,9 +227,9 @@\n       document.removeEventListener(\"touchmove\", disableScroll);\n       document.removeEventListener(\"wheel\", disableScroll);\n     };\n   }, [isDrawing]);\n-  \n+\n   const getPointerCoordinates = (event) => {\n     const svg = svgRef.current;\n     const rect = svg.getBoundingClientRect();\n \n"
                },
                {
                    "date": 1732173532491,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n   const colorInputRef = useRef(null);\n   const [background, setBackground] = useState(\n     node.attrs.paperType || backgroundStyles.none\n   );\n-\n+  const linesRef = useRef(node.attrs.lines || []);\n   const {\n     drawing,\n     path,\n     svgHeight,\n@@ -79,10 +79,8 @@\n     initialLines: node.attrs.lines || [],\n     onUpdateAttributes: updateAttributes,\n   });\n \n-  const linesRef = useRef(node.attrs.lines || []);\n-\n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n     setBackground(newBackground);\n     updateAttributes({ paperType: newBackground });\n@@ -227,9 +225,9 @@\n       document.removeEventListener(\"touchmove\", disableScroll);\n       document.removeEventListener(\"wheel\", disableScroll);\n     };\n   }, [isDrawing]);\n-\n+  \n   const getPointerCoordinates = (event) => {\n     const svg = svgRef.current;\n     const rect = svg.getBoundingClientRect();\n \n"
                },
                {
                    "date": 1732173541159,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,37 +49,9 @@\n   const [background, setBackground] = useState(\n     node.attrs.paperType || backgroundStyles.none\n   );\n   const linesRef = useRef(node.attrs.lines || []);\n-  const {\n-    drawing,\n-    path,\n-    svgHeight,\n-    tool,\n-    color,\n-    size,\n-    background,\n-    svgRef,\n-    linesRef,\n-    pathsGroupRef,\n-    activePathRef,\n-    setTool,\n-    setColor,\n-    setSize,\n-    setBackground,\n-    startDrawing,\n-    draw,\n-    stopDrawing,\n-    undo,\n-    redo,\n-    deletePath,\n-    getPointerCoordinates,\n-    adjustColorForMode,\n-  } = useDrawing({\n-    initialHeight: node.attrs.height || 400,\n-    initialLines: node.attrs.lines || [],\n-    onUpdateAttributes: updateAttributes,\n-  });\n+  const {} = useDrawing({});\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n     setBackground(newBackground);\n@@ -225,9 +197,9 @@\n       document.removeEventListener(\"touchmove\", disableScroll);\n       document.removeEventListener(\"wheel\", disableScroll);\n     };\n   }, [isDrawing]);\n-  \n+\n   const getPointerCoordinates = (event) => {\n     const svg = svgRef.current;\n     const rect = svg.getBoundingClientRect();\n \n"
                },
                {
                    "date": 1732173548396,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,8 +2,9 @@\n import * as d3 from \"d3\";\n import { v4 as uuid } from \"uuid\";\n import { Keyboard } from \"@capacitor/keyboard\";\n import Icons from \"../../../remixicon-react\";\n+import { useDrawing, thicknessOptions, backgroundStyles } from \"./useDrawing\";\n \n const thicknessOptions = {\n   thin: 2,\n   medium: 3,\n"
                },
                {
                    "date": 1732173594037,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,23 +4,8 @@\n import { Keyboard } from \"@capacitor/keyboard\";\n import Icons from \"../../../remixicon-react\";\n import { useDrawing, thicknessOptions, backgroundStyles } from \"./useDrawing\";\n \n-const thicknessOptions = {\n-  thin: 2,\n-  medium: 3,\n-  thick: 4,\n-  thicker: 5,\n-  thickest: 6,\n-};\n-\n-const backgroundStyles = {\n-  none: \"\",\n-  grid: \"grid\",\n-  ruled: \"ruled\",\n-  dotted: \"dotted\",\n-};\n-\n const BUFFER_ZONE = 50;\n const INCREMENT_HEIGHT = 200;\n const PREVIEW_HEIGHT = 500;\n \n"
                },
                {
                    "date": 1732173636769,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -202,52 +202,8 @@\n \n     return [x, y];\n   };\n \n-  const startDrawing = (x, y) => {\n-    setDrawing(true);\n-    setPoints([{ x, y }]);\n-  };\n-\n-  const draw = (x, y) => {\n-    if (!drawing) return;\n-\n-    const newPoints = [...points, { x, y }];\n-    setPoints(newPoints);\n-    const newPath = lineGenerator(newPoints);\n-    setPath(newPath);\n-    if (y > svgHeight - BUFFER_ZONE) {\n-      const newHeight = svgHeight + INCREMENT_HEIGHT;\n-      setSvgHeight(newHeight);\n-      updateAttributes({ height: newHeight });\n-\n-      // Adjust scroll position to keep the drawing point in view\n-      const container = containerRef.current;\n-      if (container) {\n-        const scrollContainer = container.closest(\".drawing-component\");\n-        if (scrollContainer) {\n-          scrollContainer.scrollTo({\n-            top: scrollContainer.scrollHeight,\n-            behavior: \"smooth\",\n-          });\n-        }\n-      }\n-    }\n-  };\n-\n-  const stopDrawing = () => {\n-    if (drawing) {\n-      setDrawing(false);\n-      saveDrawing();\n-      setHistory((prevHistory) => [\n-        ...prevHistory,\n-        { id, path, color, size, tool },\n-      ]);\n-      setPath(\"\");\n-      setPoints([]);\n-    }\n-  };\n-\n   const handleColorChange = (e) => {\n     setColor(e.target.value);\n   };\n \n"
                },
                {
                    "date": 1732173752929,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,9 +35,9 @@\n   const [background, setBackground] = useState(\n     node.attrs.paperType || backgroundStyles.none\n   );\n   const linesRef = useRef(node.attrs.lines || []);\n-  const {} = useDrawing({});\n+  const {draw, startDrawing, stopDrawing} = useDrawing({});\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n     setBackground(newBackground);\n"
                },
                {
                    "date": 1732173773107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n import * as d3 from \"d3\";\n import { v4 as uuid } from \"uuid\";\n import { Keyboard } from \"@capacitor/keyboard\";\n import Icons from \"../../../remixicon-react\";\n-import { useDrawing, thicknessOptions, backgroundStyles } from \"./useDrawing\";\n+import { useDrawing, thicknessOptions, backgroundStyles } from \"./drawUtils\";\n \n const BUFFER_ZONE = 50;\n const INCREMENT_HEIGHT = 200;\n const PREVIEW_HEIGHT = 500;\n"
                },
                {
                    "date": 1732173793470,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \n     const PEN_TIMEOUT_DURATION = 700;\n \n     const handlePointerEvent = (event) => {\n-      if (event.pointerType === \"pen\") {\n+      if (event.pointerType === \"pen\" || event.pointerType === \"mouse\") {\n         penActive = true;\n         clearTimeout(penTimeout);\n         event.preventDefault();\n         event.stopPropagation();\n"
                },
                {
                    "date": 1732173813627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,8 @@\n   const redoStackRef = useRef([]);\n   const svgRef = useRef(null);\n   const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n   const [size, setSize] = useState(thicknessOptions.thin);\n-  const [drawing, setDrawing] = useState(false);\n   const [points, setPoints] = useState([]);\n   const [path, setPath] = useState(\"\");\n   const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n   const [svgWidth] = useState(500);\n"
                },
                {
                    "date": 1732173876379,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,8 @@\n   const redoStackRef = useRef([]);\n   const svgRef = useRef(null);\n   const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n   const [size, setSize] = useState(thicknessOptions.thin);\n-  const [points, setPoints] = useState([]);\n   const [path, setPath] = useState(\"\");\n   const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n   const [svgWidth] = useState(500);\n   const [tool, setTool] = useState(\"pencil\");\n@@ -34,9 +33,17 @@\n   const [background, setBackground] = useState(\n     node.attrs.paperType || backgroundStyles.none\n   );\n   const linesRef = useRef(node.attrs.lines || []);\n-  const {draw, startDrawing, stopDrawing} = useDrawing({});\n+  const {\n+    draw,\n+    startDrawing,\n+    stopDrawing,\n+    points,\n+    setPoints,\n+    drawing,\n+    setDrawing,\n+  } = useDrawing({});\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n     setBackground(newBackground);\n"
                },
                {
                    "date": 1732173895398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -280,19 +280,8 @@\n   const activePathRef = useRef(null);\n   const throttleRef = useRef(null);\n   const batchUpdateTimeoutRef = useRef(null);\n \n-  // Memoize the line generator to prevent recreation\n-  const lineGenerator = useMemo(\n-    () =>\n-      d3\n-        .line()\n-        .x((d) => d.x)\n-        .y((d) => d.y)\n-        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n-    []\n-  );\n-\n   const smoothPoints = (points) => {\n     if (points.length < 3) return points;\n     return points.map((point, i, arr) => {\n       if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n"
                },
                {
                    "date": 1732173943653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,8 @@\n   const redoStackRef = useRef([]);\n   const svgRef = useRef(null);\n   const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n   const [size, setSize] = useState(thicknessOptions.thin);\n-  const [path, setPath] = useState(\"\");\n   const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n   const [svgWidth] = useState(500);\n   const [tool, setTool] = useState(\"pencil\");\n   const [history, setHistory] = useState([]);\n@@ -41,8 +40,10 @@\n     points,\n     setPoints,\n     drawing,\n     setDrawing,\n+    path,\n+    setPath,\n   } = useDrawing({});\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n"
                },
                {
                    "date": 1732173961855,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -373,25 +373,9 @@\n           />\n         ))}\n       </g>\n     ));\n-\n-  // Optimize save drawing function\n-  const saveDrawing = () => {\n-    if (!path) return;\n-\n-    const newLine = { id: uuid(), path, color, size, tool };\n-    linesRef.current = [...linesRef.current, newLine];\n-\n-    setHistory((prevHistory) => [\n-      ...prevHistory,\n-      { action: \"add\", line: newLine },\n-    ]);\n-\n-    setRedoStack([]);\n-    batchUpdatePaths();\n-  };\n-\n+    \n   return (\n     <div className=\"draw w-full min-h-screen flex flex-col\">\n       {/* Top Toolbar */}\n       <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n"
                },
                {
                    "date": 1732173995078,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,8 @@\n   const redoStackRef = useRef([]);\n   const svgRef = useRef(null);\n   const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n   const [size, setSize] = useState(thicknessOptions.thin);\n-  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n   const [svgWidth] = useState(500);\n   const [tool, setTool] = useState(\"pencil\");\n   const [history, setHistory] = useState([]);\n   const [redoStack, setRedoStack] = useState([]);\n@@ -42,8 +41,10 @@\n     drawing,\n     setDrawing,\n     path,\n     setPath,\n+    svgHeight,\n+    setSvgHeight\n   } = useDrawing({});\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n@@ -373,9 +374,9 @@\n           />\n         ))}\n       </g>\n     ));\n-    \n+\n   return (\n     <div className=\"draw w-full min-h-screen flex flex-col\">\n       {/* Top Toolbar */}\n       <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n"
                },
                {
                    "date": 1732174000906,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,9 +43,9 @@\n     path,\n     setPath,\n     svgHeight,\n     setSvgHeight\n-  } = useDrawing({});\n+  } = useDrawing({node:node});\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n     setBackground(newBackground);\n"
                },
                {
                    "date": 1732174044667,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,9 +17,8 @@\n   const pointsRef = useRef([]);\n   const historyRef = useRef([]);\n   const redoStackRef = useRef([]);\n   const svgRef = useRef(null);\n-  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n   const [size, setSize] = useState(thicknessOptions.thin);\n   const [svgWidth] = useState(500);\n   const [tool, setTool] = useState(\"pencil\");\n   const [history, setHistory] = useState([]);\n@@ -42,10 +41,10 @@\n     setDrawing,\n     path,\n     setPath,\n     svgHeight,\n-    setSvgHeight\n-  } = useDrawing({node:node});\n+    setSvgHeight,\n+  } = useDrawing({ node: node });\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n     setBackground(newBackground);\n"
                },
                {
                    "date": 1732174198398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,8 +42,10 @@\n     path,\n     setPath,\n     svgHeight,\n     setSvgHeight,\n+    color,\n+    setColor\n   } = useDrawing({ node: node });\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n"
                },
                {
                    "date": 1732174278399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,9 +17,14 @@\n   const pointsRef = useRef([]);\n   const historyRef = useRef([]);\n   const redoStackRef = useRef([]);\n   const svgRef = useRef(null);\n+  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n   const [size, setSize] = useState(thicknessOptions.thin);\n+  const [drawing, setDrawing] = useState(false);\n+  const [points, setPoints] = useState([]);\n+  const [path, setPath] = useState(\"\");\n+  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n   const [svgWidth] = useState(500);\n   const [tool, setTool] = useState(\"pencil\");\n   const [history, setHistory] = useState([]);\n   const [redoStack, setRedoStack] = useState([]);\n@@ -30,23 +35,9 @@\n   const [background, setBackground] = useState(\n     node.attrs.paperType || backgroundStyles.none\n   );\n   const linesRef = useRef(node.attrs.lines || []);\n-  const {\n-    draw,\n-    startDrawing,\n-    stopDrawing,\n-    points,\n-    setPoints,\n-    drawing,\n-    setDrawing,\n-    path,\n-    setPath,\n-    svgHeight,\n-    setSvgHeight,\n-    color,\n-    setColor\n-  } = useDrawing({ node: node });\n+  const {draw, startDrawing, stopDrawing} = useDrawing({});\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n     setBackground(newBackground);\n@@ -283,8 +274,19 @@\n   const activePathRef = useRef(null);\n   const throttleRef = useRef(null);\n   const batchUpdateTimeoutRef = useRef(null);\n \n+  // Memoize the line generator to prevent recreation\n+  const lineGenerator = useMemo(\n+    () =>\n+      d3\n+        .line()\n+        .x((d) => d.x)\n+        .y((d) => d.y)\n+        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n+    []\n+  );\n+\n   const smoothPoints = (points) => {\n     if (points.length < 3) return points;\n     return points.map((point, i, arr) => {\n       if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n@@ -376,8 +378,24 @@\n         ))}\n       </g>\n     ));\n \n+  // Optimize save drawing function\n+  const saveDrawing = () => {\n+    if (!path) return;\n+\n+    const newLine = { id: uuid(), path, color, size, tool };\n+    linesRef.current = [...linesRef.current, newLine];\n+\n+    setHistory((prevHistory) => [\n+      ...prevHistory,\n+      { action: \"add\", line: newLine },\n+    ]);\n+\n+    setRedoStack([]);\n+    batchUpdatePaths();\n+  };\n+\n   return (\n     <div className=\"draw w-full min-h-screen flex flex-col\">\n       {/* Top Toolbar */}\n       <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n"
                },
                {
                    "date": 1732174319268,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,28 +16,46 @@\n   const [lines, setLines] = useState([]);\n   const pointsRef = useRef([]);\n   const historyRef = useRef([]);\n   const redoStackRef = useRef([]);\n-  const svgRef = useRef(null);\n-  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n-  const [size, setSize] = useState(thicknessOptions.thin);\n-  const [drawing, setDrawing] = useState(false);\n   const [points, setPoints] = useState([]);\n-  const [path, setPath] = useState(\"\");\n-  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n   const [svgWidth] = useState(500);\n-  const [tool, setTool] = useState(\"pencil\");\n   const [history, setHistory] = useState([]);\n   const [redoStack, setRedoStack] = useState([]);\n   const [isResizing, setIsResizing] = useState(false);\n   const [startY, setStartY] = useState(0);\n   const [id] = useState(() => node.attrs.id || uuid());\n   const colorInputRef = useRef(null);\n-  const [background, setBackground] = useState(\n-    node.attrs.paperType || backgroundStyles.none\n-  );\n-  const linesRef = useRef(node.attrs.lines || []);\n-  const {draw, startDrawing, stopDrawing} = useDrawing({});\n+  \n+  const {\n+    drawing,\n+    path,\n+    svgHeight,\n+    tool,\n+    color,\n+    size,\n+    background,\n+    svgRef,\n+    linesRef,\n+    pathsGroupRef,\n+    activePathRef,\n+    setTool,\n+    setColor,\n+    setSize,\n+    setBackground,\n+    startDrawing,\n+    draw,\n+    stopDrawing,\n+    undo,\n+    redo,\n+    deletePath,\n+    getPointerCoordinates,\n+    adjustColorForMode,\n+  } = useDrawing({\n+    initialHeight: node.attrs.height || 400,\n+    initialLines: node.attrs.lines || [],\n+    onUpdateAttributes: updateAttributes,\n+  });\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n     setBackground(newBackground);\n"
                },
                {
                    "date": 1732174333964,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n   const [isResizing, setIsResizing] = useState(false);\n   const [startY, setStartY] = useState(0);\n   const [id] = useState(() => node.attrs.id || uuid());\n   const colorInputRef = useRef(null);\n-  \n+\n   const {\n     drawing,\n     path,\n     svgHeight,\n@@ -286,11 +286,9 @@\n     return () => {\n       showListener.remove();\n     };\n   }, []);\n-\n-  const pathsGroupRef = useRef(null);\n-  const activePathRef = useRef(null);\n+  \n   const throttleRef = useRef(null);\n   const batchUpdateTimeoutRef = useRef(null);\n \n   // Memoize the line generator to prevent recreation\n"
                },
                {
                    "date": 1732175008821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -160,30 +160,8 @@\n       document.body.removeEventListener(\"touchend\", preventScrolling);\n     };\n   }, [tool, color, size, points]);\n \n-  const deletePath = (pathElement) => {\n-    const clickedPathData = pathElement.getAttribute(\"d\");\n-    const pathIndex = linesRef.current.findIndex(\n-      (line) => line.path === clickedPathData\n-    );\n-\n-    if (pathIndex !== -1) {\n-      const removedLine = linesRef.current[pathIndex];\n-\n-      // Save the deletion action\n-      setHistory((prevHistory) => [\n-        ...prevHistory,\n-        { action: \"delete\", line: removedLine },\n-      ]);\n-\n-      linesRef.current.splice(pathIndex, 1);\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n   const handleMouseDown = (event) => {\n     event.preventDefault();\n   };\n \n@@ -202,79 +180,17 @@\n       document.removeEventListener(\"wheel\", disableScroll);\n     };\n   }, [isDrawing]);\n \n-  const getPointerCoordinates = (event) => {\n-    const svg = svgRef.current;\n-    const rect = svg.getBoundingClientRect();\n \n-    // Get the correct pointer position, including page scroll and scale\n-    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n-    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n-\n-    // Calculate the mouse position relative to the SVG\n-    const scaleX = svg.viewBox.baseVal.width / rect.width;\n-    const scaleY = svg.viewBox.baseVal.height / rect.height;\n-\n-    const x = (clientX - rect.left) * scaleX;\n-    const y = (clientY - rect.top) * scaleY;\n-\n-    return [x, y];\n-  };\n-\n   const handleColorChange = (e) => {\n     setColor(e.target.value);\n   };\n \n   const openColorPicker = () => {\n     colorInputRef.current.click();\n   };\n \n-  // Store only actions in history (add or delete)\n-  const undo = () => {\n-    if (history.length > 0) {\n-      const lastAction = history[history.length - 1];\n-      setHistory((prevHistory) => prevHistory.slice(0, -1));\n-      setRedoStack((prevStack) => [...prevStack, lastAction]);\n-\n-      if (lastAction.action === \"add\") {\n-        // Undo adding a line by removing it\n-        linesRef.current = linesRef.current.filter(\n-          (line) => line.id !== lastAction.line.id\n-        );\n-      } else if (lastAction.action === \"delete\") {\n-        // Undo deleting a line by adding it back\n-        linesRef.current = [...linesRef.current, lastAction.line];\n-      }\n-\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n-  const redo = () => {\n-    if (redoStack.length > 0) {\n-      const lastRedo = redoStack[redoStack.length - 1];\n-      setRedoStack((prevStack) => prevStack.slice(0, -1));\n-      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n-\n-      if (lastRedo.action === \"add\") {\n-        // Redo adding a line by adding it back\n-        linesRef.current = [...linesRef.current, lastRedo.line];\n-      } else if (lastRedo.action === \"delete\") {\n-        // Redo deleting a line by removing it again\n-        linesRef.current = linesRef.current.filter(\n-          (line) => line.id !== lastRedo.line.id\n-        );\n-      }\n-\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n   const saveHeight = () => {\n     updateAttributes({ height: svgHeight });\n   };\n \n@@ -286,9 +202,9 @@\n     return () => {\n       showListener.remove();\n     };\n   }, []);\n-  \n+\n   const throttleRef = useRef(null);\n   const batchUpdateTimeoutRef = useRef(null);\n \n   // Memoize the line generator to prevent recreation\n"
                },
                {
                    "date": 1732175013940,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -282,18 +282,8 @@\n     }\n     return chunks;\n   }, [linesRef.current.length]);\n \n-  const adjustColorForMode = (color) => {\n-    if (isDarkMode) {\n-      // Dark mode: Black turns to white; other colors unchanged\n-      return color === \"#000000\" ? \"#FFFFFF\" : color;\n-    } else {\n-      // Light mode: White turns to black; other colors unchanged\n-      return color === \"#FFFFFF\" ? \"#000000\" : color;\n-    }\n-  };\n-\n   // Optimize path rendering\n   const renderPaths = () =>\n     chunkedLines.map((chunk, chunkIndex) => (\n       <g key={`chunk-${chunkIndex}`}>\n"
                },
                {
                    "date": 1732175030081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,8 +53,9 @@\n   } = useDrawing({\n     initialHeight: node.attrs.height || 400,\n     initialLines: node.attrs.lines || [],\n     onUpdateAttributes: updateAttributes,\n+    node: node,\n   });\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n"
                },
                {
                    "date": 1732175266517,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,10 +2,24 @@\n import * as d3 from \"d3\";\n import { v4 as uuid } from \"uuid\";\n import { Keyboard } from \"@capacitor/keyboard\";\n import Icons from \"../../../remixicon-react\";\n-import { useDrawing, thicknessOptions, backgroundStyles } from \"./drawUtils\";\n \n+const thicknessOptions = {\n+  thin: 2,\n+  medium: 3,\n+  thick: 4,\n+  thicker: 5,\n+  thickest: 6,\n+};\n+\n+const backgroundStyles = {\n+  none: \"\",\n+  grid: \"grid\",\n+  ruled: \"ruled\",\n+  dotted: \"dotted\",\n+};\n+\n const BUFFER_ZONE = 50;\n const INCREMENT_HEIGHT = 200;\n const PREVIEW_HEIGHT = 500;\n \n@@ -16,47 +30,28 @@\n   const [lines, setLines] = useState([]);\n   const pointsRef = useRef([]);\n   const historyRef = useRef([]);\n   const redoStackRef = useRef([]);\n+  const svgRef = useRef(null);\n+  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n+  const [size, setSize] = useState(thicknessOptions.thin);\n+  const [drawing, setDrawing] = useState(false);\n   const [points, setPoints] = useState([]);\n+  const [path, setPath] = useState(\"\");\n+  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n   const [svgWidth] = useState(500);\n+  const [tool, setTool] = useState(\"pencil\");\n   const [history, setHistory] = useState([]);\n   const [redoStack, setRedoStack] = useState([]);\n   const [isResizing, setIsResizing] = useState(false);\n   const [startY, setStartY] = useState(0);\n   const [id] = useState(() => node.attrs.id || uuid());\n   const colorInputRef = useRef(null);\n+  const [background, setBackground] = useState(\n+    node.attrs.paperType || backgroundStyles.none\n+  );\n \n-  const {\n-    drawing,\n-    path,\n-    svgHeight,\n-    tool,\n-    color,\n-    size,\n-    background,\n-    svgRef,\n-    linesRef,\n-    pathsGroupRef,\n-    activePathRef,\n-    setTool,\n-    setColor,\n-    setSize,\n-    setBackground,\n-    startDrawing,\n-    draw,\n-    stopDrawing,\n-    undo,\n-    redo,\n-    deletePath,\n-    getPointerCoordinates,\n-    adjustColorForMode,\n-  } = useDrawing({\n-    initialHeight: node.attrs.height || 400,\n-    initialLines: node.attrs.lines || [],\n-    onUpdateAttributes: updateAttributes,\n-    node: node,\n-  });\n+  const linesRef = useRef(node.attrs.lines || []);\n \n   const handleBackgroundChange = (event) => {\n     const newBackground = event.target.value;\n     setBackground(newBackground);\n@@ -72,12 +67,12 @@\n \n     const PEN_TIMEOUT_DURATION = 700;\n \n     const handlePointerEvent = (event) => {\n-      if (event.pointerType === \"pen\" || event.pointerType === \"mouse\") {\n+      if (event.pointerType === \"pen\") {\n         penActive = true;\n         clearTimeout(penTimeout);\n-        event.preventDefault();\n+        event.preventDefault(); // Prevent touch interaction when pen is active\n         event.stopPropagation();\n \n         const [x, y] = getPointerCoordinates(event);\n \n@@ -131,20 +126,23 @@\n         }\n       });\n     };\n \n+    // Prevent scrolling when the pencil (pen) is active\n     const preventScrolling = (event) => {\n       if (penActive) {\n-        event.preventDefault();\n+        event.preventDefault(); // Prevent scrolling\n         event.stopPropagation();\n       }\n     };\n \n+    // Attach pen input handlers on SVG\n     svg\n       .on(\"pointerdown\", handlePointerEvent)\n       .on(\"pointermove\", handlePointerEvent)\n       .on(\"pointerup\", handlePointerEvent);\n \n+    // Block touch interactions (scrolling) when pen is active\n     document.body.addEventListener(\"touchstart\", preventScrolling, {\n       passive: false,\n     });\n     document.body.addEventListener(\"touchmove\", preventScrolling, {\n@@ -153,21 +151,63 @@\n     document.body.addEventListener(\"touchend\", preventScrolling, {\n       passive: false,\n     });\n \n+    // Suppress context menu (e.g., copy/paste menu) on pen input\n+    svg.on(\"contextmenu\", (event) => {\n+      if (penActive) {\n+        event.preventDefault();\n+      }\n+    });\n+\n+    // Cleanup on component unmount\n     return () => {\n       clearTimeout(penTimeout);\n       document.body.removeEventListener(\"touchstart\", preventScrolling);\n       document.body.removeEventListener(\"touchmove\", preventScrolling);\n       document.body.removeEventListener(\"touchend\", preventScrolling);\n     };\n   }, [tool, color, size, points]);\n \n+  const deletePath = (pathElement) => {\n+    const clickedPathData = pathElement.getAttribute(\"d\");\n+    const pathIndex = linesRef.current.findIndex(\n+      (line) => line.path === clickedPathData\n+    );\n+\n+    if (pathIndex !== -1) {\n+      const removedLine = linesRef.current[pathIndex];\n+\n+      // Save the deletion action\n+      setHistory((prevHistory) => [\n+        ...prevHistory,\n+        { action: \"delete\", line: removedLine },\n+      ]);\n+\n+      linesRef.current.splice(pathIndex, 1);\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n   const handleMouseDown = (event) => {\n     event.preventDefault();\n   };\n \n   useEffect(() => {\n+    const svg = svgRef.current;\n+\n+    const preventContextMenu = (event) => event.preventDefault();\n+\n+    svg.addEventListener(\"contextmenu\", preventContextMenu);\n+\n+    return () => {\n+      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n+    };\n+  }, []);\n+\n+  useEffect(() => {\n     const disableScroll = (event) => {\n       if (isDrawing) {\n         event.preventDefault();\n       }\n@@ -181,17 +221,166 @@\n       document.removeEventListener(\"wheel\", disableScroll);\n     };\n   }, [isDrawing]);\n \n+  useEffect(() => {\n+    const handleMouseMove = (event) => {\n+      if (isResizing) {\n+        const currentY =\n+          event.clientY || (event.touches && event.touches[0].clientY);\n+        const deltaY = currentY - startY;\n+        setSvgHeight((prevHeight) => {\n+          const newHeight = Math.max(\n+            MIN_HEIGHT,\n+            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n+          );\n+          return newHeight;\n+        });\n+        setStartY(currentY);\n+      }\n+    };\n \n+    const handleMouseUp = () => {\n+      if (isResizing) {\n+        setIsResizing(false);\n+        document.removeEventListener(\"mousemove\", handleMouseMove);\n+        document.removeEventListener(\"mouseup\", handleMouseUp);\n+        document.removeEventListener(\"touchmove\", handleMouseMove);\n+        document.removeEventListener(\"touchend\", handleMouseUp);\n+        saveHeight();\n+      }\n+    };\n+\n+    if (isResizing) {\n+      document.addEventListener(\"mousemove\", handleMouseMove);\n+      document.addEventListener(\"mouseup\", handleMouseUp);\n+      document.addEventListener(\"touchmove\", handleMouseMove);\n+      document.addEventListener(\"touchend\", handleMouseUp);\n+    }\n+\n+    return () => {\n+      document.removeEventListener(\"mousemove\", handleMouseMove);\n+      document.removeEventListener(\"mouseup\", handleMouseUp);\n+      document.removeEventListener(\"touchmove\", handleMouseMove);\n+      document.removeEventListener(\"touchend\", handleMouseUp);\n+    };\n+  }, [isResizing, startY]);\n+\n+  const getPointerCoordinates = (event) => {\n+    const svg = svgRef.current;\n+    const rect = svg.getBoundingClientRect();\n+\n+    // Get the correct pointer position, including page scroll and scale\n+    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n+    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n+\n+    // Calculate the mouse position relative to the SVG\n+    const scaleX = svg.viewBox.baseVal.width / rect.width;\n+    const scaleY = svg.viewBox.baseVal.height / rect.height;\n+\n+    const x = (clientX - rect.left) * scaleX;\n+    const y = (clientY - rect.top) * scaleY;\n+\n+    return [x, y];\n+  };\n+\n+  const startDrawing = (x, y) => {\n+    setDrawing(true);\n+    setPoints([{ x, y }]);\n+  };\n+\n+  const draw = (x, y) => {\n+    if (!drawing) return;\n+\n+    const newPoints = [...points, { x, y }];\n+    setPoints(newPoints);\n+    const newPath = lineGenerator(newPoints);\n+    setPath(newPath);\n+    if (y > svgHeight - BUFFER_ZONE) {\n+      const newHeight = svgHeight + INCREMENT_HEIGHT;\n+      setSvgHeight(newHeight);\n+      updateAttributes({ height: newHeight });\n+\n+      // Adjust scroll position to keep the drawing point in view\n+      const container = containerRef.current;\n+      if (container) {\n+        const scrollContainer = container.closest(\".drawing-component\");\n+        if (scrollContainer) {\n+          scrollContainer.scrollTo({\n+            top: scrollContainer.scrollHeight,\n+            behavior: \"smooth\",\n+          });\n+        }\n+      }\n+    }\n+  };\n+\n+  const stopDrawing = () => {\n+    if (drawing) {\n+      setDrawing(false);\n+      saveDrawing();\n+      setHistory((prevHistory) => [\n+        ...prevHistory,\n+        { id, path, color, size, tool },\n+      ]);\n+      setPath(\"\");\n+      setPoints([]);\n+    }\n+  };\n+\n   const handleColorChange = (e) => {\n     setColor(e.target.value);\n   };\n \n   const openColorPicker = () => {\n     colorInputRef.current.click();\n   };\n \n+  // Store only actions in history (add or delete)\n+  const undo = () => {\n+    if (history.length > 0) {\n+      const lastAction = history[history.length - 1];\n+      setHistory((prevHistory) => prevHistory.slice(0, -1));\n+      setRedoStack((prevStack) => [...prevStack, lastAction]);\n+\n+      if (lastAction.action === \"add\") {\n+        // Undo adding a line by removing it\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastAction.line.id\n+        );\n+      } else if (lastAction.action === \"delete\") {\n+        // Undo deleting a line by adding it back\n+        linesRef.current = [...linesRef.current, lastAction.line];\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const redo = () => {\n+    if (redoStack.length > 0) {\n+      const lastRedo = redoStack[redoStack.length - 1];\n+      setRedoStack((prevStack) => prevStack.slice(0, -1));\n+      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n+\n+      if (lastRedo.action === \"add\") {\n+        // Redo adding a line by adding it back\n+        linesRef.current = [...linesRef.current, lastRedo.line];\n+      } else if (lastRedo.action === \"delete\") {\n+        // Redo deleting a line by removing it again\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastRedo.line.id\n+        );\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n   const saveHeight = () => {\n     updateAttributes({ height: svgHeight });\n   };\n \n@@ -204,8 +393,10 @@\n       showListener.remove();\n     };\n   }, []);\n \n+  const pathsGroupRef = useRef(null);\n+  const activePathRef = useRef(null);\n   const throttleRef = useRef(null);\n   const batchUpdateTimeoutRef = useRef(null);\n \n   // Memoize the line generator to prevent recreation\n@@ -283,8 +474,18 @@\n     }\n     return chunks;\n   }, [linesRef.current.length]);\n \n+  const adjustColorForMode = (color) => {\n+    if (isDarkMode) {\n+      // Dark mode: Black turns to white; other colors unchanged\n+      return color === \"#000000\" ? \"#FFFFFF\" : color;\n+    } else {\n+      // Light mode: White turns to black; other colors unchanged\n+      return color === \"#FFFFFF\" ? \"#000000\" : color;\n+    }\n+  };\n+\n   // Optimize path rendering\n   const renderPaths = () =>\n     chunkedLines.map((chunk, chunkIndex) => (\n       <g key={`chunk-${chunkIndex}`}>\n"
                },
                {
                    "date": 1732175311303,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -151,15 +151,8 @@\n     document.body.addEventListener(\"touchend\", preventScrolling, {\n       passive: false,\n     });\n \n-    // Suppress context menu (e.g., copy/paste menu) on pen input\n-    svg.on(\"contextmenu\", (event) => {\n-      if (penActive) {\n-        event.preventDefault();\n-      }\n-    });\n-\n     // Cleanup on component unmount\n     return () => {\n       clearTimeout(penTimeout);\n       document.body.removeEventListener(\"touchstart\", preventScrolling);\n@@ -192,22 +185,10 @@\n \n   const handleMouseDown = (event) => {\n     event.preventDefault();\n   };\n-\n+  \n   useEffect(() => {\n-    const svg = svgRef.current;\n-\n-    const preventContextMenu = (event) => event.preventDefault();\n-\n-    svg.addEventListener(\"contextmenu\", preventContextMenu);\n-\n-    return () => {\n-      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n-    };\n-  }, []);\n-\n-  useEffect(() => {\n     const disableScroll = (event) => {\n       if (isDrawing) {\n         event.preventDefault();\n       }\n"
                },
                {
                    "date": 1732175327022,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -185,9 +185,9 @@\n \n   const handleMouseDown = (event) => {\n     event.preventDefault();\n   };\n-  \n+\n   useEffect(() => {\n     const disableScroll = (event) => {\n       if (isDrawing) {\n         event.preventDefault();\n@@ -202,51 +202,8 @@\n       document.removeEventListener(\"wheel\", disableScroll);\n     };\n   }, [isDrawing]);\n \n-  useEffect(() => {\n-    const handleMouseMove = (event) => {\n-      if (isResizing) {\n-        const currentY =\n-          event.clientY || (event.touches && event.touches[0].clientY);\n-        const deltaY = currentY - startY;\n-        setSvgHeight((prevHeight) => {\n-          const newHeight = Math.max(\n-            MIN_HEIGHT,\n-            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n-          );\n-          return newHeight;\n-        });\n-        setStartY(currentY);\n-      }\n-    };\n-\n-    const handleMouseUp = () => {\n-      if (isResizing) {\n-        setIsResizing(false);\n-        document.removeEventListener(\"mousemove\", handleMouseMove);\n-        document.removeEventListener(\"mouseup\", handleMouseUp);\n-        document.removeEventListener(\"touchmove\", handleMouseMove);\n-        document.removeEventListener(\"touchend\", handleMouseUp);\n-        saveHeight();\n-      }\n-    };\n-\n-    if (isResizing) {\n-      document.addEventListener(\"mousemove\", handleMouseMove);\n-      document.addEventListener(\"mouseup\", handleMouseUp);\n-      document.addEventListener(\"touchmove\", handleMouseMove);\n-      document.addEventListener(\"touchend\", handleMouseUp);\n-    }\n-\n-    return () => {\n-      document.removeEventListener(\"mousemove\", handleMouseMove);\n-      document.removeEventListener(\"mouseup\", handleMouseUp);\n-      document.removeEventListener(\"touchmove\", handleMouseMove);\n-      document.removeEventListener(\"touchend\", handleMouseUp);\n-    };\n-  }, [isResizing, startY]);\n-\n   const getPointerCoordinates = (event) => {\n     const svg = svgRef.current;\n     const rect = svg.getBoundingClientRect();\n \n"
                },
                {
                    "date": 1732175738803,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,55 +1,28 @@\n-import React, { useState, useRef, useEffect, useMemo } from \"react\";\n-import * as d3 from \"d3\";\n-import { v4 as uuid } from \"uuid\";\n+import React from \"react\";\n+import { useDrawLogic } from \"./useDrawLogic\";\n import { Keyboard } from \"@capacitor/keyboard\";\n import Icons from \"../../../remixicon-react\";\n \n-const thicknessOptions = {\n-  thin: 2,\n-  medium: 3,\n-  thick: 4,\n-  thicker: 5,\n-  thickest: 6,\n-};\n-\n-const backgroundStyles = {\n-  none: \"\",\n-  grid: \"grid\",\n-  ruled: \"ruled\",\n-  dotted: \"dotted\",\n-};\n-\n-const BUFFER_ZONE = 50;\n-const INCREMENT_HEIGHT = 200;\n-const PREVIEW_HEIGHT = 500;\n-\n const DrawMode = ({ onClose, updateAttributes, node }) => {\n-  const isDarkMode = document.documentElement.classList.contains(\"dark\");\n-  const [isDrawing, setIsDrawing] = useState(false);\n-  const [drawingPath, setDrawingPath] = useState(\"\");\n-  const [lines, setLines] = useState([]);\n-  const pointsRef = useRef([]);\n-  const historyRef = useRef([]);\n-  const redoStackRef = useRef([]);\n-  const svgRef = useRef(null);\n-  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n-  const [size, setSize] = useState(thicknessOptions.thin);\n-  const [drawing, setDrawing] = useState(false);\n-  const [points, setPoints] = useState([]);\n-  const [path, setPath] = useState(\"\");\n-  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n-  const [svgWidth] = useState(500);\n-  const [tool, setTool] = useState(\"pencil\");\n-  const [history, setHistory] = useState([]);\n-  const [redoStack, setRedoStack] = useState([]);\n-  const [isResizing, setIsResizing] = useState(false);\n-  const [startY, setStartY] = useState(0);\n-  const [id] = useState(() => node.attrs.id || uuid());\n-  const colorInputRef = useRef(null);\n-  const [background, setBackground] = useState(\n-    node.attrs.paperType || backgroundStyles.none\n-  );\n+  const {\n+    isDrawing,\n+    svgRef,\n+    path,\n+    color,\n+    size,\n+    tool,\n+    svgHeight,\n+    svgWidth,\n+    setColor,\n+    setSize,\n+    setTool,\n+    undo,\n+    redo,\n+    startDrawing,\n+    draw,\n+    stopDrawing,\n+  } = useDrawLogic(node, updateAttributes);\n \n   const linesRef = useRef(node.attrs.lines || []);\n \n   const handleBackgroundChange = (event) => {\n@@ -272,53 +245,8 @@\n   const openColorPicker = () => {\n     colorInputRef.current.click();\n   };\n \n-  // Store only actions in history (add or delete)\n-  const undo = () => {\n-    if (history.length > 0) {\n-      const lastAction = history[history.length - 1];\n-      setHistory((prevHistory) => prevHistory.slice(0, -1));\n-      setRedoStack((prevStack) => [...prevStack, lastAction]);\n-\n-      if (lastAction.action === \"add\") {\n-        // Undo adding a line by removing it\n-        linesRef.current = linesRef.current.filter(\n-          (line) => line.id !== lastAction.line.id\n-        );\n-      } else if (lastAction.action === \"delete\") {\n-        // Undo deleting a line by adding it back\n-        linesRef.current = [...linesRef.current, lastAction.line];\n-      }\n-\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n-  const redo = () => {\n-    if (redoStack.length > 0) {\n-      const lastRedo = redoStack[redoStack.length - 1];\n-      setRedoStack((prevStack) => prevStack.slice(0, -1));\n-      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n-\n-      if (lastRedo.action === \"add\") {\n-        // Redo adding a line by adding it back\n-        linesRef.current = [...linesRef.current, lastRedo.line];\n-      } else if (lastRedo.action === \"delete\") {\n-        // Redo deleting a line by removing it again\n-        linesRef.current = linesRef.current.filter(\n-          (line) => line.id !== lastRedo.line.id\n-        );\n-      }\n-\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n   const saveHeight = () => {\n     updateAttributes({ height: svgHeight });\n   };\n \n"
                },
                {
                    "date": 1732175749307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,550 @@\n+import React from \"react\";\n+import { useDrawLogic } from \"./useDrawLogic\";\n+import { Keyboard } from \"@capacitor/keyboard\";\n+import Icons from \"../../../remixicon-react\";\n+\n+const DrawMode = ({ onClose, updateAttributes, node }) => {\n+  const {\n+    isDrawing,\n+    svgRef,\n+    path,\n+    color,\n+    size,\n+    tool,\n+    svgHeight,\n+    svgWidth,\n+    setColor,\n+    setSize,\n+    setTool,\n+    undo,\n+    redo,\n+    startDrawing,\n+    draw,\n+    stopDrawing,\n+  } = useDrawLogic(node, updateAttributes);\n+\n+  const linesRef = useRef(node.attrs.lines || []);\n+\n+  const handleBackgroundChange = (event) => {\n+    const newBackground = event.target.value;\n+    setBackground(newBackground);\n+    updateAttributes({ paperType: newBackground });\n+  };\n+\n+  useEffect(() => {\n+    const svg = d3.select(svgRef.current);\n+    const eraseRadius = 5;\n+    let isErasing = false;\n+    let penActive = false;\n+    let penTimeout = null;\n+\n+    const PEN_TIMEOUT_DURATION = 700;\n+\n+    const handlePointerEvent = (event) => {\n+      if (event.pointerType === \"pen\") {\n+        penActive = true;\n+        clearTimeout(penTimeout);\n+        event.preventDefault(); // Prevent touch interaction when pen is active\n+        event.stopPropagation();\n+\n+        const [x, y] = getPointerCoordinates(event);\n+\n+        if (event.type === \"pointerdown\") {\n+          if (tool === \"erase\") {\n+            isErasing = true;\n+            eraseOverlappingPaths(x, y);\n+          } else {\n+            startDrawing(x, y);\n+          }\n+        } else if (event.type === \"pointermove\") {\n+          if (tool === \"erase\" && isErasing) {\n+            eraseOverlappingPaths(x, y);\n+          } else if (tool !== \"erase\") {\n+            draw(x, y);\n+          }\n+        } else if (event.type === \"pointerup\") {\n+          if (tool === \"erase\") {\n+            isErasing = false;\n+          } else {\n+            stopDrawing();\n+          }\n+\n+          penTimeout = setTimeout(() => {\n+            penActive = false;\n+          }, PEN_TIMEOUT_DURATION);\n+        }\n+      }\n+    };\n+\n+    const eraseOverlappingPaths = (x, y) => {\n+      const eraserArea = {\n+        x: x - eraseRadius,\n+        y: y - eraseRadius,\n+        width: eraseRadius * 2,\n+        height: eraseRadius * 2,\n+      };\n+\n+      svg.selectAll(\"path\").each(function () {\n+        const path = d3.select(this);\n+        const pathNode = path.node();\n+        const pathBBox = pathNode.getBBox();\n+\n+        if (\n+          pathBBox.x < eraserArea.x + eraserArea.width &&\n+          pathBBox.x + pathBBox.width > eraserArea.x &&\n+          pathBBox.y < eraserArea.y + eraserArea.height &&\n+          pathBBox.y + pathBBox.height > eraserArea.y\n+        ) {\n+          deletePath(pathNode);\n+        }\n+      });\n+    };\n+\n+    // Prevent scrolling when the pencil (pen) is active\n+    const preventScrolling = (event) => {\n+      if (penActive) {\n+        event.preventDefault(); // Prevent scrolling\n+        event.stopPropagation();\n+      }\n+    };\n+\n+    // Attach pen input handlers on SVG\n+    svg\n+      .on(\"pointerdown\", handlePointerEvent)\n+      .on(\"pointermove\", handlePointerEvent)\n+      .on(\"pointerup\", handlePointerEvent);\n+\n+    // Block touch interactions (scrolling) when pen is active\n+    document.body.addEventListener(\"touchstart\", preventScrolling, {\n+      passive: false,\n+    });\n+    document.body.addEventListener(\"touchmove\", preventScrolling, {\n+      passive: false,\n+    });\n+    document.body.addEventListener(\"touchend\", preventScrolling, {\n+      passive: false,\n+    });\n+\n+    // Cleanup on component unmount\n+    return () => {\n+      clearTimeout(penTimeout);\n+      document.body.removeEventListener(\"touchstart\", preventScrolling);\n+      document.body.removeEventListener(\"touchmove\", preventScrolling);\n+      document.body.removeEventListener(\"touchend\", preventScrolling);\n+    };\n+  }, [tool, color, size, points]);\n+\n+  const deletePath = (pathElement) => {\n+    const clickedPathData = pathElement.getAttribute(\"d\");\n+    const pathIndex = linesRef.current.findIndex(\n+      (line) => line.path === clickedPathData\n+    );\n+\n+    if (pathIndex !== -1) {\n+      const removedLine = linesRef.current[pathIndex];\n+\n+      // Save the deletion action\n+      setHistory((prevHistory) => [\n+        ...prevHistory,\n+        { action: \"delete\", line: removedLine },\n+      ]);\n+\n+      linesRef.current.splice(pathIndex, 1);\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const handleMouseDown = (event) => {\n+    event.preventDefault();\n+  };\n+\n+  useEffect(() => {\n+    const disableScroll = (event) => {\n+      if (isDrawing) {\n+        event.preventDefault();\n+      }\n+    };\n+\n+    document.addEventListener(\"touchmove\", disableScroll, { passive: false });\n+    document.addEventListener(\"wheel\", disableScroll, { passive: false });\n+\n+    return () => {\n+      document.removeEventListener(\"touchmove\", disableScroll);\n+      document.removeEventListener(\"wheel\", disableScroll);\n+    };\n+  }, [isDrawing]);\n+\n+  const getPointerCoordinates = (event) => {\n+    const svg = svgRef.current;\n+    const rect = svg.getBoundingClientRect();\n+\n+    // Get the correct pointer position, including page scroll and scale\n+    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n+    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n+\n+    // Calculate the mouse position relative to the SVG\n+    const scaleX = svg.viewBox.baseVal.width / rect.width;\n+    const scaleY = svg.viewBox.baseVal.height / rect.height;\n+\n+    const x = (clientX - rect.left) * scaleX;\n+    const y = (clientY - rect.top) * scaleY;\n+\n+    return [x, y];\n+  };\n+\n+  const handleColorChange = (e) => {\n+    setColor(e.target.value);\n+  };\n+\n+  const openColorPicker = () => {\n+    colorInputRef.current.click();\n+  };\n+\n+  const saveHeight = () => {\n+    updateAttributes({ height: svgHeight });\n+  };\n+\n+  useEffect(() => {\n+    const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n+      Keyboard.hide();\n+    });\n+\n+    return () => {\n+      showListener.remove();\n+    };\n+  }, []);\n+\n+  const pathsGroupRef = useRef(null);\n+  const activePathRef = useRef(null);\n+  const throttleRef = useRef(null);\n+  const batchUpdateTimeoutRef = useRef(null);\n+\n+  // Memoize the line generator to prevent recreation\n+  const lineGenerator = useMemo(\n+    () =>\n+      d3\n+        .line()\n+        .x((d) => d.x)\n+        .y((d) => d.y)\n+        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n+    []\n+  );\n+\n+  const smoothPoints = (points) => {\n+    if (points.length < 3) return points;\n+    return points.map((point, i, arr) => {\n+      if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n+      const prev = arr[i - 1];\n+      const next = arr[i + 1];\n+      return {\n+        x: (prev.x + point.x + next.x) / 3,\n+        y: (prev.y + point.y + next.y) / 3,\n+      };\n+    });\n+  };\n+\n+  // Batch update function for paths\n+  const batchUpdatePaths = () => {\n+    if (batchUpdateTimeoutRef.current) {\n+      clearTimeout(batchUpdateTimeoutRef.current);\n+    }\n+\n+    batchUpdateTimeoutRef.current = setTimeout(() => {\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }, 500); // Adjust timeout as needed\n+  };\n+\n+  // Throttle draw function\n+  const throttledDraw = (x, y) => {\n+    if (!throttleRef.current) {\n+      throttleRef.current = setTimeout(() => {\n+        throttleRef.current = null;\n+      }, 16); // ~60fps\n+\n+      if (!drawing) return;\n+\n+      const newPoints = [...points, { x, y }];\n+      setPoints(newPoints);\n+\n+      const newPath = lineGenerator(smoothPoints(newPoints));\n+      setPath(newPath);\n+\n+      // Update active path directly in DOM for better performance\n+      if (activePathRef.current) {\n+        activePathRef.current.setAttribute(\"d\", newPath);\n+      }\n+\n+      // Check for canvas expansion\n+      if (y > svgHeight - BUFFER_ZONE) {\n+        const newHeight = svgHeight + INCREMENT_HEIGHT;\n+        setSvgHeight(newHeight);\n+        updateAttributes({ height: newHeight });\n+      }\n+    }\n+  };\n+\n+  // Split paths into chunks for better rendering\n+  const chunkedLines = useMemo(() => {\n+    const chunkSize = 100; // Adjust based on performance needs\n+    const chunks = [];\n+    for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n+      chunks.push(linesRef.current.slice(i, i + chunkSize));\n+    }\n+    return chunks;\n+  }, [linesRef.current.length]);\n+\n+  const adjustColorForMode = (color) => {\n+    if (isDarkMode) {\n+      // Dark mode: Black turns to white; other colors unchanged\n+      return color === \"#000000\" ? \"#FFFFFF\" : color;\n+    } else {\n+      // Light mode: White turns to black; other colors unchanged\n+      return color === \"#FFFFFF\" ? \"#000000\" : color;\n+    }\n+  };\n+\n+  // Optimize path rendering\n+  const renderPaths = () =>\n+    chunkedLines.map((chunk, chunkIndex) => (\n+      <g key={`chunk-${chunkIndex}`}>\n+        {chunk.map((item) => (\n+          <path\n+            key={`${item.id}-${item.color}-${item.size}`}\n+            d={item.path}\n+            stroke={adjustColorForMode(item.color)}\n+            strokeWidth={item.size}\n+            opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n+            fill=\"none\"\n+            vectorEffect=\"non-scaling-stroke\"\n+          />\n+        ))}\n+      </g>\n+    ));\n+\n+  // Optimize save drawing function\n+  const saveDrawing = () => {\n+    if (!path) return;\n+\n+    const newLine = { id: uuid(), path, color, size, tool };\n+    linesRef.current = [...linesRef.current, newLine];\n+\n+    setHistory((prevHistory) => [\n+      ...prevHistory,\n+      { action: \"add\", line: newLine },\n+    ]);\n+\n+    setRedoStack([]);\n+    batchUpdatePaths();\n+  };\n+\n+  return (\n+    <div className=\"draw w-full min-h-screen flex flex-col\">\n+      {/* Top Toolbar */}\n+      <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n+        {/* Left side controls */}\n+        <div className=\"flex items-center space-x-2\">\n+          <button\n+            onClick={() => {\n+              setTool(\"pencil\");\n+              setColor(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n+            }}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-2 border ${\n+              tool === \"pencil\"\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n+                : \"border-gray-300 dark:border-neutral-600\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <Icons.BallPenLine className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={() => {\n+              setTool(\"highlighter\");\n+              setColor(\"#FFFF00\");\n+            }}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-2 border ${\n+              tool === \"highlighter\"\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n+                : \"border-gray-300 dark:border-neutral-600\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <Icons.MarkPenLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={() => setTool(\"erase\")}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-2 border ${\n+              tool === \"erase\"\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n+                : \"border-gray-300 dark:border-neutral-600\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <Icons.EraserLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <div className=\"relative\">\n+            <select\n+              className=\"border border-neutral-300 dark:border-neutral-600 rounded w-full p-2 text-neutral-800 bg-[#F8F8F7] dark:bg-[#2D2C2C] dark:text-[color:var(--selected-dark-text)] outline-none appearance-none mr-6\"\n+              value={background}\n+              onChange={handleBackgroundChange}\n+            >\n+              <option value=\"none\">None</option>\n+              <option value=\"grid\">Grid</option>\n+              <option value=\"ruled\">Ruled</option>\n+              <option value=\"dotted\">Dotted</option>\n+            </select>\n+            <Icons.ArrowDownSLineIcon className=\"dark:text-[color:var(--selected-dark-text)] ri-arrow-down-s-line absolute right-3 top-1/2 transform -translate-y-1/2 text-neutral-600 pointer-events-none\" />\n+          </div>\n+        </div>\n+        {/* Right side controls */}\n+        <div className=\"flex items-center space-x-2\">\n+          <button\n+            onClick={undo}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n+          >\n+            <Icons.ArrowGoBackLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={redo}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n+          >\n+            <Icons.ArrowGoForwardLineIcon className=\"w-6 h-6\" />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thin)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thin\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"3\"\n+              height=\"3\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.medium)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.medium\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"4\"\n+              height=\"4\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thick)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thick\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"5\"\n+              height=\"5\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thicker)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thicker\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"6\"\n+              height=\"6\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <button\n+            onClick={() => setSize(thicknessOptions.thickest)}\n+            onMouseDown={(e) => e.preventDefault()}\n+            className={`flex items-center justify-center p-1 border ${\n+              size === thicknessOptions.thickest\n+                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n+                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n+            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+          >\n+            <svg\n+              width=\"7\"\n+              height=\"7\"\n+              className=\"rounded-full\"\n+              style={{ backgroundColor: color }}\n+            />\n+          </button>\n+          <div className=\"relative inline-block\">\n+            {/* Hidden color input */}\n+            <input\n+              type=\"color\"\n+              value={color}\n+              onChange={handleColorChange}\n+              ref={colorInputRef}\n+              className=\"absolute inset-0 opacity-0 cursor-pointer\"\n+            />\n+            {/* Custom button */}\n+            <button\n+              onClick={openColorPicker}\n+              style={{ backgroundColor: color }}\n+              className={`flex items-center justify-center p-1 h-10 w-10 rounded-full hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n+            />\n+          </div>\n+          <button\n+            onClick={onClose}\n+            className=\"p-2 rounded-full bg-gray-100 dark:bg-neutral-800 hover:bg-gray-200 dark:hover:bg-neutral-700 transition-colors\"\n+          >\n+            <Icons.CloseLineIcon className=\"w-6 h-6\" />\n+          </button>\n+        </div>\n+      </div>\n+\n+      {/* SVG Container */}\n+      <div className=\"relative flex-grow drawing-container\">\n+        <svg\n+          ref={svgRef}\n+          viewBox={`0 0 ${svgWidth} ${svgHeight}`}\n+          preserveAspectRatio=\"xMidYMid meet\"\n+          className={`w-full h-auto ${background} bg-neutral-100 dark:bg-neutral-800`}\n+        >\n+          <g ref={pathsGroupRef}>{renderPaths()}</g>\n+          {path && (\n+            <path\n+              ref={activePathRef}\n+              d={path}\n+              stroke={adjustColorForMode(color)}\n+              strokeWidth={size}\n+              opacity={tool === \"highlighter\" ? 0.3 : 1}\n+              fill=\"none\"\n+              vectorEffect=\"non-scaling-stroke\"\n+            />\n+          )}\n+        </svg>\n+      </div>\n+    </div>\n+  );\n+};\n+\n+export default DrawMode;\n"
                },
                {
                    "date": 1732175758911,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n import React from \"react\";\n-import { useDrawLogic } from \"./useDrawLogic\";\n+import { useDrawLogic } from \"./drawUtils\";\n import { Keyboard } from \"@capacitor/keyboard\";\n import Icons from \"../../../remixicon-react\";\n \n const DrawMode = ({ onClose, updateAttributes, node }) => {\n@@ -547,598 +547,4 @@\n   );\n };\n \n export default DrawMode;\n-import React from \"react\";\n-import { useDrawLogic } from \"./useDrawLogic\";\n-import { Keyboard } from \"@capacitor/keyboard\";\n-import Icons from \"../../../remixicon-react\";\n-\n-const DrawMode = ({ onClose, updateAttributes, node }) => {\n-  const {\n-    isDrawing,\n-    svgRef,\n-    path,\n-    color,\n-    size,\n-    tool,\n-    svgHeight,\n-    svgWidth,\n-    setColor,\n-    setSize,\n-    setTool,\n-    undo,\n-    redo,\n-    startDrawing,\n-    draw,\n-    stopDrawing,\n-  } = useDrawLogic(node, updateAttributes);\n-\n-  const linesRef = useRef(node.attrs.lines || []);\n-\n-  const handleBackgroundChange = (event) => {\n-    const newBackground = event.target.value;\n-    setBackground(newBackground);\n-    updateAttributes({ paperType: newBackground });\n-  };\n-\n-  useEffect(() => {\n-    const svg = d3.select(svgRef.current);\n-    const eraseRadius = 5;\n-    let isErasing = false;\n-    let penActive = false;\n-    let penTimeout = null;\n-\n-    const PEN_TIMEOUT_DURATION = 700;\n-\n-    const handlePointerEvent = (event) => {\n-      if (event.pointerType === \"pen\") {\n-        penActive = true;\n-        clearTimeout(penTimeout);\n-        event.preventDefault(); // Prevent touch interaction when pen is active\n-        event.stopPropagation();\n-\n-        const [x, y] = getPointerCoordinates(event);\n-\n-        if (event.type === \"pointerdown\") {\n-          if (tool === \"erase\") {\n-            isErasing = true;\n-            eraseOverlappingPaths(x, y);\n-          } else {\n-            startDrawing(x, y);\n-          }\n-        } else if (event.type === \"pointermove\") {\n-          if (tool === \"erase\" && isErasing) {\n-            eraseOverlappingPaths(x, y);\n-          } else if (tool !== \"erase\") {\n-            draw(x, y);\n-          }\n-        } else if (event.type === \"pointerup\") {\n-          if (tool === \"erase\") {\n-            isErasing = false;\n-          } else {\n-            stopDrawing();\n-          }\n-\n-          penTimeout = setTimeout(() => {\n-            penActive = false;\n-          }, PEN_TIMEOUT_DURATION);\n-        }\n-      }\n-    };\n-\n-    const eraseOverlappingPaths = (x, y) => {\n-      const eraserArea = {\n-        x: x - eraseRadius,\n-        y: y - eraseRadius,\n-        width: eraseRadius * 2,\n-        height: eraseRadius * 2,\n-      };\n-\n-      svg.selectAll(\"path\").each(function () {\n-        const path = d3.select(this);\n-        const pathNode = path.node();\n-        const pathBBox = pathNode.getBBox();\n-\n-        if (\n-          pathBBox.x < eraserArea.x + eraserArea.width &&\n-          pathBBox.x + pathBBox.width > eraserArea.x &&\n-          pathBBox.y < eraserArea.y + eraserArea.height &&\n-          pathBBox.y + pathBBox.height > eraserArea.y\n-        ) {\n-          deletePath(pathNode);\n-        }\n-      });\n-    };\n-\n-    // Prevent scrolling when the pencil (pen) is active\n-    const preventScrolling = (event) => {\n-      if (penActive) {\n-        event.preventDefault(); // Prevent scrolling\n-        event.stopPropagation();\n-      }\n-    };\n-\n-    // Attach pen input handlers on SVG\n-    svg\n-      .on(\"pointerdown\", handlePointerEvent)\n-      .on(\"pointermove\", handlePointerEvent)\n-      .on(\"pointerup\", handlePointerEvent);\n-\n-    // Block touch interactions (scrolling) when pen is active\n-    document.body.addEventListener(\"touchstart\", preventScrolling, {\n-      passive: false,\n-    });\n-    document.body.addEventListener(\"touchmove\", preventScrolling, {\n-      passive: false,\n-    });\n-    document.body.addEventListener(\"touchend\", preventScrolling, {\n-      passive: false,\n-    });\n-\n-    // Cleanup on component unmount\n-    return () => {\n-      clearTimeout(penTimeout);\n-      document.body.removeEventListener(\"touchstart\", preventScrolling);\n-      document.body.removeEventListener(\"touchmove\", preventScrolling);\n-      document.body.removeEventListener(\"touchend\", preventScrolling);\n-    };\n-  }, [tool, color, size, points]);\n-\n-  const deletePath = (pathElement) => {\n-    const clickedPathData = pathElement.getAttribute(\"d\");\n-    const pathIndex = linesRef.current.findIndex(\n-      (line) => line.path === clickedPathData\n-    );\n-\n-    if (pathIndex !== -1) {\n-      const removedLine = linesRef.current[pathIndex];\n-\n-      // Save the deletion action\n-      setHistory((prevHistory) => [\n-        ...prevHistory,\n-        { action: \"delete\", line: removedLine },\n-      ]);\n-\n-      linesRef.current.splice(pathIndex, 1);\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n-  const handleMouseDown = (event) => {\n-    event.preventDefault();\n-  };\n-\n-  useEffect(() => {\n-    const disableScroll = (event) => {\n-      if (isDrawing) {\n-        event.preventDefault();\n-      }\n-    };\n-\n-    document.addEventListener(\"touchmove\", disableScroll, { passive: false });\n-    document.addEventListener(\"wheel\", disableScroll, { passive: false });\n-\n-    return () => {\n-      document.removeEventListener(\"touchmove\", disableScroll);\n-      document.removeEventListener(\"wheel\", disableScroll);\n-    };\n-  }, [isDrawing]);\n-\n-  const getPointerCoordinates = (event) => {\n-    const svg = svgRef.current;\n-    const rect = svg.getBoundingClientRect();\n-\n-    // Get the correct pointer position, including page scroll and scale\n-    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n-    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n-\n-    // Calculate the mouse position relative to the SVG\n-    const scaleX = svg.viewBox.baseVal.width / rect.width;\n-    const scaleY = svg.viewBox.baseVal.height / rect.height;\n-\n-    const x = (clientX - rect.left) * scaleX;\n-    const y = (clientY - rect.top) * scaleY;\n-\n-    return [x, y];\n-  };\n-\n-  const startDrawing = (x, y) => {\n-    setDrawing(true);\n-    setPoints([{ x, y }]);\n-  };\n-\n-  const draw = (x, y) => {\n-    if (!drawing) return;\n-\n-    const newPoints = [...points, { x, y }];\n-    setPoints(newPoints);\n-    const newPath = lineGenerator(newPoints);\n-    setPath(newPath);\n-    if (y > svgHeight - BUFFER_ZONE) {\n-      const newHeight = svgHeight + INCREMENT_HEIGHT;\n-      setSvgHeight(newHeight);\n-      updateAttributes({ height: newHeight });\n-\n-      // Adjust scroll position to keep the drawing point in view\n-      const container = containerRef.current;\n-      if (container) {\n-        const scrollContainer = container.closest(\".drawing-component\");\n-        if (scrollContainer) {\n-          scrollContainer.scrollTo({\n-            top: scrollContainer.scrollHeight,\n-            behavior: \"smooth\",\n-          });\n-        }\n-      }\n-    }\n-  };\n-\n-  const stopDrawing = () => {\n-    if (drawing) {\n-      setDrawing(false);\n-      saveDrawing();\n-      setHistory((prevHistory) => [\n-        ...prevHistory,\n-        { id, path, color, size, tool },\n-      ]);\n-      setPath(\"\");\n-      setPoints([]);\n-    }\n-  };\n-\n-  const handleColorChange = (e) => {\n-    setColor(e.target.value);\n-  };\n-\n-  const openColorPicker = () => {\n-    colorInputRef.current.click();\n-  };\n-\n-  const saveHeight = () => {\n-    updateAttributes({ height: svgHeight });\n-  };\n-\n-  useEffect(() => {\n-    const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n-      Keyboard.hide();\n-    });\n-\n-    return () => {\n-      showListener.remove();\n-    };\n-  }, []);\n-\n-  const pathsGroupRef = useRef(null);\n-  const activePathRef = useRef(null);\n-  const throttleRef = useRef(null);\n-  const batchUpdateTimeoutRef = useRef(null);\n-\n-  // Memoize the line generator to prevent recreation\n-  const lineGenerator = useMemo(\n-    () =>\n-      d3\n-        .line()\n-        .x((d) => d.x)\n-        .y((d) => d.y)\n-        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n-    []\n-  );\n-\n-  const smoothPoints = (points) => {\n-    if (points.length < 3) return points;\n-    return points.map((point, i, arr) => {\n-      if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n-      const prev = arr[i - 1];\n-      const next = arr[i + 1];\n-      return {\n-        x: (prev.x + point.x + next.x) / 3,\n-        y: (prev.y + point.y + next.y) / 3,\n-      };\n-    });\n-  };\n-\n-  // Batch update function for paths\n-  const batchUpdatePaths = () => {\n-    if (batchUpdateTimeoutRef.current) {\n-      clearTimeout(batchUpdateTimeoutRef.current);\n-    }\n-\n-    batchUpdateTimeoutRef.current = setTimeout(() => {\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }, 500); // Adjust timeout as needed\n-  };\n-\n-  // Throttle draw function\n-  const throttledDraw = (x, y) => {\n-    if (!throttleRef.current) {\n-      throttleRef.current = setTimeout(() => {\n-        throttleRef.current = null;\n-      }, 16); // ~60fps\n-\n-      if (!drawing) return;\n-\n-      const newPoints = [...points, { x, y }];\n-      setPoints(newPoints);\n-\n-      const newPath = lineGenerator(smoothPoints(newPoints));\n-      setPath(newPath);\n-\n-      // Update active path directly in DOM for better performance\n-      if (activePathRef.current) {\n-        activePathRef.current.setAttribute(\"d\", newPath);\n-      }\n-\n-      // Check for canvas expansion\n-      if (y > svgHeight - BUFFER_ZONE) {\n-        const newHeight = svgHeight + INCREMENT_HEIGHT;\n-        setSvgHeight(newHeight);\n-        updateAttributes({ height: newHeight });\n-      }\n-    }\n-  };\n-\n-  // Split paths into chunks for better rendering\n-  const chunkedLines = useMemo(() => {\n-    const chunkSize = 100; // Adjust based on performance needs\n-    const chunks = [];\n-    for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n-      chunks.push(linesRef.current.slice(i, i + chunkSize));\n-    }\n-    return chunks;\n-  }, [linesRef.current.length]);\n-\n-  const adjustColorForMode = (color) => {\n-    if (isDarkMode) {\n-      // Dark mode: Black turns to white; other colors unchanged\n-      return color === \"#000000\" ? \"#FFFFFF\" : color;\n-    } else {\n-      // Light mode: White turns to black; other colors unchanged\n-      return color === \"#FFFFFF\" ? \"#000000\" : color;\n-    }\n-  };\n-\n-  // Optimize path rendering\n-  const renderPaths = () =>\n-    chunkedLines.map((chunk, chunkIndex) => (\n-      <g key={`chunk-${chunkIndex}`}>\n-        {chunk.map((item) => (\n-          <path\n-            key={`${item.id}-${item.color}-${item.size}`}\n-            d={item.path}\n-            stroke={adjustColorForMode(item.color)}\n-            strokeWidth={item.size}\n-            opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n-            fill=\"none\"\n-            vectorEffect=\"non-scaling-stroke\"\n-          />\n-        ))}\n-      </g>\n-    ));\n-\n-  // Optimize save drawing function\n-  const saveDrawing = () => {\n-    if (!path) return;\n-\n-    const newLine = { id: uuid(), path, color, size, tool };\n-    linesRef.current = [...linesRef.current, newLine];\n-\n-    setHistory((prevHistory) => [\n-      ...prevHistory,\n-      { action: \"add\", line: newLine },\n-    ]);\n-\n-    setRedoStack([]);\n-    batchUpdatePaths();\n-  };\n-\n-  return (\n-    <div className=\"draw w-full min-h-screen flex flex-col\">\n-      {/* Top Toolbar */}\n-      <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n-        {/* Left side controls */}\n-        <div className=\"flex items-center space-x-2\">\n-          <button\n-            onClick={() => {\n-              setTool(\"pencil\");\n-              setColor(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n-            }}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-2 border ${\n-              tool === \"pencil\"\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n-                : \"border-gray-300 dark:border-neutral-600\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <Icons.BallPenLine className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={() => {\n-              setTool(\"highlighter\");\n-              setColor(\"#FFFF00\");\n-            }}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-2 border ${\n-              tool === \"highlighter\"\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n-                : \"border-gray-300 dark:border-neutral-600\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <Icons.MarkPenLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={() => setTool(\"erase\")}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-2 border ${\n-              tool === \"erase\"\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n-                : \"border-gray-300 dark:border-neutral-600\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <Icons.EraserLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <div className=\"relative\">\n-            <select\n-              className=\"border border-neutral-300 dark:border-neutral-600 rounded w-full p-2 text-neutral-800 bg-[#F8F8F7] dark:bg-[#2D2C2C] dark:text-[color:var(--selected-dark-text)] outline-none appearance-none mr-6\"\n-              value={background}\n-              onChange={handleBackgroundChange}\n-            >\n-              <option value=\"none\">None</option>\n-              <option value=\"grid\">Grid</option>\n-              <option value=\"ruled\">Ruled</option>\n-              <option value=\"dotted\">Dotted</option>\n-            </select>\n-            <Icons.ArrowDownSLineIcon className=\"dark:text-[color:var(--selected-dark-text)] ri-arrow-down-s-line absolute right-3 top-1/2 transform -translate-y-1/2 text-neutral-600 pointer-events-none\" />\n-          </div>\n-        </div>\n-        {/* Right side controls */}\n-        <div className=\"flex items-center space-x-2\">\n-          <button\n-            onClick={undo}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n-          >\n-            <Icons.ArrowGoBackLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={redo}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n-          >\n-            <Icons.ArrowGoForwardLineIcon className=\"w-6 h-6\" />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thin)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thin\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"3\"\n-              height=\"3\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.medium)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.medium\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"4\"\n-              height=\"4\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thick)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thick\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"5\"\n-              height=\"5\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thicker)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thicker\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"6\"\n-              height=\"6\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <button\n-            onClick={() => setSize(thicknessOptions.thickest)}\n-            onMouseDown={(e) => e.preventDefault()}\n-            className={`flex items-center justify-center p-1 border ${\n-              size === thicknessOptions.thickest\n-                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n-                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n-            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-          >\n-            <svg\n-              width=\"7\"\n-              height=\"7\"\n-              className=\"rounded-full\"\n-              style={{ backgroundColor: color }}\n-            />\n-          </button>\n-          <div className=\"relative inline-block\">\n-            {/* Hidden color input */}\n-            <input\n-              type=\"color\"\n-              value={color}\n-              onChange={handleColorChange}\n-              ref={colorInputRef}\n-              className=\"absolute inset-0 opacity-0 cursor-pointer\"\n-            />\n-            {/* Custom button */}\n-            <button\n-              onClick={openColorPicker}\n-              style={{ backgroundColor: color }}\n-              className={`flex items-center justify-center p-1 h-10 w-10 rounded-full hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n-            />\n-          </div>\n-          <button\n-            onClick={onClose}\n-            className=\"p-2 rounded-full bg-gray-100 dark:bg-neutral-800 hover:bg-gray-200 dark:hover:bg-neutral-700 transition-colors\"\n-          >\n-            <Icons.CloseLineIcon className=\"w-6 h-6\" />\n-          </button>\n-        </div>\n-      </div>\n-\n-      {/* SVG Container */}\n-      <div className=\"relative flex-grow drawing-container\">\n-        <svg\n-          ref={svgRef}\n-          viewBox={`0 0 ${svgWidth} ${svgHeight}`}\n-          preserveAspectRatio=\"xMidYMid meet\"\n-          className={`w-full h-auto ${background} bg-neutral-100 dark:bg-neutral-800`}\n-        >\n-          <g ref={pathsGroupRef}>{renderPaths()}</g>\n-          {path && (\n-            <path\n-              ref={activePathRef}\n-              d={path}\n-              stroke={adjustColorForMode(color)}\n-              strokeWidth={size}\n-              opacity={tool === \"highlighter\" ? 0.3 : 1}\n-              fill=\"none\"\n-              vectorEffect=\"non-scaling-stroke\"\n-            />\n-          )}\n-        </svg>\n-      </div>\n-    </div>\n-  );\n-};\n-\n-export default DrawMode;\n"
                },
                {
                    "date": 1732175769703,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,28 +1,55 @@\n-import React from \"react\";\n-import { useDrawLogic } from \"./drawUtils\";\n+import React, { useState, useRef, useEffect, useMemo } from \"react\";\n+import * as d3 from \"d3\";\n+import { v4 as uuid } from \"uuid\";\n import { Keyboard } from \"@capacitor/keyboard\";\n import Icons from \"../../../remixicon-react\";\n \n+const thicknessOptions = {\n+  thin: 2,\n+  medium: 3,\n+  thick: 4,\n+  thicker: 5,\n+  thickest: 6,\n+};\n+\n+const backgroundStyles = {\n+  none: \"\",\n+  grid: \"grid\",\n+  ruled: \"ruled\",\n+  dotted: \"dotted\",\n+};\n+\n+const BUFFER_ZONE = 50;\n+const INCREMENT_HEIGHT = 200;\n+const PREVIEW_HEIGHT = 500;\n+\n const DrawMode = ({ onClose, updateAttributes, node }) => {\n-  const {\n-    isDrawing,\n-    svgRef,\n-    path,\n-    color,\n-    size,\n-    tool,\n-    svgHeight,\n-    svgWidth,\n-    setColor,\n-    setSize,\n-    setTool,\n-    undo,\n-    redo,\n-    startDrawing,\n-    draw,\n-    stopDrawing,\n-  } = useDrawLogic(node, updateAttributes);\n+  const isDarkMode = document.documentElement.classList.contains(\"dark\");\n+  const [isDrawing, setIsDrawing] = useState(false);\n+  const [drawingPath, setDrawingPath] = useState(\"\");\n+  const [lines, setLines] = useState([]);\n+  const pointsRef = useRef([]);\n+  const historyRef = useRef([]);\n+  const redoStackRef = useRef([]);\n+  const svgRef = useRef(null);\n+  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n+  const [size, setSize] = useState(thicknessOptions.thin);\n+  const [drawing, setDrawing] = useState(false);\n+  const [points, setPoints] = useState([]);\n+  const [path, setPath] = useState(\"\");\n+  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n+  const [svgWidth] = useState(500);\n+  const [tool, setTool] = useState(\"pencil\");\n+  const [history, setHistory] = useState([]);\n+  const [redoStack, setRedoStack] = useState([]);\n+  const [isResizing, setIsResizing] = useState(false);\n+  const [startY, setStartY] = useState(0);\n+  const [id] = useState(() => node.attrs.id || uuid());\n+  const colorInputRef = useRef(null);\n+  const [background, setBackground] = useState(\n+    node.attrs.paperType || backgroundStyles.none\n+  );\n \n   const linesRef = useRef(node.attrs.lines || []);\n \n   const handleBackgroundChange = (event) => {\n@@ -158,9 +185,8 @@\n \n   const handleMouseDown = (event) => {\n     event.preventDefault();\n   };\n-\n   useEffect(() => {\n     const disableScroll = (event) => {\n       if (isDrawing) {\n         event.preventDefault();\n@@ -175,8 +201,51 @@\n       document.removeEventListener(\"wheel\", disableScroll);\n     };\n   }, [isDrawing]);\n \n+  useEffect(() => {\n+    const handleMouseMove = (event) => {\n+      if (isResizing) {\n+        const currentY =\n+          event.clientY || (event.touches && event.touches[0].clientY);\n+        const deltaY = currentY - startY;\n+        setSvgHeight((prevHeight) => {\n+          const newHeight = Math.max(\n+            MIN_HEIGHT,\n+            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n+          );\n+          return newHeight;\n+        });\n+        setStartY(currentY);\n+      }\n+    };\n+\n+    const handleMouseUp = () => {\n+      if (isResizing) {\n+        setIsResizing(false);\n+        document.removeEventListener(\"mousemove\", handleMouseMove);\n+        document.removeEventListener(\"mouseup\", handleMouseUp);\n+        document.removeEventListener(\"touchmove\", handleMouseMove);\n+        document.removeEventListener(\"touchend\", handleMouseUp);\n+        saveHeight();\n+      }\n+    };\n+\n+    if (isResizing) {\n+      document.addEventListener(\"mousemove\", handleMouseMove);\n+      document.addEventListener(\"mouseup\", handleMouseUp);\n+      document.addEventListener(\"touchmove\", handleMouseMove);\n+      document.addEventListener(\"touchend\", handleMouseUp);\n+    }\n+\n+    return () => {\n+      document.removeEventListener(\"mousemove\", handleMouseMove);\n+      document.removeEventListener(\"mouseup\", handleMouseUp);\n+      document.removeEventListener(\"touchmove\", handleMouseMove);\n+      document.removeEventListener(\"touchend\", handleMouseUp);\n+    };\n+  }, [isResizing, startY]);\n+\n   const getPointerCoordinates = (event) => {\n     const svg = svgRef.current;\n     const rect = svg.getBoundingClientRect();\n \n@@ -193,16 +262,105 @@\n \n     return [x, y];\n   };\n \n+  const startDrawing = (x, y) => {\n+    setDrawing(true);\n+    setPoints([{ x, y }]);\n+  };\n+\n+  const draw = (x, y) => {\n+    if (!drawing) return;\n+\n+    const newPoints = [...points, { x, y }];\n+    setPoints(newPoints);\n+    const newPath = lineGenerator(newPoints);\n+    setPath(newPath);\n+    if (y > svgHeight - BUFFER_ZONE) {\n+      const newHeight = svgHeight + INCREMENT_HEIGHT;\n+      setSvgHeight(newHeight);\n+      updateAttributes({ height: newHeight });\n+\n+      // Adjust scroll position to keep the drawing point in view\n+      const container = containerRef.current;\n+      if (container) {\n+        const scrollContainer = container.closest(\".drawing-component\");\n+        if (scrollContainer) {\n+          scrollContainer.scrollTo({\n+            top: scrollContainer.scrollHeight,\n+            behavior: \"smooth\",\n+          });\n+        }\n+      }\n+    }\n+  };\n+\n+  const stopDrawing = () => {\n+    if (drawing) {\n+      setDrawing(false);\n+      saveDrawing();\n+      setHistory((prevHistory) => [\n+        ...prevHistory,\n+        { id, path, color, size, tool },\n+      ]);\n+      setPath(\"\");\n+      setPoints([]);\n+    }\n+  };\n+\n   const handleColorChange = (e) => {\n     setColor(e.target.value);\n   };\n \n   const openColorPicker = () => {\n     colorInputRef.current.click();\n   };\n \n+  // Store only actions in history (add or delete)\n+  const undo = () => {\n+    if (history.length > 0) {\n+      const lastAction = history[history.length - 1];\n+      setHistory((prevHistory) => prevHistory.slice(0, -1));\n+      setRedoStack((prevStack) => [...prevStack, lastAction]);\n+\n+      if (lastAction.action === \"add\") {\n+        // Undo adding a line by removing it\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastAction.line.id\n+        );\n+      } else if (lastAction.action === \"delete\") {\n+        // Undo deleting a line by adding it back\n+        linesRef.current = [...linesRef.current, lastAction.line];\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const redo = () => {\n+    if (redoStack.length > 0) {\n+      const lastRedo = redoStack[redoStack.length - 1];\n+      setRedoStack((prevStack) => prevStack.slice(0, -1));\n+      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n+\n+      if (lastRedo.action === \"add\") {\n+        // Redo adding a line by adding it back\n+        linesRef.current = [...linesRef.current, lastRedo.line];\n+      } else if (lastRedo.action === \"delete\") {\n+        // Redo deleting a line by removing it again\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastRedo.line.id\n+        );\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n   const saveHeight = () => {\n     updateAttributes({ height: svgHeight });\n   };\n \n"
                },
                {
                    "date": 1732175783876,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -185,8 +185,9 @@\n \n   const handleMouseDown = (event) => {\n     event.preventDefault();\n   };\n+\n   useEffect(() => {\n     const disableScroll = (event) => {\n       if (isDrawing) {\n         event.preventDefault();\n@@ -201,51 +202,8 @@\n       document.removeEventListener(\"wheel\", disableScroll);\n     };\n   }, [isDrawing]);\n \n-  useEffect(() => {\n-    const handleMouseMove = (event) => {\n-      if (isResizing) {\n-        const currentY =\n-          event.clientY || (event.touches && event.touches[0].clientY);\n-        const deltaY = currentY - startY;\n-        setSvgHeight((prevHeight) => {\n-          const newHeight = Math.max(\n-            MIN_HEIGHT,\n-            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n-          );\n-          return newHeight;\n-        });\n-        setStartY(currentY);\n-      }\n-    };\n-\n-    const handleMouseUp = () => {\n-      if (isResizing) {\n-        setIsResizing(false);\n-        document.removeEventListener(\"mousemove\", handleMouseMove);\n-        document.removeEventListener(\"mouseup\", handleMouseUp);\n-        document.removeEventListener(\"touchmove\", handleMouseMove);\n-        document.removeEventListener(\"touchend\", handleMouseUp);\n-        saveHeight();\n-      }\n-    };\n-\n-    if (isResizing) {\n-      document.addEventListener(\"mousemove\", handleMouseMove);\n-      document.addEventListener(\"mouseup\", handleMouseUp);\n-      document.addEventListener(\"touchmove\", handleMouseMove);\n-      document.addEventListener(\"touchend\", handleMouseUp);\n-    }\n-\n-    return () => {\n-      document.removeEventListener(\"mousemove\", handleMouseMove);\n-      document.removeEventListener(\"mouseup\", handleMouseUp);\n-      document.removeEventListener(\"touchmove\", handleMouseMove);\n-      document.removeEventListener(\"touchend\", handleMouseUp);\n-    };\n-  }, [isResizing, startY]);\n-\n   const getPointerCoordinates = (event) => {\n     const svg = svgRef.current;\n     const rect = svg.getBoundingClientRect();\n \n"
                }
            ],
            "date": 1731678443885,
            "name": "Commit-0",
            "content": "import React, { useState, useRef, useEffect, useMemo } from \"react\";\nimport * as d3 from \"d3\";\nimport { v4 as uuid } from \"uuid\";\nimport { Keyboard } from \"@capacitor/keyboard\";\nimport Icons from \"../../../remixicon-react\";\n\nconst thicknessOptions = {\n  thin: 2,\n  medium: 3,\n  thick: 4,\n  thicker: 5,\n  thickest: 6,\n};\n\nconst backgroundStyles = {\n  none: \"\",\n  grid: \"grid\",\n  ruled: \"ruled\",\n  dotted: \"dotted\",\n};\n\nconst BUFFER_ZONE = 50;\nconst INCREMENT_HEIGHT = 200;\nconst PREVIEW_HEIGHT = 500;\n\nconst DrawMode = ({ onClose, updateAttributes, node }) => {\n  const isDarkMode = document.documentElement.classList.contains(\"dark\");\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [drawingPath, setDrawingPath] = useState(\"\");\n  const [lines, setLines] = useState([]);\n  const pointsRef = useRef([]);\n  const historyRef = useRef([]);\n  const redoStackRef = useRef([]);\n  const svgRef = useRef(null);\n  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n  const [size, setSize] = useState(thicknessOptions.thin);\n  const [drawing, setDrawing] = useState(false);\n  const [points, setPoints] = useState([]);\n  const [path, setPath] = useState(\"\");\n  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n  const [svgWidth] = useState(500);\n  const [tool, setTool] = useState(\"pencil\");\n  const [history, setHistory] = useState([]);\n  const [redoStack, setRedoStack] = useState([]);\n  const [isResizing, setIsResizing] = useState(false);\n  const [startY, setStartY] = useState(0);\n  const [id] = useState(() => node.attrs.id || uuid());\n  const colorInputRef = useRef(null);\n  const [background, setBackground] = useState(\n    node.attrs.paperType || backgroundStyles.none\n  );\n\n  const linesRef = useRef(node.attrs.lines || []);\n\n  const handleBackgroundChange = (event) => {\n    const newBackground = event.target.value;\n    setBackground(newBackground);\n    updateAttributes({ paperType: newBackground });\n  };\n\n  useEffect(() => {\n    const svg = d3.select(svgRef.current);\n    const eraseRadius = 5;\n    let isErasing = false;\n    let penActive = false;\n    let penTimeout = null;\n\n    const PEN_TIMEOUT_DURATION = 700;\n\n    const handlePointerEvent = (event) => {\n      if (event.pointerType === \"pen\") {\n        penActive = true;\n        clearTimeout(penTimeout);\n        event.preventDefault(); // Prevent touch interaction when pen is active\n        event.stopPropagation();\n\n        const [x, y] = getPointerCoordinates(event);\n\n        if (event.type === \"pointerdown\") {\n          if (tool === \"erase\") {\n            isErasing = true;\n            eraseOverlappingPaths(x, y);\n          } else {\n            startDrawing(x, y);\n          }\n        } else if (event.type === \"pointermove\") {\n          if (tool === \"erase\" && isErasing) {\n            eraseOverlappingPaths(x, y);\n          } else if (tool !== \"erase\") {\n            draw(x, y);\n          }\n        } else if (event.type === \"pointerup\") {\n          if (tool === \"erase\") {\n            isErasing = false;\n          } else {\n            stopDrawing();\n          }\n\n          penTimeout = setTimeout(() => {\n            penActive = false;\n          }, PEN_TIMEOUT_DURATION);\n        }\n      }\n    };\n\n    const eraseOverlappingPaths = (x, y) => {\n      const eraserArea = {\n        x: x - eraseRadius,\n        y: y - eraseRadius,\n        width: eraseRadius * 2,\n        height: eraseRadius * 2,\n      };\n\n      svg.selectAll(\"path\").each(function () {\n        const path = d3.select(this);\n        const pathNode = path.node();\n        const pathBBox = pathNode.getBBox();\n\n        if (\n          pathBBox.x < eraserArea.x + eraserArea.width &&\n          pathBBox.x + pathBBox.width > eraserArea.x &&\n          pathBBox.y < eraserArea.y + eraserArea.height &&\n          pathBBox.y + pathBBox.height > eraserArea.y\n        ) {\n          deletePath(pathNode);\n        }\n      });\n    };\n\n    // Prevent scrolling when the pencil (pen) is active\n    const preventScrolling = (event) => {\n      if (penActive) {\n        event.preventDefault(); // Prevent scrolling\n        event.stopPropagation();\n      }\n    };\n\n    // Attach pen input handlers on SVG\n    svg\n      .on(\"pointerdown\", handlePointerEvent)\n      .on(\"pointermove\", handlePointerEvent)\n      .on(\"pointerup\", handlePointerEvent);\n\n    // Block touch interactions (scrolling) when pen is active\n    document.body.addEventListener(\"touchstart\", preventScrolling, {\n      passive: false,\n    });\n    document.body.addEventListener(\"touchmove\", preventScrolling, {\n      passive: false,\n    });\n    document.body.addEventListener(\"touchend\", preventScrolling, {\n      passive: false,\n    });\n\n    // Suppress context menu (e.g., copy/paste menu) on pen input\n    svg.on(\"contextmenu\", (event) => {\n      if (penActive) {\n        event.preventDefault();\n      }\n    });\n\n    // Cleanup on component unmount\n    return () => {\n      clearTimeout(penTimeout);\n      document.body.removeEventListener(\"touchstart\", preventScrolling);\n      document.body.removeEventListener(\"touchmove\", preventScrolling);\n      document.body.removeEventListener(\"touchend\", preventScrolling);\n    };\n  }, [tool, color, size, points]);\n\n  const deletePath = (pathElement) => {\n    const clickedPathData = pathElement.getAttribute(\"d\");\n    const pathIndex = linesRef.current.findIndex(\n      (line) => line.path === clickedPathData\n    );\n\n    if (pathIndex !== -1) {\n      const removedLine = linesRef.current[pathIndex];\n\n      // Save the deletion action\n      setHistory((prevHistory) => [\n        ...prevHistory,\n        { action: \"delete\", line: removedLine },\n      ]);\n\n      linesRef.current.splice(pathIndex, 1);\n      updateAttributes({\n        lines: linesRef.current,\n      });\n    }\n  };\n\n  const handleMouseDown = (event) => {\n    event.preventDefault();\n  };\n\n  useEffect(() => {\n    const svg = svgRef.current;\n\n    const preventContextMenu = (event) => event.preventDefault();\n\n    svg.addEventListener(\"contextmenu\", preventContextMenu);\n\n    return () => {\n      svg.removeEventListener(\"contextmenu\", preventContextMenu);\n    };\n  }, []);\n\n  useEffect(() => {\n    const disableScroll = (event) => {\n      if (isDrawing) {\n        event.preventDefault();\n      }\n    };\n\n    document.addEventListener(\"touchmove\", disableScroll, { passive: false });\n    document.addEventListener(\"wheel\", disableScroll, { passive: false });\n\n    return () => {\n      document.removeEventListener(\"touchmove\", disableScroll);\n      document.removeEventListener(\"wheel\", disableScroll);\n    };\n  }, [isDrawing]);\n\n  useEffect(() => {\n    const handleMouseMove = (event) => {\n      if (isResizing) {\n        const currentY =\n          event.clientY || (event.touches && event.touches[0].clientY);\n        const deltaY = currentY - startY;\n        setSvgHeight((prevHeight) => {\n          const newHeight = Math.max(\n            MIN_HEIGHT,\n            Math.min(MAX_HEIGHT, prevHeight + deltaY)\n          );\n          return newHeight;\n        });\n        setStartY(currentY);\n      }\n    };\n\n    const handleMouseUp = () => {\n      if (isResizing) {\n        setIsResizing(false);\n        document.removeEventListener(\"mousemove\", handleMouseMove);\n        document.removeEventListener(\"mouseup\", handleMouseUp);\n        document.removeEventListener(\"touchmove\", handleMouseMove);\n        document.removeEventListener(\"touchend\", handleMouseUp);\n        saveHeight();\n      }\n    };\n\n    if (isResizing) {\n      document.addEventListener(\"mousemove\", handleMouseMove);\n      document.addEventListener(\"mouseup\", handleMouseUp);\n      document.addEventListener(\"touchmove\", handleMouseMove);\n      document.addEventListener(\"touchend\", handleMouseUp);\n    }\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n      document.removeEventListener(\"touchmove\", handleMouseMove);\n      document.removeEventListener(\"touchend\", handleMouseUp);\n    };\n  }, [isResizing, startY]);\n\n  const getPointerCoordinates = (event) => {\n    const svg = svgRef.current;\n    const rect = svg.getBoundingClientRect();\n\n    // Get the correct pointer position, including page scroll and scale\n    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n\n    // Calculate the mouse position relative to the SVG\n    const scaleX = svg.viewBox.baseVal.width / rect.width;\n    const scaleY = svg.viewBox.baseVal.height / rect.height;\n\n    const x = (clientX - rect.left) * scaleX;\n    const y = (clientY - rect.top) * scaleY;\n\n    return [x, y];\n  };\n\n  const startDrawing = (x, y) => {\n    setDrawing(true);\n    setPoints([{ x, y }]);\n  };\n\n  const draw = (x, y) => {\n    if (!drawing) return;\n\n    const newPoints = [...points, { x, y }];\n    setPoints(newPoints);\n    const newPath = lineGenerator(newPoints);\n    setPath(newPath);\n    if (y > svgHeight - BUFFER_ZONE) {\n      const newHeight = svgHeight + INCREMENT_HEIGHT;\n      setSvgHeight(newHeight);\n      updateAttributes({ height: newHeight });\n\n      // Adjust scroll position to keep the drawing point in view\n      const container = containerRef.current;\n      if (container) {\n        const scrollContainer = container.closest(\".drawing-component\");\n        if (scrollContainer) {\n          scrollContainer.scrollTo({\n            top: scrollContainer.scrollHeight,\n            behavior: \"smooth\",\n          });\n        }\n      }\n    }\n  };\n\n  const stopDrawing = () => {\n    if (drawing) {\n      setDrawing(false);\n      saveDrawing();\n      setHistory((prevHistory) => [\n        ...prevHistory,\n        { id, path, color, size, tool },\n      ]);\n      setPath(\"\");\n      setPoints([]);\n    }\n  };\n\n  const handleColorChange = (e) => {\n    setColor(e.target.value);\n  };\n\n  const openColorPicker = () => {\n    colorInputRef.current.click();\n  };\n\n  // Store only actions in history (add or delete)\n  const undo = () => {\n    if (history.length > 0) {\n      const lastAction = history[history.length - 1];\n      setHistory((prevHistory) => prevHistory.slice(0, -1));\n      setRedoStack((prevStack) => [...prevStack, lastAction]);\n\n      if (lastAction.action === \"add\") {\n        // Undo adding a line by removing it\n        linesRef.current = linesRef.current.filter(\n          (line) => line.id !== lastAction.line.id\n        );\n      } else if (lastAction.action === \"delete\") {\n        // Undo deleting a line by adding it back\n        linesRef.current = [...linesRef.current, lastAction.line];\n      }\n\n      updateAttributes({\n        lines: linesRef.current,\n      });\n    }\n  };\n\n  const redo = () => {\n    if (redoStack.length > 0) {\n      const lastRedo = redoStack[redoStack.length - 1];\n      setRedoStack((prevStack) => prevStack.slice(0, -1));\n      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n\n      if (lastRedo.action === \"add\") {\n        // Redo adding a line by adding it back\n        linesRef.current = [...linesRef.current, lastRedo.line];\n      } else if (lastRedo.action === \"delete\") {\n        // Redo deleting a line by removing it again\n        linesRef.current = linesRef.current.filter(\n          (line) => line.id !== lastRedo.line.id\n        );\n      }\n\n      updateAttributes({\n        lines: linesRef.current,\n      });\n    }\n  };\n\n  const saveHeight = () => {\n    updateAttributes({ height: svgHeight });\n  };\n\n  useEffect(() => {\n    const showListener = Keyboard.addListener(\"keyboardWillShow\", () => {\n      Keyboard.hide();\n    });\n\n    return () => {\n      showListener.remove();\n    };\n  }, []);\n\n  const pathsGroupRef = useRef(null);\n  const activePathRef = useRef(null);\n  const throttleRef = useRef(null);\n  const batchUpdateTimeoutRef = useRef(null);\n\n  // Memoize the line generator to prevent recreation\n  const lineGenerator = useMemo(\n    () =>\n      d3\n        .line()\n        .x((d) => d.x)\n        .y((d) => d.y)\n        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n    []\n  );\n\n  const smoothPoints = (points) => {\n    if (points.length < 3) return points;\n    return points.map((point, i, arr) => {\n      if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n      const prev = arr[i - 1];\n      const next = arr[i + 1];\n      return {\n        x: (prev.x + point.x + next.x) / 3,\n        y: (prev.y + point.y + next.y) / 3,\n      };\n    });\n  };\n\n  // Batch update function for paths\n  const batchUpdatePaths = () => {\n    if (batchUpdateTimeoutRef.current) {\n      clearTimeout(batchUpdateTimeoutRef.current);\n    }\n\n    batchUpdateTimeoutRef.current = setTimeout(() => {\n      updateAttributes({\n        lines: linesRef.current,\n      });\n    }, 500); // Adjust timeout as needed\n  };\n\n  // Throttle draw function\n  const throttledDraw = (x, y) => {\n    if (!throttleRef.current) {\n      throttleRef.current = setTimeout(() => {\n        throttleRef.current = null;\n      }, 16); // ~60fps\n\n      if (!drawing) return;\n\n      const newPoints = [...points, { x, y }];\n      setPoints(newPoints);\n\n      const newPath = lineGenerator(smoothPoints(newPoints));\n      setPath(newPath);\n\n      // Update active path directly in DOM for better performance\n      if (activePathRef.current) {\n        activePathRef.current.setAttribute(\"d\", newPath);\n      }\n\n      // Check for canvas expansion\n      if (y > svgHeight - BUFFER_ZONE) {\n        const newHeight = svgHeight + INCREMENT_HEIGHT;\n        setSvgHeight(newHeight);\n        updateAttributes({ height: newHeight });\n      }\n    }\n  };\n\n  // Split paths into chunks for better rendering\n  const chunkedLines = useMemo(() => {\n    const chunkSize = 100; // Adjust based on performance needs\n    const chunks = [];\n    for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n      chunks.push(linesRef.current.slice(i, i + chunkSize));\n    }\n    return chunks;\n  }, [linesRef.current.length]);\n\n  // Optimize path rendering\n  const renderPaths = () =>\n    chunkedLines.map((chunk, chunkIndex) => (\n      <g key={`chunk-${chunkIndex}`}>\n        {chunk.map((item) => (\n          <path\n            key={`${item.id}-${item.color}-${item.size}`}\n            d={item.path}\n            stroke={\n              isDarkMode\n                ? item.color === \"#FFFFFF\"\n                  ? \"#FFFFFF\" // White text for dark mode\n                  : item.color // Keep original color\n                : item.color === \"#FFFFFF\"\n                ? \"#000000\"\n                : item.color // Keep original color\n            }\n            strokeWidth={item.size}\n            opacity={item.tool === \"highlighter\" ? 0.3 : 1}\n            fill=\"none\"\n            vectorEffect=\"non-scaling-stroke\"\n          />\n        ))}\n      </g>\n    ));\n\n  // Optimize save drawing function\n  const saveDrawing = () => {\n    if (!path) return;\n\n    const newLine = { id: uuid(), path, color, size, tool };\n    linesRef.current = [...linesRef.current, newLine];\n\n    setHistory((prevHistory) => [\n      ...prevHistory,\n      { action: \"add\", line: newLine },\n    ]);\n\n    setRedoStack([]);\n    batchUpdatePaths();\n  };\n\n  return (\n    <div className=\"draw w-full min-h-screen flex flex-col\">\n      {/* Top Toolbar */}\n      <div className=\"mt-2 sticky top-0 z-10 p-4 flex justify-between items-center bg-gray-100 dark:bg-neutral-800 rounded-none shadow-md\">\n        {/* Left side controls */}\n        <div className=\"flex items-center space-x-2\">\n          <button\n            onClick={() => {\n              setTool(\"pencil\");\n            }}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-2 border ${\n              tool === \"pencil\"\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n                : \"border-gray-300 dark:border-neutral-600\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <Icons.BallPenLine className=\"w-6 h-6\" />\n          </button>\n          <button\n            onClick={() => {\n              setTool(\"highlighter\");\n              setColor(\"#FFFF00\");\n            }}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-2 border ${\n              tool === \"highlighter\"\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n                : \"border-gray-300 dark:border-neutral-600\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <Icons.MarkPenLineIcon className=\"w-6 h-6\" />\n          </button>\n          <button\n            onClick={() => setTool(\"erase\")}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-2 border ${\n              tool === \"erase\"\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700\"\n                : \"border-gray-300 dark:border-neutral-600\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <Icons.EraserLineIcon className=\"w-6 h-6\" />\n          </button>\n          <div className=\"relative\">\n            <select\n              className=\"border border-neutral-300 dark:border-neutral-600 rounded w-full p-2 text-neutral-800 bg-[#F8F8F7] dark:bg-[#2D2C2C] dark:text-[color:var(--selected-dark-text)] outline-none appearance-none mr-6\"\n              value={background}\n              onChange={handleBackgroundChange}\n            >\n              <option value=\"none\">None</option>\n              <option value=\"grid\">Grid</option>\n              <option value=\"ruled\">Ruled</option>\n              <option value=\"dotted\">Dotted</option>\n            </select>\n            <Icons.ArrowDownSLineIcon className=\"dark:text-[color:var(--selected-dark-text)] ri-arrow-down-s-line absolute right-3 top-1/2 transform -translate-y-1/2 text-neutral-600 pointer-events-none\" />\n          </div>\n        </div>\n        {/* Right side controls */}\n        <div className=\"flex items-center space-x-2\">\n          <button\n            onClick={undo}\n            onMouseDown={(e) => e.preventDefault()}\n            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n          >\n            <Icons.ArrowGoBackLineIcon className=\"w-6 h-6\" />\n          </button>\n          <button\n            onClick={redo}\n            onMouseDown={(e) => e.preventDefault()}\n            className=\"flex items-center justify-center p-2 border border-gray-300 dark:border-neutral-600 rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800\"\n          >\n            <Icons.ArrowGoForwardLineIcon className=\"w-6 h-6\" />\n          </button>\n          <button\n            onClick={() => setSize(thicknessOptions.thin)}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-1 border ${\n              size === thicknessOptions.thin\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <svg\n              width=\"3\"\n              height=\"3\"\n              className=\"rounded-full\"\n              style={{ backgroundColor: color }}\n            />\n          </button>\n          <button\n            onClick={() => setSize(thicknessOptions.medium)}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-1 border ${\n              size === thicknessOptions.medium\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <svg\n              width=\"4\"\n              height=\"4\"\n              className=\"rounded-full\"\n              style={{ backgroundColor: color }}\n            />\n          </button>\n          <button\n            onClick={() => setSize(thicknessOptions.thick)}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-1 border ${\n              size === thicknessOptions.thick\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <svg\n              width=\"5\"\n              height=\"5\"\n              className=\"rounded-full\"\n              style={{ backgroundColor: color }}\n            />\n          </button>\n          <button\n            onClick={() => setSize(thicknessOptions.thicker)}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-1 border ${\n              size === thicknessOptions.thicker\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <svg\n              width=\"6\"\n              height=\"6\"\n              className=\"rounded-full\"\n              style={{ backgroundColor: color }}\n            />\n          </button>\n          <button\n            onClick={() => setSize(thicknessOptions.thickest)}\n            onMouseDown={(e) => e.preventDefault()}\n            className={`flex items-center justify-center p-1 border ${\n              size === thicknessOptions.thickest\n                ? \"border-amber-400 bg-amber-100 dark:bg-amber-700 w-10 h-10\"\n                : \"border-gray-300 dark:border-neutral-600 h-10 w-10\"\n            } rounded hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n          >\n            <svg\n              width=\"7\"\n              height=\"7\"\n              className=\"rounded-full\"\n              style={{ backgroundColor: color }}\n            />\n          </button>\n          <div className=\"relative inline-block\">\n            {/* Hidden color input */}\n            <input\n              type=\"color\"\n              value={color}\n              onChange={handleColorChange}\n              ref={colorInputRef}\n              className=\"absolute inset-0 opacity-0 cursor-pointer\"\n            />\n            {/* Custom button */}\n            <button\n              onClick={openColorPicker}\n              style={{ backgroundColor: color }}\n              className={`flex items-center justify-center p-1 h-10 w-10 rounded-full hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-amber-400 bg-neutral-100 dark:bg-neutral-800`}\n            />\n          </div>\n          <button\n            onClick={onClose}\n            className=\"p-2 rounded-full bg-gray-100 dark:bg-neutral-800 hover:bg-gray-200 dark:hover:bg-neutral-700 transition-colors\"\n          >\n            <Icons.CloseLineIcon className=\"w-6 h-6\" />\n          </button>\n        </div>\n      </div>\n\n      {/* SVG Container */}\n      <div className=\"relative flex-grow drawing-container\">\n        <svg\n          ref={svgRef}\n          viewBox={`0 0 ${svgWidth} ${svgHeight}`}\n          preserveAspectRatio=\"xMidYMid meet\"\n          className={`w-full h-auto ${background}`}\n        >\n          <g ref={pathsGroupRef}>{renderPaths()}</g>\n          {path && (\n            <path\n              ref={activePathRef}\n              d={path}\n              stroke={color}\n              strokeWidth={size}\n              opacity={tool === \"highlighter\" ? 0.3 : 1}\n              fill=\"none\"\n              vectorEffect=\"non-scaling-stroke\"\n            />\n          )}\n        </svg>\n      </div>\n    </div>\n  );\n};\n\nexport default DrawMode;"
        }
    ]
}