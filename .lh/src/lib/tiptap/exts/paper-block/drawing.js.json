{
    "sourceFile": "src/lib/tiptap/exts/paper-block/drawing.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 17,
            "patches": [
                {
                    "date": 1732138263949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1732138281103,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,23 @@\n-import React, { useRef, useEffect } from \"react\";\n-import { Keyboard } from \"@capacitor/keyboard\";\n-import Icons from \"../../../remixicon-react\";\n-import { useDrawing, thicknessOptions, backgroundStyles } from \"./useDrawing\";\n+import { useState, useRef, useEffect, useMemo } from \"react\";\n+import * as d3 from \"d3\";\n\\ No newline at end of file\n+import { v4 as uuid } from \"uuid\";\n \n-const DrawMode = ({ onClose, updateAttributes, node }) => {\n+export const thicknessOptions = {\n+  thin: 2,\n+  medium: 3,\n+  thick: 4,\n+  thicker: 5,\n+  thickest: 6,\n+};\n+\n+export const backgroundStyles = {\n+  none: \"\",\n+  grid: \"grid\",\n+  ruled: \"ruled\",\n+  dotted: \"dotted\",\n+};\n+\n+const BUFFER_ZONE = 50;\n+const INCREMENT_HEIGHT = 200;\n+\n+export const useDrawing = ({ initialHeight = 400, initialLines = [], onUpdateAttributes }) => {\n\\ No newline at end of file\n"
                },
                {
                    "date": 1732138293441,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,5 +19,6 @@\n \n const BUFFER_ZONE = 50;\n const INCREMENT_HEIGHT = 200;\n \n-export const useDrawing = ({ initialHeight = 400, initialLines = [], onUpdateAttributes }) => {\n\\ No newline at end of file\n+export const useDrawing = ({ initialHeight = 400, initialLines = [], onUpdateAttributes }) => {\n+    const isDarkMode = document.documentElement.classList.contains(\"dark\");\n"
                },
                {
                    "date": 1732138302427,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,4 +21,34 @@\n const INCREMENT_HEIGHT = 200;\n \n export const useDrawing = ({ initialHeight = 400, initialLines = [], onUpdateAttributes }) => {\n     const isDarkMode = document.documentElement.classList.contains(\"dark\");\n+\n+    return {\n+        drawing,\n+        points,\n+        path,\n+        svgHeight,\n+        tool,\n+        color,\n+        size,\n+        background,\n+        history,\n+        redoStack,\n+        svgRef,\n+        linesRef,\n+        pathsGroupRef,\n+        activePathRef,\n+        setTool,\n+        setColor,\n+        setSize,\n+        setBackground,\n+        startDrawing,\n+        draw,\n+        stopDrawing,\n+        undo,\n+        redo,\n+        deletePath,\n+        getPointerCoordinates,\n+        adjustColorForMode,\n+      };\n+    };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1732138350989,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,36 +19,35 @@\n \n const BUFFER_ZONE = 50;\n const INCREMENT_HEIGHT = 200;\n \n-export const useDrawing = ({ initialHeight = 400, initialLines = [], onUpdateAttributes }) => {\n-    const isDarkMode = document.documentElement.classList.contains(\"dark\");\n+export const useDrawing = ({\n+  initialHeight = 400,\n+  initialLines = [],\n+  onUpdateAttributes,\n+}) => {\n+  const deletePath = (pathElement) => {\n+    const clickedPathData = pathElement.getAttribute(\"d\");\n+    const pathIndex = linesRef.current.findIndex(\n+      (line) => line.path === clickedPathData\n+    );\n \n-    return {\n-        drawing,\n-        points,\n-        path,\n-        svgHeight,\n-        tool,\n-        color,\n-        size,\n-        background,\n-        history,\n-        redoStack,\n-        svgRef,\n-        linesRef,\n-        pathsGroupRef,\n-        activePathRef,\n-        setTool,\n-        setColor,\n-        setSize,\n-        setBackground,\n\\ No newline at end of file\n-        startDrawing,\n-        draw,\n-        stopDrawing,\n-        undo,\n-        redo,\n-        deletePath,\n-        getPointerCoordinates,\n-        adjustColorForMode,\n-      };\n-    };\n+    if (pathIndex !== -1) {\n+      const removedLine = linesRef.current[pathIndex];\n+\n+      // Save the deletion action\n+      setHistory((prevHistory) => [\n+        ...prevHistory,\n+        { action: \"delete\", line: removedLine },\n+      ]);\n+\n+      linesRef.current.splice(pathIndex, 1);\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  return {\n+    deletePath,\n+  };\n+};\n"
                },
                {
                    "date": 1732138369828,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,8 +24,34 @@\n   initialHeight = 400,\n   initialLines = [],\n   onUpdateAttributes,\n }) => {\n+    const isDarkMode = document.documentElement.classList.contains(\"dark\");\n+    const [isDrawing, setIsDrawing] = useState(false);\n+    const [drawingPath, setDrawingPath] = useState(\"\");\n+    const [lines, setLines] = useState([]);\n+    const pointsRef = useRef([]);\n+    const historyRef = useRef([]);\n+    const redoStackRef = useRef([]);\n+    const svgRef = useRef(null);\n+    const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n+    const [size, setSize] = useState(thicknessOptions.thin);\n+    const [drawing, setDrawing] = useState(false);\n+    const [points, setPoints] = useState([]);\n+    const [path, setPath] = useState(\"\");\n+    const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n+    const [svgWidth] = useState(500);\n+    const [tool, setTool] = useState(\"pencil\");\n+    const [history, setHistory] = useState([]);\n+    const [redoStack, setRedoStack] = useState([]);\n+    const [isResizing, setIsResizing] = useState(false);\n+    const [startY, setStartY] = useState(0);\n+    const [id] = useState(() => node.attrs.id || uuid());\n+    const colorInputRef = useRef(null);\n+    const [background, setBackground] = useState(\n+      node.attrs.paperType || backgroundStyles.none\n+    );\n+    \n   const deletePath = (pathElement) => {\n     const clickedPathData = pathElement.getAttribute(\"d\");\n     const pathIndex = linesRef.current.findIndex(\n       (line) => line.path === clickedPathData\n"
                },
                {
                    "date": 1732138425643,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,34 +24,34 @@\n   initialHeight = 400,\n   initialLines = [],\n   onUpdateAttributes,\n }) => {\n-    const isDarkMode = document.documentElement.classList.contains(\"dark\");\n-    const [isDrawing, setIsDrawing] = useState(false);\n-    const [drawingPath, setDrawingPath] = useState(\"\");\n-    const [lines, setLines] = useState([]);\n-    const pointsRef = useRef([]);\n-    const historyRef = useRef([]);\n-    const redoStackRef = useRef([]);\n-    const svgRef = useRef(null);\n-    const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n-    const [size, setSize] = useState(thicknessOptions.thin);\n-    const [drawing, setDrawing] = useState(false);\n-    const [points, setPoints] = useState([]);\n-    const [path, setPath] = useState(\"\");\n-    const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n-    const [svgWidth] = useState(500);\n-    const [tool, setTool] = useState(\"pencil\");\n-    const [history, setHistory] = useState([]);\n-    const [redoStack, setRedoStack] = useState([]);\n-    const [isResizing, setIsResizing] = useState(false);\n-    const [startY, setStartY] = useState(0);\n-    const [id] = useState(() => node.attrs.id || uuid());\n-    const colorInputRef = useRef(null);\n-    const [background, setBackground] = useState(\n-      node.attrs.paperType || backgroundStyles.none\n-    );\n-    \n+  const isDarkMode = document.documentElement.classList.contains(\"dark\");\n+  const [isDrawing, setIsDrawing] = useState(false);\n+  const [drawingPath, setDrawingPath] = useState(\"\");\n+  const [lines, setLines] = useState([]);\n+  const pointsRef = useRef([]);\n+  const historyRef = useRef([]);\n+  const redoStackRef = useRef([]);\n+  const svgRef = useRef(null);\n+  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n+  const [size, setSize] = useState(thicknessOptions.thin);\n+  const [drawing, setDrawing] = useState(false);\n+  const [points, setPoints] = useState([]);\n+  const [path, setPath] = useState(\"\");\n+  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n+  const [svgWidth] = useState(500);\n+  const [tool, setTool] = useState(\"pencil\");\n+  const [history, setHistory] = useState([]);\n+  const [redoStack, setRedoStack] = useState([]);\n+  const [isResizing, setIsResizing] = useState(false);\n+  const [startY, setStartY] = useState(0);\n+  const [id] = useState(() => node.attrs.id || uuid());\n+  const colorInputRef = useRef(null);\n+  const [background, setBackground] = useState(\n+    node.attrs.paperType || backgroundStyles.none\n+  );\n+\n   const deletePath = (pathElement) => {\n     const clickedPathData = pathElement.getAttribute(\"d\");\n     const pathIndex = linesRef.current.findIndex(\n       (line) => line.path === clickedPathData\n@@ -72,8 +72,57 @@\n       });\n     }\n   };\n \n+  const startDrawing = (x, y) => {\n+    setDrawing(true);\n+    setPoints([{ x, y }]);\n+  };\n+\n+  const draw = (x, y) => {\n+    if (!drawing) return;\n+\n+    const newPoints = [...points, { x, y }];\n+    setPoints(newPoints);\n+    const newPath = lineGenerator(newPoints);\n+    setPath(newPath);\n+    if (y > svgHeight - BUFFER_ZONE) {\n+      const newHeight = svgHeight + INCREMENT_HEIGHT;\n+      setSvgHeight(newHeight);\n+      updateAttributes({ height: newHeight });\n+\n+      // Adjust scroll position to keep the drawing point in view\n+      const container = containerRef.current;\n+      if (container) {\n+        const scrollContainer = container.closest(\".drawing-component\");\n+        if (scrollContainer) {\n+          scrollContainer.scrollTo({\n+            top: scrollContainer.scrollHeight,\n+            behavior: \"smooth\",\n+          });\n+        }\n+      }\n+    }\n+  };\n+\n+  const stopDrawing = () => {\n+    if (drawing) {\n+      setDrawing(false);\n+      saveDrawing();\n+      setHistory((prevHistory) => [\n+        ...prevHistory,\n+        { id, path, color, size, tool },\n+      ]);\n+      setPath(\"\");\n+      setPoints([]);\n+    }\n+  };\n+\n   return {\n     deletePath,\n+    startDrawing,\n+    draw,\n+    stopDrawing,\n+    isDrawing,\n+    color,\n   };\n };\n"
                },
                {
                    "date": 1732138475133,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,13 +116,60 @@\n       setPoints([]);\n     }\n   };\n \n+  const undo = () => {\n+    if (history.length > 0) {\n+      const lastAction = history[history.length - 1];\n+      setHistory((prevHistory) => prevHistory.slice(0, -1));\n+      setRedoStack((prevStack) => [...prevStack, lastAction]);\n+\n+      if (lastAction.action === \"add\") {\n+        // Undo adding a line by removing it\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastAction.line.id\n+        );\n+      } else if (lastAction.action === \"delete\") {\n+        // Undo deleting a line by adding it back\n+        linesRef.current = [...linesRef.current, lastAction.line];\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n+  const redo = () => {\n+    if (redoStack.length > 0) {\n+      const lastRedo = redoStack[redoStack.length - 1];\n+      setRedoStack((prevStack) => prevStack.slice(0, -1));\n+      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n+\n+      if (lastRedo.action === \"add\") {\n+        // Redo adding a line by adding it back\n+        linesRef.current = [...linesRef.current, lastRedo.line];\n+      } else if (lastRedo.action === \"delete\") {\n+        // Redo deleting a line by removing it again\n+        linesRef.current = linesRef.current.filter(\n+          (line) => line.id !== lastRedo.line.id\n+        );\n+      }\n+\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }\n+  };\n+\n   return {\n     deletePath,\n     startDrawing,\n     draw,\n     stopDrawing,\n-    isDrawing,\n+    undo,\n+    redo,\n     color,\n+    setColor,\n+    size,\n   };\n };\n"
                },
                {
                    "date": 1732138510865,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -170,6 +170,7 @@\n     redo,\n     color,\n     setColor,\n     size,\n+    setSize\n   };\n };\n"
                },
                {
                    "date": 1732138554324,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,13 +19,9 @@\n \n const BUFFER_ZONE = 50;\n const INCREMENT_HEIGHT = 200;\n \n-export const useDrawing = ({\n-  initialHeight = 400,\n-  initialLines = [],\n-  onUpdateAttributes,\n-}) => {\n+export const useDrawing = ({ node }) => {\n   const isDarkMode = document.documentElement.classList.contains(\"dark\");\n   const [isDrawing, setIsDrawing] = useState(false);\n   const [drawingPath, setDrawingPath] = useState(\"\");\n   const [lines, setLines] = useState([]);\n@@ -170,7 +166,7 @@\n     redo,\n     color,\n     setColor,\n     size,\n-    setSize\n+    setSize,\n   };\n };\n"
                },
                {
                    "date": 1732138612349,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,37 @@\n   const colorInputRef = useRef(null);\n   const [background, setBackground] = useState(\n     node.attrs.paperType || backgroundStyles.none\n   );\n+  const pathsGroupRef = useRef(null);\n+  const activePathRef = useRef(null);\n+  const throttleRef = useRef(null);\n+  const batchUpdateTimeoutRef = useRef(null);\n \n+  // Memoize the line generator to prevent recreation\n+  const lineGenerator = useMemo(\n+    () =>\n+      d3\n+        .line()\n+        .x((d) => d.x)\n+        .y((d) => d.y)\n+        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n+    []\n+  );\n+\n+  const smoothPoints = (points) => {\n+    if (points.length < 3) return points;\n+    return points.map((point, i, arr) => {\n+      if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n+      const prev = arr[i - 1];\n+      const next = arr[i + 1];\n+      return {\n+        x: (prev.x + point.x + next.x) / 3,\n+        y: (prev.y + point.y + next.y) / 3,\n+      };\n+    });\n+  };\n+\n   const deletePath = (pathElement) => {\n     const clickedPathData = pathElement.getAttribute(\"d\");\n     const pathIndex = linesRef.current.findIndex(\n       (line) => line.path === clickedPathData\n"
                },
                {
                    "date": 1732138633412,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -74,8 +74,71 @@\n       };\n     });\n   };\n \n+    // Batch update function for paths\n+    const batchUpdatePaths = () => {\n+        if (batchUpdateTimeoutRef.current) {\n+          clearTimeout(batchUpdateTimeoutRef.current);\n+        }\n+    \n+        batchUpdateTimeoutRef.current = setTimeout(() => {\n+          updateAttributes({\n+            lines: linesRef.current,\n+          });\n+        }, 500); // Adjust timeout as needed\n+      };\n+    \n+      // Throttle draw function\n+      const throttledDraw = (x, y) => {\n+        if (!throttleRef.current) {\n+          throttleRef.current = setTimeout(() => {\n+            throttleRef.current = null;\n+          }, 16); // ~60fps\n+    \n+          if (!drawing) return;\n+    \n+          const newPoints = [...points, { x, y }];\n+          setPoints(newPoints);\n+    \n+          const newPath = lineGenerator(smoothPoints(newPoints));\n+          setPath(newPath);\n+    \n+          // Update active path directly in DOM for better performance\n+          if (activePathRef.current) {\n+            activePathRef.current.setAttribute(\"d\", newPath);\n+          }\n+    \n+          // Check for canvas expansion\n+          if (y > svgHeight - BUFFER_ZONE) {\n+            const newHeight = svgHeight + INCREMENT_HEIGHT;\n+            setSvgHeight(newHeight);\n+            updateAttributes({ height: newHeight });\n+          }\n+        }\n+      };\n+    \n+      // Split paths into chunks for better rendering\n+      const chunkedLines = useMemo(() => {\n+        const chunkSize = 100; // Adjust based on performance needs\n+        const chunks = [];\n+        for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n+          chunks.push(linesRef.current.slice(i, i + chunkSize));\n+        }\n+        return chunks;\n+      }, [linesRef.current.length]);\n+    \n+      const adjustColorForMode = (color) => {\n+        if (isDarkMode) {\n+          // Dark mode: Black turns to white; other colors unchanged\n+          return color === \"#000000\" ? \"#FFFFFF\" : color;\n+        } else {\n+          // Light mode: White turns to black; other colors unchanged\n+          return color === \"#FFFFFF\" ? \"#000000\" : color;\n+        }\n+      };\n+    \n+\n   const deletePath = (pathElement) => {\n     const clickedPathData = pathElement.getAttribute(\"d\");\n     const pathIndex = linesRef.current.findIndex(\n       (line) => line.path === clickedPathData\n"
                },
                {
                    "date": 1732138651596,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -74,71 +74,70 @@\n       };\n     });\n   };\n \n-    // Batch update function for paths\n-    const batchUpdatePaths = () => {\n-        if (batchUpdateTimeoutRef.current) {\n-          clearTimeout(batchUpdateTimeoutRef.current);\n-        }\n-    \n-        batchUpdateTimeoutRef.current = setTimeout(() => {\n-          updateAttributes({\n-            lines: linesRef.current,\n-          });\n-        }, 500); // Adjust timeout as needed\n-      };\n-    \n-      // Throttle draw function\n-      const throttledDraw = (x, y) => {\n-        if (!throttleRef.current) {\n-          throttleRef.current = setTimeout(() => {\n-            throttleRef.current = null;\n-          }, 16); // ~60fps\n-    \n-          if (!drawing) return;\n-    \n-          const newPoints = [...points, { x, y }];\n-          setPoints(newPoints);\n-    \n-          const newPath = lineGenerator(smoothPoints(newPoints));\n-          setPath(newPath);\n-    \n-          // Update active path directly in DOM for better performance\n-          if (activePathRef.current) {\n-            activePathRef.current.setAttribute(\"d\", newPath);\n-          }\n-    \n-          // Check for canvas expansion\n-          if (y > svgHeight - BUFFER_ZONE) {\n-            const newHeight = svgHeight + INCREMENT_HEIGHT;\n-            setSvgHeight(newHeight);\n-            updateAttributes({ height: newHeight });\n-          }\n-        }\n-      };\n-    \n-      // Split paths into chunks for better rendering\n-      const chunkedLines = useMemo(() => {\n-        const chunkSize = 100; // Adjust based on performance needs\n-        const chunks = [];\n-        for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n-          chunks.push(linesRef.current.slice(i, i + chunkSize));\n-        }\n-        return chunks;\n-      }, [linesRef.current.length]);\n-    \n-      const adjustColorForMode = (color) => {\n-        if (isDarkMode) {\n-          // Dark mode: Black turns to white; other colors unchanged\n-          return color === \"#000000\" ? \"#FFFFFF\" : color;\n-        } else {\n-          // Light mode: White turns to black; other colors unchanged\n-          return color === \"#FFFFFF\" ? \"#000000\" : color;\n-        }\n-      };\n-    \n+  // Batch update function for paths\n+  const batchUpdatePaths = () => {\n+    if (batchUpdateTimeoutRef.current) {\n+      clearTimeout(batchUpdateTimeoutRef.current);\n+    }\n \n+    batchUpdateTimeoutRef.current = setTimeout(() => {\n+      updateAttributes({\n+        lines: linesRef.current,\n+      });\n+    }, 500); // Adjust timeout as needed\n+  };\n+\n+  // Throttle draw function\n+  const throttledDraw = (x, y) => {\n+    if (!throttleRef.current) {\n+      throttleRef.current = setTimeout(() => {\n+        throttleRef.current = null;\n+      }, 16); // ~60fps\n+\n+      if (!drawing) return;\n+\n+      const newPoints = [...points, { x, y }];\n+      setPoints(newPoints);\n+\n+      const newPath = lineGenerator(smoothPoints(newPoints));\n+      setPath(newPath);\n+\n+      // Update active path directly in DOM for better performance\n+      if (activePathRef.current) {\n+        activePathRef.current.setAttribute(\"d\", newPath);\n+      }\n+\n+      // Check for canvas expansion\n+      if (y > svgHeight - BUFFER_ZONE) {\n+        const newHeight = svgHeight + INCREMENT_HEIGHT;\n+        setSvgHeight(newHeight);\n+        updateAttributes({ height: newHeight });\n+      }\n+    }\n+  };\n+\n+  // Split paths into chunks for better rendering\n+  const chunkedLines = useMemo(() => {\n+    const chunkSize = 100; // Adjust based on performance needs\n+    const chunks = [];\n+    for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n+      chunks.push(linesRef.current.slice(i, i + chunkSize));\n+    }\n+    return chunks;\n+  }, [linesRef.current.length]);\n+\n+  const adjustColorForMode = (color) => {\n+    if (isDarkMode) {\n+      // Dark mode: Black turns to white; other colors unchanged\n+      return color === \"#000000\" ? \"#FFFFFF\" : color;\n+    } else {\n+      // Light mode: White turns to black; other colors unchanged\n+      return color === \"#FFFFFF\" ? \"#000000\" : color;\n+    }\n+  };\n+\n   const deletePath = (pathElement) => {\n     const clickedPathData = pathElement.getAttribute(\"d\");\n     const pathIndex = linesRef.current.findIndex(\n       (line) => line.path === clickedPathData\n@@ -247,8 +246,25 @@\n       });\n     }\n   };\n \n+    // Optimize save drawing function\n+    const saveDrawing = () => {\n+        if (!path) return;\n+    \n+        const newLine = { id: uuid(), path, color, size, tool };\n+        linesRef.current = [...linesRef.current, newLine];\n+    \n+        setHistory((prevHistory) => [\n+          ...prevHistory,\n+          { action: \"add\", line: newLine },\n+        ]);\n+    \n+        setRedoStack([]);\n+        batchUpdatePaths();\n+      };\n+    \n+\n   return {\n     deletePath,\n     startDrawing,\n     draw,\n"
                },
                {
                    "date": 1732138685438,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,8 +20,9 @@\n const BUFFER_ZONE = 50;\n const INCREMENT_HEIGHT = 200;\n \n export const useDrawing = ({ node }) => {\n+    const linesRef = useRef(initialLines);\n   const isDarkMode = document.documentElement.classList.contains(\"dark\");\n   const [isDrawing, setIsDrawing] = useState(false);\n   const [drawingPath, setDrawingPath] = useState(\"\");\n   const [lines, setLines] = useState([]);\n@@ -246,25 +247,24 @@\n       });\n     }\n   };\n \n-    // Optimize save drawing function\n-    const saveDrawing = () => {\n-        if (!path) return;\n-    \n-        const newLine = { id: uuid(), path, color, size, tool };\n-        linesRef.current = [...linesRef.current, newLine];\n-    \n-        setHistory((prevHistory) => [\n-          ...prevHistory,\n-          { action: \"add\", line: newLine },\n-        ]);\n-    \n-        setRedoStack([]);\n-        batchUpdatePaths();\n-      };\n-    \n+  // Optimize save drawing function\n+  const saveDrawing = () => {\n+    if (!path) return;\n \n+    const newLine = { id: uuid(), path, color, size, tool };\n+    linesRef.current = [...linesRef.current, newLine];\n+\n+    setHistory((prevHistory) => [\n+      ...prevHistory,\n+      { action: \"add\", line: newLine },\n+    ]);\n+\n+    setRedoStack([]);\n+    batchUpdatePaths();\n+  };\n+\n   return {\n     deletePath,\n     startDrawing,\n     draw,\n"
                },
                {
                    "date": 1732138706084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n const BUFFER_ZONE = 50;\n const INCREMENT_HEIGHT = 200;\n \n export const useDrawing = ({ node }) => {\n-    const linesRef = useRef(initialLines);\n+  const linesRef = useRef(node.attrs.lines || [],);\n   const isDarkMode = document.documentElement.classList.contains(\"dark\");\n   const [isDrawing, setIsDrawing] = useState(false);\n   const [drawingPath, setDrawingPath] = useState(\"\");\n   const [lines, setLines] = useState([]);\n"
                },
                {
                    "date": 1732138745339,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n const BUFFER_ZONE = 50;\n const INCREMENT_HEIGHT = 200;\n \n export const useDrawing = ({ node }) => {\n-  const linesRef = useRef(node.attrs.lines || [],);\n+  const linesRef = useRef(node.attrs.lines || []);\n   const isDarkMode = document.documentElement.classList.contains(\"dark\");\n   const [isDrawing, setIsDrawing] = useState(false);\n   const [drawingPath, setDrawingPath] = useState(\"\");\n   const [lines, setLines] = useState([]);\n@@ -274,6 +274,7 @@\n     color,\n     setColor,\n     size,\n     setSize,\n+    pathsGroupRef\n   };\n };\n"
                },
                {
                    "date": 1732138766466,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -274,7 +274,8 @@\n     color,\n     setColor,\n     size,\n     setSize,\n-    pathsGroupRef\n+    pathsGroupRef,\n+    chunkedLines\n   };\n };\n"
                },
                {
                    "date": 1732139212335,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,281 +0,0 @@\n-import { useState, useRef, useEffect, useMemo } from \"react\";\n-import * as d3 from \"d3\";\n-import { v4 as uuid } from \"uuid\";\n-\n-export const thicknessOptions = {\n-  thin: 2,\n-  medium: 3,\n-  thick: 4,\n-  thicker: 5,\n-  thickest: 6,\n-};\n-\n-export const backgroundStyles = {\n-  none: \"\",\n-  grid: \"grid\",\n-  ruled: \"ruled\",\n-  dotted: \"dotted\",\n-};\n-\n-const BUFFER_ZONE = 50;\n-const INCREMENT_HEIGHT = 200;\n-\n-export const useDrawing = ({ node }) => {\n-  const linesRef = useRef(node.attrs.lines || []);\n-  const isDarkMode = document.documentElement.classList.contains(\"dark\");\n-  const [isDrawing, setIsDrawing] = useState(false);\n-  const [drawingPath, setDrawingPath] = useState(\"\");\n-  const [lines, setLines] = useState([]);\n-  const pointsRef = useRef([]);\n-  const historyRef = useRef([]);\n-  const redoStackRef = useRef([]);\n-  const svgRef = useRef(null);\n-  const [color, setColor] = useState(isDarkMode ? \"#FFFFFF\" : \"#000000\");\n-  const [size, setSize] = useState(thicknessOptions.thin);\n-  const [drawing, setDrawing] = useState(false);\n-  const [points, setPoints] = useState([]);\n-  const [path, setPath] = useState(\"\");\n-  const [svgHeight, setSvgHeight] = useState(node.attrs.height || 400);\n-  const [svgWidth] = useState(500);\n-  const [tool, setTool] = useState(\"pencil\");\n-  const [history, setHistory] = useState([]);\n-  const [redoStack, setRedoStack] = useState([]);\n-  const [isResizing, setIsResizing] = useState(false);\n-  const [startY, setStartY] = useState(0);\n-  const [id] = useState(() => node.attrs.id || uuid());\n-  const colorInputRef = useRef(null);\n-  const [background, setBackground] = useState(\n-    node.attrs.paperType || backgroundStyles.none\n-  );\n-  const pathsGroupRef = useRef(null);\n-  const activePathRef = useRef(null);\n-  const throttleRef = useRef(null);\n-  const batchUpdateTimeoutRef = useRef(null);\n-\n-  // Memoize the line generator to prevent recreation\n-  const lineGenerator = useMemo(\n-    () =>\n-      d3\n-        .line()\n-        .x((d) => d.x)\n-        .y((d) => d.y)\n-        .curve(d3.curveBasis), // Adjusted alpha for more smoothness\n-    []\n-  );\n-\n-  const smoothPoints = (points) => {\n-    if (points.length < 3) return points;\n-    return points.map((point, i, arr) => {\n-      if (i === 0 || i === arr.length - 1) return point; // Keep endpoints\n-      const prev = arr[i - 1];\n-      const next = arr[i + 1];\n-      return {\n-        x: (prev.x + point.x + next.x) / 3,\n-        y: (prev.y + point.y + next.y) / 3,\n-      };\n-    });\n-  };\n-\n-  // Batch update function for paths\n-  const batchUpdatePaths = () => {\n-    if (batchUpdateTimeoutRef.current) {\n-      clearTimeout(batchUpdateTimeoutRef.current);\n-    }\n-\n-    batchUpdateTimeoutRef.current = setTimeout(() => {\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }, 500); // Adjust timeout as needed\n-  };\n-\n-  // Throttle draw function\n-  const throttledDraw = (x, y) => {\n-    if (!throttleRef.current) {\n-      throttleRef.current = setTimeout(() => {\n-        throttleRef.current = null;\n-      }, 16); // ~60fps\n-\n-      if (!drawing) return;\n-\n-      const newPoints = [...points, { x, y }];\n-      setPoints(newPoints);\n-\n-      const newPath = lineGenerator(smoothPoints(newPoints));\n-      setPath(newPath);\n-\n-      // Update active path directly in DOM for better performance\n-      if (activePathRef.current) {\n-        activePathRef.current.setAttribute(\"d\", newPath);\n-      }\n-\n-      // Check for canvas expansion\n-      if (y > svgHeight - BUFFER_ZONE) {\n-        const newHeight = svgHeight + INCREMENT_HEIGHT;\n-        setSvgHeight(newHeight);\n-        updateAttributes({ height: newHeight });\n-      }\n-    }\n-  };\n-\n-  // Split paths into chunks for better rendering\n-  const chunkedLines = useMemo(() => {\n-    const chunkSize = 100; // Adjust based on performance needs\n-    const chunks = [];\n-    for (let i = 0; i < linesRef.current.length; i += chunkSize) {\n-      chunks.push(linesRef.current.slice(i, i + chunkSize));\n-    }\n-    return chunks;\n-  }, [linesRef.current.length]);\n-\n-  const adjustColorForMode = (color) => {\n-    if (isDarkMode) {\n-      // Dark mode: Black turns to white; other colors unchanged\n-      return color === \"#000000\" ? \"#FFFFFF\" : color;\n-    } else {\n-      // Light mode: White turns to black; other colors unchanged\n-      return color === \"#FFFFFF\" ? \"#000000\" : color;\n-    }\n-  };\n-\n-  const deletePath = (pathElement) => {\n-    const clickedPathData = pathElement.getAttribute(\"d\");\n-    const pathIndex = linesRef.current.findIndex(\n-      (line) => line.path === clickedPathData\n-    );\n-\n-    if (pathIndex !== -1) {\n-      const removedLine = linesRef.current[pathIndex];\n-\n-      // Save the deletion action\n-      setHistory((prevHistory) => [\n-        ...prevHistory,\n-        { action: \"delete\", line: removedLine },\n-      ]);\n-\n-      linesRef.current.splice(pathIndex, 1);\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n-  const startDrawing = (x, y) => {\n-    setDrawing(true);\n-    setPoints([{ x, y }]);\n-  };\n-\n-  const draw = (x, y) => {\n-    if (!drawing) return;\n-\n-    const newPoints = [...points, { x, y }];\n-    setPoints(newPoints);\n-    const newPath = lineGenerator(newPoints);\n-    setPath(newPath);\n-    if (y > svgHeight - BUFFER_ZONE) {\n-      const newHeight = svgHeight + INCREMENT_HEIGHT;\n-      setSvgHeight(newHeight);\n-      updateAttributes({ height: newHeight });\n-\n-      // Adjust scroll position to keep the drawing point in view\n-      const container = containerRef.current;\n-      if (container) {\n-        const scrollContainer = container.closest(\".drawing-component\");\n-        if (scrollContainer) {\n-          scrollContainer.scrollTo({\n-            top: scrollContainer.scrollHeight,\n-            behavior: \"smooth\",\n-          });\n-        }\n-      }\n-    }\n-  };\n-\n-  const stopDrawing = () => {\n-    if (drawing) {\n-      setDrawing(false);\n-      saveDrawing();\n-      setHistory((prevHistory) => [\n-        ...prevHistory,\n-        { id, path, color, size, tool },\n-      ]);\n-      setPath(\"\");\n-      setPoints([]);\n-    }\n-  };\n-\n-  const undo = () => {\n-    if (history.length > 0) {\n-      const lastAction = history[history.length - 1];\n-      setHistory((prevHistory) => prevHistory.slice(0, -1));\n-      setRedoStack((prevStack) => [...prevStack, lastAction]);\n-\n-      if (lastAction.action === \"add\") {\n-        // Undo adding a line by removing it\n-        linesRef.current = linesRef.current.filter(\n-          (line) => line.id !== lastAction.line.id\n-        );\n-      } else if (lastAction.action === \"delete\") {\n-        // Undo deleting a line by adding it back\n-        linesRef.current = [...linesRef.current, lastAction.line];\n-      }\n-\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n-  const redo = () => {\n-    if (redoStack.length > 0) {\n-      const lastRedo = redoStack[redoStack.length - 1];\n-      setRedoStack((prevStack) => prevStack.slice(0, -1));\n-      setHistory((prevHistory) => [...prevHistory, lastRedo]);\n-\n-      if (lastRedo.action === \"add\") {\n-        // Redo adding a line by adding it back\n-        linesRef.current = [...linesRef.current, lastRedo.line];\n-      } else if (lastRedo.action === \"delete\") {\n-        // Redo deleting a line by removing it again\n-        linesRef.current = linesRef.current.filter(\n-          (line) => line.id !== lastRedo.line.id\n-        );\n-      }\n-\n-      updateAttributes({\n-        lines: linesRef.current,\n-      });\n-    }\n-  };\n-\n-  // Optimize save drawing function\n-  const saveDrawing = () => {\n-    if (!path) return;\n-\n-    const newLine = { id: uuid(), path, color, size, tool };\n-    linesRef.current = [...linesRef.current, newLine];\n-\n-    setHistory((prevHistory) => [\n-      ...prevHistory,\n-      { action: \"add\", line: newLine },\n-    ]);\n-\n-    setRedoStack([]);\n-    batchUpdatePaths();\n-  };\n-\n-  return {\n-    deletePath,\n-    startDrawing,\n-    draw,\n-    stopDrawing,\n-    undo,\n-    redo,\n-    color,\n-    setColor,\n-    size,\n-    setSize,\n-    pathsGroupRef,\n-    chunkedLines\n-  };\n-};\n\\ No newline at end of file\n"
                }
            ],
            "date": 1732138263949,
            "name": "Commit-0",
            "content": "import React, { useRef, useEffect } from \"react\";\nimport { Keyboard } from \"@capacitor/keyboard\";\nimport Icons from \"../../../remixicon-react\";\nimport { useDrawing, thicknessOptions, backgroundStyles } from \"./useDrawing\";\n\nconst DrawMode = ({ onClose, updateAttributes, node }) => {"
        }
    ]
}