{
    "sourceFile": "src/lib/tiptap/exts/search-&-replace/search&Replace.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1731916744378,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1731916763177,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -374,9 +374,9 @@\n           editor.storage.searchAndReplace.resultIndex = 0;\n \n           // Reset decorations by clearing the plugin state\n           const pluginState = editor.view.state.plugins\n-            .find((plugin) => plugin.key === searchAndReplacePluginKey)\n+            .find((plugin:ay) => plugin.key === searchAndReplacePluginKey)\n             ?.getState(editor.view.state);\n \n           if (pluginState) {\n             editor.view.dispatch(\n"
                },
                {
                    "date": 1731916770871,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -374,9 +374,9 @@\n           editor.storage.searchAndReplace.resultIndex = 0;\n \n           // Reset decorations by clearing the plugin state\n           const pluginState = editor.view.state.plugins\n-            .find((plugin:ay) => plugin.key === searchAndReplacePluginKey)\n+            .find((plugin) => plugin.key === searchAndReplacePluginKey)\n             ?.getState(editor.view.state);\n \n           if (pluginState) {\n             editor.view.dispatch(\n"
                },
                {
                    "date": 1731916784698,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -374,9 +374,9 @@\n           editor.storage.searchAndReplace.resultIndex = 0;\n \n           // Reset decorations by clearing the plugin state\n           const pluginState = editor.view.state.plugins\n-            .find((plugin) => plugin.key === searchAndReplacePluginKey)\n+            .find((plugin: any) => plugin.key === searchAndReplacePluginKey)\n             ?.getState(editor.view.state);\n \n           if (pluginState) {\n             editor.view.dispatch(\n"
                },
                {
                    "date": 1731917159670,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -209,39 +209,39 @@\n   return [offset, results];\n };\n \n const replaceAll = (\n-  replaceTerm: string,\n-  results: Range[],\n-  { tr, dispatch }: { tr: Transaction; dispatch?: Dispatch }\n-) => {\n-  let offset = 0;\n+    replaceTerm: string,\n+    results: Range[],\n+    { tr, dispatch }: { tr: Transaction; dispatch?: Dispatch }\n+  ) => {\n+    let offset = 0;\n+  \n+    let resultsCopy = results.slice();\n+  \n+    if (!resultsCopy.length || !dispatch) return; // Check if dispatch is defined\n+  \n+    for (let i = 0; i < resultsCopy.length; i += 1) {\n+      const { from, to } = resultsCopy[i];\n+  \n+      tr.insertText(replaceTerm, from, to);\n+  \n+      const rebaseNextResultResponse = rebaseNextResult(\n+        replaceTerm,\n+        i,\n+        offset,\n+        resultsCopy\n+      );\n+  \n+      if (!rebaseNextResultResponse) continue;\n+  \n+      offset = rebaseNextResultResponse[0];\n+      resultsCopy = rebaseNextResultResponse[1];\n+    }\n+  \n+    dispatch(tr); // Now you can safely call dispatch\n+  };  \n \n-  let resultsCopy = results.slice();\n-\n-  if (!resultsCopy.length || !dispatch) return; // Check if dispatch is defined\n-\n-  for (let i = 0; i < resultsCopy.length; i += 1) {\n-    const { from, to } = resultsCopy[i];\n-\n-    tr.insertText(replaceTerm, from, to);\n-\n-    const rebaseNextResultResponse = rebaseNextResult(\n-      replaceTerm,\n-      i,\n-      offset,\n-      resultsCopy\n-    );\n-\n-    if (!rebaseNextResultResponse) continue;\n-\n-    offset = rebaseNextResultResponse[0];\n-    resultsCopy = rebaseNextResultResponse[1];\n-  }\n-\n-  dispatch(tr); // Now you can safely call dispatch\n-};\n-\n export const searchAndReplacePluginKey = new PluginKey(\n   \"searchAndReplacePlugin\"\n );\n \n@@ -364,29 +364,8 @@\n           replaceAll(replaceTerm, results, { tr, dispatch });\n \n           return false;\n         },\n-      clearSearch:\n-        () =>\n-        ({ editor }) => {\n-          // Reset search-related state\n-          editor.storage.searchAndReplace.searchTerm = \"\";\n-          editor.storage.searchAndReplace.results = [];\n-          editor.storage.searchAndReplace.resultIndex = 0;\n-\n-          // Reset decorations by clearing the plugin state\n-          const pluginState = editor.view.state.plugins\n-            .find((plugin: any) => plugin.key === searchAndReplacePluginKey)\n-            ?.getState(editor.view.state);\n-\n-          if (pluginState) {\n-            editor.view.dispatch(\n-              editor.view.state.tr.setMeta(searchAndReplacePluginKey, {})\n-            );\n-          }\n-\n-          return true;\n-        },\n     };\n   },\n \n   addProseMirrorPlugins() {\n"
                }
            ],
            "date": 1731916744378,
            "name": "Commit-0",
            "content": "// MIT License\n\n// Copyright (c) 2023 - 2024 Jeet Mandaliya (Github Username: sereneinserenade)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nimport { Extension, Range, type Dispatch } from \"@tiptap/core\";\nimport { Decoration, DecorationSet } from \"@tiptap/pm/view\";\nimport {\n  Plugin,\n  PluginKey,\n  type EditorState,\n  type Transaction,\n} from \"@tiptap/pm/state\";\nimport { Node as PMNode } from \"@tiptap/pm/model\";\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    search: {\n      /**\n       * @description Set search term in extension.\n       */\n      setSearchTerm: (searchTerm: string) => ReturnType;\n      /**\n       * @description Set replace term in extension.\n       */\n      setReplaceTerm: (replaceTerm: string) => ReturnType;\n      /**\n       * @description Set case sensitivity in extension.\n       */\n      setCaseSensitive: (caseSensitive: boolean) => ReturnType;\n      /**\n       * @description Reset current search result to first instance.\n       */\n      resetIndex: () => ReturnType;\n      /**\n       * @description Find next instance of search result.\n       */\n      nextSearchResult: () => ReturnType;\n      /**\n       * @description Find previous instance of search result.\n       */\n      previousSearchResult: () => ReturnType;\n      /**\n       * @description Replace first instance of search result with given replace term.\n       */\n      replace: () => ReturnType;\n      /**\n       * @description Replace all instances of search result with given replace term.\n       */\n      replaceAll: () => ReturnType;\n    };\n  }\n}\n\ninterface TextNodesWithPosition {\n  text: string;\n  pos: number;\n}\n\nconst getRegex = (\n  s: string,\n  disableRegex: boolean,\n  caseSensitive: boolean\n): RegExp => {\n  return RegExp(\n    disableRegex ? s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\") : s,\n    caseSensitive ? \"gu\" : \"gui\"\n  );\n};\n\ninterface ProcessedSearches {\n  decorationsToReturn: DecorationSet;\n  results: Range[];\n}\n\nfunction processSearches(\n  doc: PMNode,\n  searchTerm: RegExp,\n  searchResultClass: string,\n  resultIndex: number\n): ProcessedSearches {\n  const decorations: Decoration[] = [];\n  const results: Range[] = [];\n\n  let textNodesWithPosition: TextNodesWithPosition[] = [];\n  let index = 0;\n\n  if (!searchTerm) {\n    return {\n      decorationsToReturn: DecorationSet.empty,\n      results: [],\n    };\n  }\n\n  doc?.descendants((node, pos) => {\n    if (node.isText) {\n      if (textNodesWithPosition[index]) {\n        textNodesWithPosition[index] = {\n          text: textNodesWithPosition[index].text + node.text,\n          pos: textNodesWithPosition[index].pos,\n        };\n      } else {\n        textNodesWithPosition[index] = {\n          text: `${node.text}`,\n          pos,\n        };\n      }\n    } else {\n      index += 1;\n    }\n  });\n\n  textNodesWithPosition = textNodesWithPosition.filter(Boolean);\n\n  for (const element of textNodesWithPosition) {\n    const { text, pos } = element;\n    const matches = Array.from(text.matchAll(searchTerm)).filter(\n      ([matchText]) => matchText.trim()\n    );\n\n    for (const m of matches) {\n      if (m[0] === \"\") break;\n\n      if (m.index !== undefined) {\n        results.push({\n          from: pos + m.index,\n          to: pos + m.index + m[0].length,\n        });\n      }\n    }\n  }\n\n  for (let i = 0; i < results.length; i += 1) {\n    const r = results[i];\n    const className =\n      i === resultIndex\n        ? `${searchResultClass} ${searchResultClass}-current`\n        : searchResultClass;\n    const decoration: Decoration = Decoration.inline(r.from, r.to, {\n      class: className,\n    });\n\n    decorations.push(decoration);\n  }\n\n  return {\n    decorationsToReturn: DecorationSet.create(doc, decorations),\n    results,\n  };\n}\n\nconst replace = (\n  replaceTerm: string,\n  results: Range[],\n  { state, dispatch }: { state: EditorState; dispatch: Dispatch }\n) => {\n  const firstResult = results[0];\n\n  if (!firstResult) return;\n\n  const { from, to } = results[0];\n\n  if (dispatch) {\n    const tr = state.tr;\n    tr.deleteRange(from, to); // Delete the original text\n    tr.insertText(replaceTerm, from); // Insert the replacement term\n    dispatch(tr);\n  }\n};\n\nconst rebaseNextResult = (\n  replaceTerm: string,\n  index: number,\n  lastOffset: number,\n  results: Range[]\n): [number, Range[]] | null => {\n  const nextIndex = index + 1;\n\n  if (!results[nextIndex]) return null;\n\n  const { from: currentFrom, to: currentTo } = results[index];\n\n  const offset = currentTo - currentFrom - replaceTerm.length + lastOffset;\n\n  const { from, to } = results[nextIndex];\n\n  results[nextIndex] = {\n    to: to - offset,\n    from: from - offset,\n  };\n\n  return [offset, results];\n};\n\nconst replaceAll = (\n  replaceTerm: string,\n  results: Range[],\n  { tr, dispatch }: { tr: Transaction; dispatch?: Dispatch }\n) => {\n  let offset = 0;\n\n  let resultsCopy = results.slice();\n\n  if (!resultsCopy.length || !dispatch) return; // Check if dispatch is defined\n\n  for (let i = 0; i < resultsCopy.length; i += 1) {\n    const { from, to } = resultsCopy[i];\n\n    tr.insertText(replaceTerm, from, to);\n\n    const rebaseNextResultResponse = rebaseNextResult(\n      replaceTerm,\n      i,\n      offset,\n      resultsCopy\n    );\n\n    if (!rebaseNextResultResponse) continue;\n\n    offset = rebaseNextResultResponse[0];\n    resultsCopy = rebaseNextResultResponse[1];\n  }\n\n  dispatch(tr); // Now you can safely call dispatch\n};\n\nexport const searchAndReplacePluginKey = new PluginKey(\n  \"searchAndReplacePlugin\"\n);\n\nexport interface SearchAndReplaceOptions {\n  searchResultClass: string;\n  disableRegex: boolean;\n}\n\nexport interface SearchAndReplaceStorage {\n  searchTerm: string;\n  replaceTerm: string;\n  results: Range[];\n  lastSearchTerm: string;\n  caseSensitive: boolean;\n  lastCaseSensitive: boolean;\n  resultIndex: number;\n  lastResultIndex: number;\n}\n\nexport const SearchAndReplace = Extension.create<\n  SearchAndReplaceOptions,\n  SearchAndReplaceStorage\n>({\n  name: \"searchAndReplace\",\n\n  addOptions() {\n    return {\n      searchResultClass: \"bg-amber-400 bg-opacity-60\",\n      disableRegex: true,\n    };\n  },\n\n  addStorage() {\n    return {\n      searchTerm: \"\",\n      replaceTerm: \"\",\n      results: [],\n      lastSearchTerm: \"\",\n      caseSensitive: false,\n      lastCaseSensitive: false,\n      resultIndex: 0,\n      lastResultIndex: 0,\n    };\n  },\n\n  addCommands() {\n    return {\n      setSearchTerm:\n        (searchTerm: string) =>\n        ({ editor }) => {\n          editor.storage.searchAndReplace.searchTerm = searchTerm;\n\n          return false;\n        },\n      setReplaceTerm:\n        (replaceTerm: string) =>\n        ({ editor }) => {\n          editor.storage.searchAndReplace.replaceTerm = replaceTerm;\n\n          return false;\n        },\n      setCaseSensitive:\n        (caseSensitive: boolean) =>\n        ({ editor }) => {\n          editor.storage.searchAndReplace.caseSensitive = caseSensitive;\n\n          return false;\n        },\n      resetIndex:\n        () =>\n        ({ editor }) => {\n          editor.storage.searchAndReplace.resultIndex = 0;\n\n          return false;\n        },\n      nextSearchResult:\n        () =>\n        ({ editor }) => {\n          const { results, resultIndex } = editor.storage.searchAndReplace;\n\n          const nextIndex = resultIndex + 1;\n\n          if (results[nextIndex]) {\n            editor.storage.searchAndReplace.resultIndex = nextIndex;\n          } else {\n            editor.storage.searchAndReplace.resultIndex = 0;\n          }\n\n          return false;\n        },\n      previousSearchResult:\n        () =>\n        ({ editor }) => {\n          const { results, resultIndex } = editor.storage.searchAndReplace;\n\n          const prevIndex = resultIndex - 1;\n\n          if (results[prevIndex]) {\n            editor.storage.searchAndReplace.resultIndex = prevIndex;\n          } else {\n            editor.storage.searchAndReplace.resultIndex = results.length - 1;\n          }\n\n          return false;\n        },\n      replace:\n        () =>\n        ({ editor, state, dispatch }) => {\n          const { replaceTerm, results } = editor.storage.searchAndReplace;\n\n          replace(replaceTerm, results, { state, dispatch });\n\n          return false;\n        },\n      replaceAll:\n        () =>\n        ({ editor, tr, dispatch }) => {\n          const { replaceTerm, results } = editor.storage.searchAndReplace;\n\n          replaceAll(replaceTerm, results, { tr, dispatch });\n\n          return false;\n        },\n      clearSearch:\n        () =>\n        ({ editor }) => {\n          // Reset search-related state\n          editor.storage.searchAndReplace.searchTerm = \"\";\n          editor.storage.searchAndReplace.results = [];\n          editor.storage.searchAndReplace.resultIndex = 0;\n\n          // Reset decorations by clearing the plugin state\n          const pluginState = editor.view.state.plugins\n            .find((plugin) => plugin.key === searchAndReplacePluginKey)\n            ?.getState(editor.view.state);\n\n          if (pluginState) {\n            editor.view.dispatch(\n              editor.view.state.tr.setMeta(searchAndReplacePluginKey, {})\n            );\n          }\n\n          return true;\n        },\n    };\n  },\n\n  addProseMirrorPlugins() {\n    const editor = this.editor;\n    const { searchResultClass, disableRegex } = this.options;\n\n    const setLastSearchTerm = (t: string) =>\n      (editor.storage.searchAndReplace.lastSearchTerm = t);\n    const setLastCaseSensitive = (t: boolean) =>\n      (editor.storage.searchAndReplace.lastCaseSensitive = t);\n    const setLastResultIndex = (t: number) =>\n      (editor.storage.searchAndReplace.lastResultIndex = t);\n\n    return [\n      new Plugin({\n        key: searchAndReplacePluginKey,\n        state: {\n          init: () => DecorationSet.empty,\n          apply({ doc, docChanged }, oldState) {\n            const {\n              searchTerm,\n              lastSearchTerm,\n              caseSensitive,\n              lastCaseSensitive,\n              resultIndex,\n              lastResultIndex,\n            } = editor.storage.searchAndReplace;\n\n            if (\n              !docChanged &&\n              lastSearchTerm === searchTerm &&\n              lastCaseSensitive === caseSensitive &&\n              lastResultIndex === resultIndex\n            )\n              return oldState;\n\n            setLastSearchTerm(searchTerm);\n            setLastCaseSensitive(caseSensitive);\n            setLastResultIndex(resultIndex);\n\n            if (!searchTerm) {\n              editor.storage.searchAndReplace.results = [];\n              return DecorationSet.empty;\n            }\n\n            const { decorationsToReturn, results } = processSearches(\n              doc,\n              getRegex(searchTerm, disableRegex, caseSensitive),\n              searchResultClass,\n              resultIndex\n            );\n\n            editor.storage.searchAndReplace.results = results;\n\n            return decorationsToReturn;\n          },\n        },\n        props: {\n          decorations(state) {\n            return this.getState(state);\n          },\n        },\n      }),\n    ];\n  },\n});\n\nexport default SearchAndReplace;\n"
        }
    ]
}