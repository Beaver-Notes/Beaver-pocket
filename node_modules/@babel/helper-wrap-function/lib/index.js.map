{"version":3,"names":["_helperFunctionName","require","_template","_t","blockStatement","callExpression","functionExpression","isAssignmentPattern","isFunctionDeclaration","isRestElement","returnStatement","isCallExpression","cloneNode","toExpression","buildWrapper","template","statement","classOrObjectMethod","path","callId","node","body","container","async","generator","get","unwrapFunctionEnvironment","plainFunction","inPath","noNewArrows","ignoreFunctionLength","functionId","nodeParams","params","isArrowFunctionExpression","_path$arrowFunctionTo","arrowFunctionToExpression","isDeclaration","built","id","type","param","push","scope","generateUidIdentifier","ref","name","wrapper","NAME","REF","FUNCTION","PARAMS","nameFunction","parent","length","replaceWith","parentPath","wrapFunction","isMethod"],"sources":["../src/index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport template from \"@babel/template\";\nimport {\n  blockStatement,\n  callExpression,\n  functionExpression,\n  isAssignmentPattern,\n  isFunctionDeclaration,\n  isRestElement,\n  returnStatement,\n  isCallExpression,\n  cloneNode,\n  toExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nconst buildWrapper = template.statement(`\n  function NAME(PARAMS) {\n    return (REF = REF || FUNCTION).apply(this, arguments);\n  }\n`) as (\n  replacements: Parameters<ReturnType<typeof template.expression>>[0],\n) => t.FunctionDeclaration;\n\nfunction classOrObjectMethod(\n  path: NodePath<t.ClassMethod | t.ClassPrivateMethod | t.ObjectMethod>,\n  callId: t.Expression,\n) {\n  const node = path.node;\n  const body = node.body;\n\n  const container = functionExpression(\n    null,\n    [],\n    blockStatement(body.body),\n    true,\n  );\n  body.body = [\n    returnStatement(callExpression(callExpression(callId, [container]), [])),\n  ];\n\n  // Regardless of whether or not the wrapped function is a an async method\n  // or generator the outer function should not be\n  node.async = false;\n  node.generator = false;\n\n  // Unwrap the wrapper IIFE's environment so super and this and such still work.\n  (\n    path.get(\"body.body.0.argument.callee.arguments.0\") as NodePath\n  ).unwrapFunctionEnvironment();\n}\n\nfunction plainFunction(\n  inPath: NodePath<Exclude<t.Function, t.Method>>,\n  callId: t.Expression,\n  noNewArrows: boolean,\n  ignoreFunctionLength: boolean,\n) {\n  let path: NodePath<\n    | t.FunctionDeclaration\n    | t.FunctionExpression\n    | t.CallExpression\n    | t.ArrowFunctionExpression\n  > = inPath;\n  let node;\n  let functionId = null;\n  const nodeParams = inPath.node.params;\n\n  if (path.isArrowFunctionExpression()) {\n    if (process.env.BABEL_8_BREAKING) {\n      path = path.arrowFunctionToExpression({ noNewArrows });\n    } else {\n      // arrowFunctionToExpression returns undefined in @babel/traverse < 7.18.10\n      path = path.arrowFunctionToExpression({ noNewArrows }) ?? path;\n    }\n    node = path.node as\n      | t.FunctionDeclaration\n      | t.FunctionExpression\n      | t.CallExpression;\n  } else {\n    node = path.node as t.FunctionDeclaration | t.FunctionExpression;\n  }\n\n  const isDeclaration = isFunctionDeclaration(node);\n\n  let built = node;\n  if (!isCallExpression(node)) {\n    functionId = node.id;\n    node.id = null;\n    node.type = \"FunctionExpression\";\n    built = callExpression(callId, [\n      node as Exclude<typeof node, t.FunctionDeclaration>,\n    ]);\n  }\n\n  const params: t.Identifier[] = [];\n  for (const param of nodeParams) {\n    if (isAssignmentPattern(param) || isRestElement(param)) {\n      break;\n    }\n    params.push(path.scope.generateUidIdentifier(\"x\"));\n  }\n\n  const ref = path.scope.generateUidIdentifier(\n    functionId ? functionId.name : \"ref\",\n  );\n\n  let wrapper: t.Function = buildWrapper({\n    NAME: functionId,\n    REF: ref,\n    FUNCTION: built,\n    PARAMS: params,\n  });\n\n  if (!isDeclaration) {\n    wrapper = toExpression(wrapper);\n    nameFunction({\n      node: wrapper,\n      parent: (path as NodePath<t.FunctionExpression>).parent,\n      scope: path.scope,\n    });\n  }\n\n  if (isDeclaration || wrapper.id || (!ignoreFunctionLength && params.length)) {\n    path.replaceWith(wrapper);\n    path.parentPath.scope.push({ id: cloneNode(ref) });\n  } else {\n    // we can omit this wrapper as the conditions it protects for do not apply\n    path.replaceWith(built);\n  }\n}\n\nexport default function wrapFunction(\n  path: NodePath<t.Function>,\n  callId: t.Expression,\n  // TODO(Babel 8): Consider defaulting to false for spec compliance\n  noNewArrows: boolean = true,\n  ignoreFunctionLength: boolean = false,\n) {\n  if (path.isMethod()) {\n    classOrObjectMethod(path, callId);\n  } else {\n    plainFunction(\n      path as NodePath<Exclude<t.Function, t.Method>>,\n      callId,\n      noNewArrows,\n      ignoreFunctionLength,\n    );\n  }\n}\n"],"mappings":"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"}